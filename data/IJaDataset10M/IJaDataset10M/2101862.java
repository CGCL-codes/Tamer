package ssii2009.mips.architectures;

import java.awt.Color;
import java.awt.Graphics;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.Random;
import javax.swing.JFileChooser;
import javax.swing.JScrollPane;

/**
 *
 * @author Jose
 */
public class ChronogramView extends javax.swing.JFrame {

    private File file;

    private SignalsValuesAndIntervals[] SignalsValuesIntervals;

    private int cursor;

    private int numberSignals;

    private JScrollPane scroll;

    /** Creates new form ChronogramView2 */
    public ChronogramView() {
        initComponents();
        scroll = new JScrollPane();
        scroll.setViewportView(this.getContentPane());
        file = null;
        cursor = 0;
    }

    private void drawIntervals(Graphics g) {
        int coordXinicial = 0;
        Integer intervalo = 0;
        String inter = intervalo.toString();
        for (int j = 0; j < 60; j++) {
            g.drawString(inter, 100 + coordXinicial, 100);
            g.drawLine(100 + coordXinicial, 110, 100 + coordXinicial, 900);
            coordXinicial = coordXinicial + 50;
            intervalo = intervalo + 500;
            inter = intervalo.toString();
        }
    }

    private void drawValuesAndSignals(Graphics g) {
        int height = 20;
        Color c = Color.BLACK;
        Color colorAnt = c;
        float int1;
        float int2;
        SignalsValuesAndIntervals svi;
        String intervalPrec;
        String intervalSuc;
        String valor;
        int valorAct = 0;
        int valorSig = 0;
        int coordX = 0;
        int coordY = 0;
        int coordXrect = 0;
        int coordYrect = 0;
        int fin;
        int coordXini = 5;
        for (int i = 0; i < this.cursor; i++) {
            g.setColor(Color.BLACK);
            g.drawString(this.SignalsValuesIntervals[i].getName(), coordXini, 150 + coordY);
            svi = SignalsValuesIntervals[i];
            fin = svi.getCursor();
            coordX = 100;
            c = this.setColor(colorAnt);
            g.setColor(c);
            colorAnt = c;
            for (int m = 0; m < fin; m++) {
                intervalPrec = svi.getIntervalI(m);
                if (m + 1 < fin) {
                    intervalSuc = svi.getIntervalI(m + 1);
                } else {
                    intervalSuc = intervalPrec;
                }
                int1 = Float.parseFloat(intervalPrec);
                int2 = Float.parseFloat(intervalSuc);
                valor = svi.getValueI(m);
                coordXrect = this.calculaCoordenada(int2);
                if (int1 != int2) {
                    g.setColor(c);
                    g.fillRect(coordX, 135 + coordY, coordXrect, height);
                }
                g.setColor(Color.RED);
                if (int1 != int2) {
                    g.drawString(valor, coordX, 135 + coordY + 15);
                }
                valorAct = Integer.parseInt(valor);
                if (m + 1 < fin) {
                    valorSig = Integer.parseInt(svi.getValueI(m + 1));
                }
                if (valorAct != valorSig) {
                    coordX = coordXrect;
                    c = this.setColor(colorAnt);
                    g.setColor(c);
                }
                colorAnt = c;
            }
            coordY = coordY + 30;
        }
    }

    private Color setColor(Color c) {
        Color[] colores = new Color[2];
        colores[0] = Color.BLUE;
        colores[1] = Color.WHITE;
        Random rand = new Random();
        int i = rand.nextInt(2);
        while (c == colores[i]) {
            i = rand.nextInt(2);
        }
        return colores[i];
    }

    private int calculaCoordenada(float i1) {
        int coord = 100;
        float inicio = 0;
        while (inicio < i1) {
            inicio = inicio + 500;
            coord = coord + 50;
        }
        float resta = inicio - i1;
        while (resta > 0) {
            resta = resta - 100;
            coord = coord - 10;
        }
        return coord;
    }

    public void paint(Graphics g) {
        this.OptionsMenu.setVisible(true);
        if (file != null) {
            super.paint(g);
            drawIntervals(g);
            drawValuesAndSignals(g);
        }
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    private void initComponents() {
        jMenuBar1 = new javax.swing.JMenuBar();
        OptionsMenu = new javax.swing.JMenu();
        LoadFileMenuItem = new javax.swing.JMenuItem();
        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        OptionsMenu.setText("Options");
        LoadFileMenuItem.setText("Load File");
        LoadFileMenuItem.addActionListener(new java.awt.event.ActionListener() {

            public void actionPerformed(java.awt.event.ActionEvent evt) {
                LoadFileMenuItemActionPerformed(evt);
            }
        });
        OptionsMenu.add(LoadFileMenuItem);
        jMenuBar1.add(OptionsMenu);
        setJMenuBar(jMenuBar1);
        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(0, 402, Short.MAX_VALUE));
        layout.setVerticalGroup(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING).add(0, 290, Short.MAX_VALUE));
        pack();
    }

    private void LoadFileMenuItemActionPerformed(java.awt.event.ActionEvent evt) {
        CargarFichero();
        LeerFichero();
    }

    private boolean CargarFichero() {
        JFileChooser explorador = new JFileChooser();
        explorador.setDialogTitle("Seleccionar fichero log");
        int seleccion = explorador.showOpenDialog(this);
        if (seleccion == JFileChooser.APPROVE_OPTION) {
            this.file = explorador.getSelectedFile();
            return true;
        } else return false;
    }

    private void LeerFichero() {
        FileReader fl = null;
        BufferedReader buffer = null;
        try {
            fl = new FileReader(this.file);
            buffer = new BufferedReader(fl);
            numberSignals = NumberOfSignals(buffer);
            SignalsValuesIntervals = new SignalsValuesAndIntervals[numberSignals];
            ReadSignals();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (fl != null) {
                    fl.close();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    private void ReadSignals() {
        String line;
        FileReader fl = null;
        BufferedReader buffer = null;
        try {
            fl = new FileReader(this.file);
            buffer = new BufferedReader(fl);
            String interval = "";
            String signal = "";
            String value = "";
            while ((line = buffer.readLine()) != null) {
                if (line.length() < 5) continue;
                if (line.substring(0, 5).equals("[INFO")) {
                    interval = ReadInterval(line);
                    signal = ReadSignal(line);
                    value = ReadValue(line);
                    if (!isSignal(signal, SignalsValuesIntervals) && !signal.equals("")) {
                        SignalsValuesIntervals[cursor] = new SignalsValuesAndIntervals(signal, numberSignals);
                        SignalsValuesIntervals[cursor].addValueAndInterval(value, interval);
                        cursor++;
                    } else {
                        buscaYAnade(signal, interval, value);
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void buscaYAnade(String s, String i, String v) {
        if (!s.equals("")) {
            int j = 0;
            while (j < cursor && !SignalsValuesIntervals[j].getName().equals(s)) {
                j++;
            }
            SignalsValuesIntervals[j].addValueAndInterval(v, i);
        }
    }

    private boolean isSignal(String signal, SignalsValuesAndIntervals[] s) {
        int i = 0;
        while (i < cursor) {
            if (s[i].getName().equals(signal)) {
                return true;
            }
            i++;
        }
        return false;
    }

    private String ReadInterval(String line) {
        int i = 0;
        String inter = "";
        while (line.charAt(i) != ']') {
            i++;
        }
        if (line.charAt(i) != ':') {
            i++;
        }
        while (!isNumber(line.charAt(i))) {
            i++;
        }
        while (line.charAt(i) != ' ') {
            inter = inter + line.charAt(i);
            i++;
        }
        return inter;
    }

    private boolean isNumber(char n) {
        if (n >= '0' && n <= '9') {
            return true;
        } else {
            return false;
        }
    }

    private String ReadSignal(String line) {
        int i = 0;
        String signal = "";
        while (line.charAt(i) != '<' && line.charAt(i) != '-') {
            i++;
        }
        int size = 0;
        while (!esLetra(line.charAt(i))) {
            i++;
        }
        while (esLetra(line.charAt(i))) {
            signal = signal + line.charAt(i);
            i++;
        }
        i++;
        String saux = "";
        while (esLetra(line.charAt(i))) {
            saux = saux + line.charAt(i);
            i++;
        }
        if (!signal.equals("Clock")) {
            signal = signal + ":" + saux;
        }
        return signal;
    }

    private String ReadValue(String line) {
        int pos = line.indexOf("::");
        String value = line.substring(pos + 2);
        return value.replaceAll(" ", "");
    }

    private boolean esLetra(char letra) {
        if ((letra >= 'A' && letra <= 'Z') || (letra >= 'a' && letra <= 'z')) {
            return true;
        } else {
            return false;
        }
    }

    private int NumberOfSignals(BufferedReader buf) {
        String line;
        int number = 0;
        try {
            while ((line = buf.readLine()) != null) {
                number = number + 1;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return number;
    }

    /**
    * @param args the command line arguments
    */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                new ChronogramView().setVisible(true);
            }
        });
    }

    private javax.swing.JMenuItem LoadFileMenuItem;

    private javax.swing.JMenu OptionsMenu;

    private javax.swing.JMenuBar jMenuBar1;
}
