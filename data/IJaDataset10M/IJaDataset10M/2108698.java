package net.sf.snver.pileup.core;

import net.sf.snver.pileup.AbstructSnverObject;
import net.sf.snver.pileup.meta.SnverMeta;
import net.sf.snver.pileup.util.NumFormat;
import net.sf.snver.pileup.util.math.BinomBinom;
import net.sf.snver.pileup.util.math.StrandBias;
import org.apache.commons.math.MathException;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Properties;
import static net.sf.snver.pileup.config.Dictionary.*;

public class CoreAnalysis {

    private static CoreAnalysis coreAnalysis = null;

    public int failed;

    public Float present;

    private AbstructSnverObject handler = null;

    public CoreAnalysis() {
        this.failed = 0;
        this.present = 1f;
    }

    public void setHandler(AbstructSnverObject handler) {
        this.handler = handler;
    }

    public void printoutIndividual(String chr, String pos, String ref, String filter, double pvalue, String alt, int altCount, int depth, double fisher, double sp, int altfor, int altrev, int reffor, int refrev, double gt0, double gt1, double gt2, PrintWriter out) {
        double gt = gt0 + gt1 + gt2;
        double GQ0 = (-1) * 10 * (Math.log10(gt0 / gt));
        double GQ1 = (-1) * 10 * (Math.log10(gt1 / gt));
        double GQ2 = (-1) * 10 * (Math.log10(gt2 / gt));
        String genotype = null;
        double min = Math.min(Math.min(GQ0, GQ1), GQ2);
        if (min == GQ0) {
            genotype = "0/0";
        } else if (min == GQ1) {
            genotype = "1/0";
        } else {
            genotype = "1/1";
        }
        String format = "AC1:AC2:RC1:RC2:GT:PL";
        String id = ".";
        String qual = ".";
        String sample = altfor + ":" + altrev + ":" + reffor + ":" + refrev + ":" + genotype + ":" + NumFormat.formatDouble1(GQ2) + "," + NumFormat.formatDouble1(GQ1) + "," + NumFormat.formatDouble1(GQ0);
        String info = "DP=" + depth + ";AC=" + altCount + ";FS=" + NumFormat.formatDouble(fisher) + ";SP=" + NumFormat.formatDouble(sp) + ";PV=" + pvalue;
        out.println(chr + "\t" + pos + "\t" + id + "\t" + ref + "\t" + alt + "\t" + qual + "\t" + filter + "\t" + info + "\t" + format + "\t" + sample);
    }

    /**
     * Close the file handler
     */
    public void close() {
    }

    /**
     * Make the singleton instance for CoreAnalysis
     *
     * @param properties Properties
     * @return boolean
     */
    public static boolean makeInstance(Properties properties) {
        if (coreAnalysis == null) {
            return true;
        }
        return false;
    }

    /**
     * Get singleton instance
     *
     * @return CoreAnalysis
     */
    public static CoreAnalysis getInstance() throws FileNotFoundException {
        if (coreAnalysis == null) return new CoreAnalysis();
        return coreAnalysis;
    }

    /**
     * Private constructor
     *
     * @param properties Properties
     * @throws FileNotFoundException Error in file operations
     */
    private CoreAnalysis(Properties properties) throws FileNotFoundException {
    }

    /**
     * Print the vcf header
     *
     * @param out  PrintWriter
     * @param name String
     */
    public static void printHeader(PrintWriter out, String name) {
        out.print("##fileformat=VCFv4.0\n");
        out.print("##INFO=<ID=DP,Number=1,Type=Integer,Description=\"Total Depth\">\n");
        out.print("##INFO=<ID=AC,Number=1,Type=Integer,Description=\"Alternative Allele Count\">\n");
        out.print("##INFO=<ID=FS,Number=.,Type=Float,Description=\"Fisher's Exact Pvalue\">\n");
        out.print("##INFO=<ID=SP,Number=.,Type=Float,Description=\"Strand Bias Pvalue\">\n");
        out.print("##INFO=<ID=PV,Number=.,Type=Float,Description=\"Pvalue generated by SNVer\">\n");
        out.print("##FORMAT=<ID=AC1,Number=1,Type=Integer,Description=\"Alternative Allele Count Forward\">\n");
        out.print("##FORMAT=<ID=AC2,Number=1,Type=Integer,Description=\"Alternative Allele Count Reverse\">\n");
        out.print("##FORMAT=<ID=RC1,Number=1,Type=Integer,Description=\"Reference Allele Count Forward\">\n");
        out.print("##FORMAT=<ID=RC2,Number=1,Type=Integer,Description=\"Reference Allele Count Reverse\">\n");
        out.print("##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">\n");
        out.print("##FORMAT=<ID=PL,Number=1,Type=Float,Description=\"Phred Scaled Posterior Probablity of AA,AB,BB\">\n");
        out.print("#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT");
        out.print("\t" + name);
        out.print("\n");
    }

    /**
     * Print the count file Header for debug
     *
     * @param out PrintWriter
     */
    public static void printCountHeader(PrintWriter out) {
        out.println("CHR\tPOS\tREF\tA\tC\tG\tT\ta\tc\tg\tt\tindel\terror_estimate\tweighted_error_estimate");
    }

    /**
     * Print meta information into vcf file
     *
     * @param meta SnverMeta
     * @param out  PrintWriter
     */
    public void print(SnverMeta meta, Properties properties, PrintWriter out) {
        if (meta.isEmpty()) return;
        int mq = Integer.valueOf((String) properties.get(THRESHOLD_MQ));
        out.println(meta.getChromosome() + "\t" + meta.getIndex() + "\t" + meta.getRef() + "\t" + meta.getForwardBaseNum('A') + "\t" + meta.getForwardBaseNum('C') + "\t" + meta.getForwardBaseNum('G') + "\t" + meta.getForwardBaseNum('T') + "\t" + meta.getReverseBaseNum('A') + "\t" + meta.getReverseBaseNum('C') + "\t" + meta.getReverseBaseNum('G') + "\t" + meta.getReverseBaseNum('T') + "\t" + meta.getIndel() + "\t" + meta.getErrorEstimate() + "\t" + meta.getCorrectedWeitghtedErrorEstimate(mq));
    }

    /**
     * Evaluate SnverMeta for output
     *
     * @param meta SnverMeta
     * @param out  PrintWriter
     * @throws MathException Error in Calculation
     */
    public void analyze(SnverMeta meta, Properties properties, PrintWriter out, PrintWriter log) throws MathException {
        int mq = Integer.valueOf((String) properties.get(THRESHOLD_MQ));
        int n = Integer.valueOf((String) properties.get(OPTION_HAPLOIDS));
        double het = Double.valueOf((String) properties.get(OPTION_HETEROZYGOSITY));
        double theta = Double.valueOf((String) properties.get(OPTION_THETA));
        double pValue = 2.0;
        double err = meta.getCorrectedWeitghtedErrorEstimate(mq);
        double gt0;
        double gt1;
        double gt2;
        double strandBias;
        double fisherExact;
        char alt = meta.getMostAltBase();
        int refFor = meta.getForwardBaseNum(meta.getRef());
        int refRev = meta.getReverseBaseNum(meta.getRef());
        int altFor = meta.getForwardBaseNum(alt);
        int altRev = meta.getReverseBaseNum(alt);
        int count = meta.getCount(alt);
        int total = meta.getTotal();
        strandBias = StrandBias.StrandBias(altFor, altRev);
        fisherExact = StrandBias.Fisher(refFor, refRev, altFor, altRev);
        if (test(meta, properties, log)) {
            meta.setPass(true);
        } else {
            meta.setPass(false);
        }
        if (meta.isEmpty()) return;
        if (meta.isOnlyRef()) alt = meta.getRef();
        pValue = BinomBinom.pool_binom(count, n, total, err, theta);
        gt0 = BinomBinom.dbinombinom(count, n, total, err, 0) * (1 - 3 * het / 2);
        gt1 = BinomBinom.dbinombinom(count, n, total, err, 0.5) * het;
        gt2 = BinomBinom.dbinombinom(count, n, total, err, 1) * (het / 2);
        String filter = meta.isPass() ? "PASS" : "FAILED";
        printoutIndividual(meta.getChromosome(), String.valueOf(meta.getIndex()), String.valueOf(meta.getRef()), filter, pValue, String.valueOf(alt), count, total, fisherExact, strandBias, altFor, altRev, refFor, refRev, gt0, gt1, gt2, out);
    }

    public boolean test(SnverMeta meta, Properties properties, PrintWriter errorLog) throws MathException {
        double FISHER = Double.valueOf(properties.getProperty(THRESHOLD_FISHER));
        double STRAND = Double.valueOf(properties.getProperty(THRESHOLD_STRAND));
        int N = Integer.valueOf(properties.getProperty(OPTION_HAPLOIDS));
        double ALT_REF_RATIO = Double.valueOf(properties.getProperty(OPTION_RATIO));
        int LEAST = Integer.valueOf(properties.getProperty(OPTION_A));
        int UPPER = Integer.valueOf(properties.getProperty(OPTION_TEST));
        double strandBias;
        double fisherExact;
        char alt = meta.getMostAltBase();
        int refFor = meta.getForwardBaseNum(meta.getRef());
        int refRev = meta.getReverseBaseNum(meta.getRef());
        int altFor = meta.getForwardBaseNum(alt);
        int altRev = meta.getReverseBaseNum(alt);
        int indel = meta.getIndel();
        if (refFor < 0 || refRev < 0 || altFor < 0 || altRev < 0) {
            System.err.println("Invalid record found");
            errorLog.println("[Invalid] :\t\t" + meta.printCount());
            return false;
        }
        if (meta.isEmpty()) {
            return false;
        }
        if (altFor + altRev < indel) {
            errorLog.println("[Indel Significant] :\t\t" + meta.printCount());
            return false;
        }
        if (meta.isOnlyRef()) {
            return true;
        }
        if (altFor < LEAST || altRev < LEAST) {
            errorLog.println("[Not Supported for Each Strand] :\t\t" + meta.printCount());
            return false;
        }
        double ref = refFor + refRev;
        if (ref > 0 && ((altFor + altRev) / ref) < ALT_REF_RATIO) {
            errorLog.println("[Not Meet the Alt/Ref Ratio] :\t\t" + meta.printCount());
            return false;
        }
        if (altFor + altRev > UPPER) {
            return true;
        }
        strandBias = StrandBias.StrandBias(altFor, altRev);
        fisherExact = StrandBias.Fisher(refFor, refRev, altFor, altRev);
        if (fisherExact < FISHER || strandBias < STRAND) {
            errorLog.println("[Failed in Fisher / Strand Test] :\t\t" + meta.printCount());
            return false;
        }
        return true;
    }

    /**
     * Calculate P value
     *
     * @param meta SnverMeta
     * @return double
     */
    public double getpValue(SnverMeta meta, Properties properties) {
        if (meta.getMostAltBase() == 0) return 1.0;
        int n = Integer.valueOf((String) properties.get(OPTION_HAPLOIDS));
        double theta = Double.valueOf((String) properties.get(OPTION_THETA));
        int mq = Integer.valueOf((String) properties.get(THRESHOLD_MQ));
        return BinomBinom.pool_binom(meta.getCount(meta.getMostAltBase()), n, meta.getTotal(), meta.getCorrectedWeitghtedErrorEstimate(mq), theta);
    }
}
