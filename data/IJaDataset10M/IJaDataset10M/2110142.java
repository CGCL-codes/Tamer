package org.xmlcml.schemagen;

import java.io.IOException;
import java.util.Iterator;
import java.util.Set;
import org.xmlcml.schemagen.cml.base.CMLException;
import org.xmlcml.schemagen.cml.base.CMLType;
import org.xmlcml.schemagen.cml.element.CMLTypeList;

/**
 * generates CML* classes from schema.
 * 
 * @author pm286
 * 
 */
public class TextWriter extends ClassWriter {

    TextProcessor ag;

    String name;

    String cmlName;

    String abstractName;

    MethodGenerator mg;

    CMLType cmlType;

    /**
     * constructor.
     * 
     * @param ag
     * @param name
     * @throws IOException
     */
    public TextWriter(TextProcessor ag, String name) throws IOException {
        super(name);
        this.name = name;
        this.ag = ag;
        setPackage(OUTPUT_TEXT);
        setSimpleDoc("user-modifiable class supporting text in " + name);
        setFullDoc("autogenerated from schema\n" + "use as a shell which can be edited");
        addImport("java.util.Map");
        addImport("java.util.HashMap");
        addImport(OUTPUT_BASE + ".*");
        addImport(OUTPUT_ATTRIBUTE + ".*");
        addImport("nu.xom.Attribute");
        FieldGenerator fg = new FieldGenerator(this, "Map", false, "textMap", "map of types by type name", "new HashMap()");
        fg.setStatic("static");
        this.addField(fg);
        fg = new FieldGenerator(this, "CMLAttribute", false, "cmlText", "??", "null");
        fg.setStatic("static");
        this.addField(fg);
        fg = new FieldGenerator(this, "String", false, "name", "??", "null");
        fg.setStatic("static");
        this.addField(fg);
        fg = new FieldGenerator(this, "String", false, "namex", "??", "null");
        fg.setStatic("static");
        this.addField(fg);
        mg = new MethodGenerator(this, "getText", "lookup CMLTexts by name");
        mg.setStatic("static");
        mg.setAccess("public");
        mg.setReturnType("CMLAttribute");
        mg.addArg("String", false, "name", "to lookup");
        mg.addLine("return (CMLAttribute) textMap.get(name);");
        this.addMethod(mg);
        mg = new MethodGenerator(this, "", "");
        mg.setStatic("static");
        mg.setAccess("");
        mg.addLine("try {");
        this.incrementIndent();
        mg.addLine("if (1 == 2) throw new CMLException(" + S_QUOT + "dummy" + S_QUOT + ");");
        Set keys = ag.textMap.keySet();
        for (Iterator it = keys.iterator(); it.hasNext(); ) {
            String attName = (String) it.next();
            TextProcessor ap = (TextProcessor) ag.textMap.get(attName);
            String cmlTypeS = ap.getBase();
            cmlType = CMLTypeList.getType(cmlTypeS);
            try {
                writeJavaX(attName);
            } catch (CMLException cmle) {
                throw new RuntimeException("bug " + cmle + "/" + attName);
            }
        }
        this.decrementIndent();
        mg.addLine("} catch (CMLException e) {");
        this.incrementIndent();
        mg.addLine("System.err.println(" + S_QUOT + "bug" + S_QUOT + "+e)" + EL());
        this.decrementIndent();
        mg.addLine("}");
        this.addMethod(mg);
        writeJavaMakeAttribute();
    }

    void writeJavaX(String attName) throws CMLException {
        if (cmlType == null) {
            throw new CMLException("Null cmlType");
        }
        String cmlAttribute = "cmlText";
        String base = cmlType.getBase();
        boolean isList = cmlType.getIsList();
        mg.addLine("name = " + S_QUOT + attName + S_QUOT + EL());
        if (isList) {
            if (base.equals(XSD_INTEGER)) {
                mg.addLine(cmlAttribute + " = new IntArrayAttribute(name)" + EL());
            } else if (base.equals(XSD_DOUBLE)) {
                mg.addLine(cmlAttribute + " = new DoubleArrayAttribute(name)" + EL());
            } else if (base.equals(XSD_STRING)) {
                mg.addLine(cmlAttribute + " = new StringArrayAttribute(name)" + EL());
            } else {
                throw new CMLException("bad base: " + base);
            }
        } else {
            if (base.equals(XSD_INTEGER)) {
                mg.addLine(cmlAttribute + " = new IntAttribute(name)" + EL());
            } else if (base.equals(XSD_DOUBLE)) {
                mg.addLine(cmlAttribute + " = new DoubleAttribute(name)" + EL());
            } else if (base.equals(XSD_STRING)) {
                mg.addLine(cmlAttribute + " = new StringAttribute(name)" + EL());
            } else {
                throw new CMLException("bad base: " + base + " in schemaType: " + ag.schemaType.getName());
            }
        }
        mg.addLine(cmlAttribute + ".setSchemaType(" + S_QUOT + cmlType.getName() + S_QUOT + ")" + EL());
        mg.addLine("textMap.put(name, " + cmlAttribute + ")" + EL());
        mg.addLine("");
    }

    void writeJavaMakeAttribute() {
        mg = new MethodGenerator(this, "makeAttribute", "make CMLAttributes");
        mg.setStatic("static");
        mg.setAccess("public");
        mg.setReturnType("Attribute");
        mg.addArg("String", false, "name", "attribute name");
        mg.addArg("String", false, "value", "attribute value");
        mg.addArg("String", false, "URI", "attribute URI");
        mg.addException("CMLException", "bad attribute name/value");
        this.addMethod(mg);
        mg.addLine("CMLAttribute attribute = null" + EL());
        VariableGenerator vg = new VariableGenerator(mg, "CMLAttribute", "attribute");
        vg.setStatic("xx");
        mg.addLine("if (" + S_NL);
        Set keys = ag.textMap.keySet();
        for (Iterator it = keys.iterator(); it.hasNext(); ) {
            String name = (String) it.next();
            mg.addLine("   name.equals(\"" + name + "\") ||");
        }
        mg.addLine("      false) {" + S_NL);
        mg.addLine("    attribute = new CMLAttribute(CMLTextList.getText(name))" + EL());
        mg.addLine("attribute.setCMLValue(value)" + EL());
        mg.addLine("}" + S_NL);
        mg.addLine("return attribute;" + S_NL);
    }
}
