package mipt.crec.muse.data;

import mipt.data.Data;
import mipt.data.MutableComparableData;
import mipt.data.event.DataModelEvent;
import mipt.data.event.DataModelEventSource;
import mipt.data.event.DataModelListener;

/**
 * Interface for data sending and receiving/loading in MUSE (in the agent or controller).
 * Loading is synchronous reading, receiving is asynchronous reading.
 * Sending a message is synchronous writing, but sending arrays is asynchronous writing.
 * Message is: command (from controller) or notification (from agent) or text (from both sides) 
 *  or parameter value(s) (from both sides); see {@link DataProtocol} for details.
 * 
 * TO SEND/RECEIVE ARRAYS ("unstructured data", in MUSE it's double or float): getArrayIO().
 * 
 * TO RECEIVE A MESSAGE: this.addDataModelListener(your DataModelAdapter with overridden dataChanged()).
 * Note: dataAdded() will be used to receive GET_DATA pseudo-events for loading, dataRemoved() won't be used.
 * To send a message: this.send(data).
 * To create the data for send(), you MUST call createData()
 *   (because existent DataIO implementations support IO of only one Data implementation).
 * Note: the data in all the above calls is a TEMPORARY request-scoped data (stored nowhere).
 * 
 * Note: Loading (used by the agent only) is reading STORED data for a specific module;
 *  the module is one for many configurations; all the configuration view the same status of the module.
 * TO LOAD: getDataLoader() in agent; setLoadingSender() in controller.
 *   
 * [To save (send) a part or a model previously loaded: data.set*(..). NOT REQUIRED => NOT SUPPORTED
 *  [To create data for save, createData() may be used but it should be wrapped by Composite data?] ]
 *
 * @author Alexey Evdokimov
 */
public interface DataIO extends DataModelEventSource, DataProtocol {

    /**
	 * Data type, XML element name.
	 */
    String EVENT = "event";

    /**
	 * Event Data field; has int values - defined by {@link DataModelEvent}.
	 * @see #send(Data)
	 */
    String TYPE = "type";

    /**
	 * Event Data field; has int values - defined by {@link DataProtocol}.
	 * @see #send(Data)
	 */
    String EVENT_TYPE = "eventType";

    /**
	 * The field of event Data with eventType={@link DataProtocol#EVENT_REQUEST}.
	 * The request usually requires a response (see {@link #RESPONSE_TYPE}) or other data 
	 * (see {@link DataProtocol#EVENT_TEXT}, {@link DataProtocol#EVENT_PARAMETER}) but can be also 
	 *  used for notifications without sending any response (almost all agent requests).
	 * Has String values - defined by client. Some of the values are:
	 *  * controller: "exit.agent", "start.module", "stop.module", "refresh.module", "send.params", "send.text", "save.text";
	 *  * agent: "send.root" (initialization), "no_module.error", "?.error"
	 *    "module.complete", "module.updated", "file.updated".
	 * The examples of other fields of such request event are:
	 *  * "filePath" (String)- for "send.text", "save.text", "file.updated", "send.params" request types;
	 *  * "exitCode" (int) - for "module.complete" request type;
	 *  * "progress" (double) - for "module.updated" request type;
	 * Note: there is no "message.received" request since it's event with eventType= {@link DataProtocol#EVENT_TEXT}. 
	 */
    String REQUEST_TYPE = "requestType";

    /**
	 * The field of event Data with eventType={@link DataProtocol#EVENT_RESPONSE}
	 *  (always secondary and final events).
	 * Has String values - defined by client and related to the values of appropriate {@link #REQUEST_TYPE}.
	 * Some of the values are:
	 *  * controller: "send.root" (with "modules" field of String[] type);
	 *  * agent: "exit.agent" (is also generated by finalization if the agent process is exiting by external reason),
	 *    "start.module", "stop.module", "save.text".
	 */
    String RESPONSE_TYPE = "responseType";

    /**
	 * Any event Data with eventType={@link DataProtocol#EVENT_RESPONSE}
	 *  must have this boolean field (failed or succeeded).
	 */
    String RESPONSE_SUCCESS = "success";

    /**
	 * All event Datas must have this String field - module global identifier
	 *  (because even an agent works with several modules, not to say about controller).
	 * The exceptions are events with requestType = "send.root", "exit.agent", "send.text", "save.text".
	 * Note: this identifier is in the form ID@path where ID and path are from "module" section of the configuration.
	 *  It's because ID is the identifier of module's metadata (i.e. ID is the same for all module instances)
	 *  and because path (=host[:port]@systemPath) can be the same for several modules (using the same data).
	 * TO DO: create the same field in responses to the requests (or we hope that the response
	 *  is received immediately after the request, and no responses of other agents are between them?!).
	 */
    String MODULE = "module";

    /**
	 *  The events received by the listener has {@link DataModelEvent#CHANGE} type
	 *  (in case of multiple parameters - {@link DataModelEvent#ADD} type),
	 *   and have the same EVENT_TYPE field (int - defined by {@link DataProtocol}).
	 *  The other possible fields are described in the comments to the constants of this interface.
	 * @see mipt.data.event.DataModelEventSource#addDataModelListener(mipt.data.event.DataModelListener)
	 */
    void addDataModelListener(DataModelListener l);

    /**
	 * Sends the message synchronously.
	 * //It is a convenience method for getUpdater().dataChanged(new DataModelEvent(.., message)).
	 * //@see DataModelOwner#getUpdater()
	 * @see #createData(int, String)
	 * @see #createDataElement(int)
	 * @return true if succeeded.
	 */
    boolean send(Data message);

    /**
	 * Call this method, fill its result with you field values and send the result.
	 * Do not create your own Data implementations for sending (until a special implementation
	 * of this interface will be created to support Data of any implementation class).
	 * @param eventType One of the {@link DataProtocol} constants
	 * @param messageType Null or a client-defined constant, see the examples in {@link #REQUEST_TYPE}
	 *  or in {@link #RESPONSE_TYPE} (depending on the event type - request or response).
	 * @return a Data with type={@link #EVENT} (this type is used as XML element name)
	 *  and with the following fields: {@link #TYPE} (always),{@link #EVENT_TYPE} (always),
	 *  {@link #REQUEST_TYPE} (if the event type is {@link DataProtocol#EVENT_REQUEST}),
	 *  {@link #RESPONSE_TYPE} (if the event type is {@link DataProtocol#EVENT_RESPONSE}).
	 */
    MutableComparableData createData(int eventType, String messageType);

    /**
	 * The same as {@link #createData(int, String)} but has the {@link DataIO#MODULE} field.
	 * Use this method for all events except for "send.root", "exit.agent", "send.text", "save.text".
	 */
    MutableComparableData createData(int eventType, String messageType, String moduleKey);

    /**
	 * The same as {@link #createData(int, String)} but used for sequence responses only:
	 * event type now can be {@link DataProtocol#EVENT_PARAMETER} only.
	 */
    MutableComparableData createDataElement(int eventType);

    /**
	 * Returns the object responsible for data loading. Is called in agent only.
	 */
    DataLoader getDataLoader();

    /**
	 * Sets the object responsible for data loading to send them for agent. Must be called by controller.
	 */
    void setLoadingSender(DataLoadingSender loadingSender);

    /**
	 * Affects the way how the module paths are stored in configurations;
	 *  if the port is not specified there, this port is used to find the modules
	 *  corresponding to the agent just connected.
	 * And of course, this port shows the IO itself the port to connect to by default.
	 */
    int getDefaultPort();
}
