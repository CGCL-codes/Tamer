package telespravochnik.obmen;

import telespravochnik.morda.ИДисплэй;
import telespravochnik.model.Запись;
import telespravochnik.protocols.ИПротокол;
import gnu.io.*;
import java.awt.Point;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.logging.Level;
import java.util.logging.Logger;
import telespravochnik.protocols.Носитель;

/**
 *
 * Класс для обмена данными между приложением и телефоном.
 */
public class ТелеОбменник implements Runnable {

    private static final Logger logger = Logger.getLogger(ТелеОбменник.class.getName());

    private final ИДисплэй дисплэй;

    private final BlockingQueue<СобытиеТелеЭкрана> очередь;

    private SerialPort порт;

    private boolean флагПортОткрыт;

    private OutputStream выход;

    private InputStream вход;

    private ИПротокол протокол;

    private Состояния состояние;

    private int диапМин;

    private int диапМакс;

    private Носитель выбранныйНоситель;

    private static final int РАЗМЕР_БУФЕРА = 100000;

    private static final int МАКС_ПРОДОЛЖИТЕЛЬНОСТЬ_МОЛЧАНИЯ = 850;

    private static final int СКОРОСТЬ_ПОРТА = 57600;

    private static final int ПАУЗА = 100;

    private final ByteBuffer ббуф = ByteBuffer.wrap(new byte[РАЗМЕР_БУФЕРА]);

    /**
     * Сразу же создаёт
     * @param дисплэй
     */
    public ТелеОбменник(ИДисплэй дисплэй, ИПротокол протокол) {
        this.дисплэй = дисплэй;
        очередь = new ArrayBlockingQueue<СобытиеТелеЭкрана>(100);
        this.протокол = протокол;
        состояние = Состояния.Ожидание;
    }

    /**
     * Вычитывает из буфера порта всё, что пришло, и выбрасывает это.
     * @return Количество вычитанных байт.
     */
    private int опустошиБуфер() throws IOException {
        int пришло = вход.available();
        if (пришло > 0) {
            byte[] мусор = new byte[пришло];
            вход.read(мусор);
        }
        ббуф.position(0);
        Arrays.fill(ббуф.array(), (byte) 0);
        return пришло;
    }

    /**
     * Отсылает команду в порт.
     * @param команда
     * @return Успешно ли отправил. true если успешно.
     */
    private void отправьКоманду(byte[] команда) throws IOException {
        logger.log(Level.FINE, "Отправлена команда: {0}", new String(команда));
        выход.write(команда);
    }

    /**
     * Принимает ответ от аппарата и помещает все байты в буфер.
     * Если приходит символ конца строки, то проверяет, не завершено ли сообщение.
     * Если оно завершено (аппарат возвратил сообщение об ошибке либо об успехе выполнения посланной команды),
     * то слушание прекращается.
     * Также оно прекращается, если аппарат слишком долго молчал.
     * @return
     */
    private РезультатОбмена получиОтвет() throws IOException {
        long времяПредъидЧтения = System.nanoTime();
        РезультатОбмена результат = РезультатОбмена.НеОкончено;
        while (результат == РезультатОбмена.НеОкончено) {
            int пришло = вход.available();
            if (пришло > 0) {
                logger.log(Level.FINE, "Пришло {0} байт", пришло);
                времяПредъидЧтения = System.nanoTime();
                for (int i = 0; i < пришло; i++) {
                    byte получен = (byte) вход.read();
                    ббуф.put(получен);
                    if (протокол.этоКонецСтроки(получен)) {
                        результат = протокол.какойРезультат(ббуф.array());
                    }
                }
            } else {
                try {
                    Thread.sleep(ПАУЗА);
                } catch (InterruptedException ex) {
                    return результат;
                }
                long сейчас = System.nanoTime();
                if ((сейчас - времяПредъидЧтения) > (МАКС_ПРОДОЛЖИТЕЛЬНОСТЬ_МОЛЧАНИЯ * 1000 * 1000)) {
                    результат = РезультатОбмена.ВремяИзтекло;
                }
            }
        }
        return результат;
    }

    /**
     * Отправляет телефону команду смены текущего носителя.
     * При успешной смене выясняет диапазон значений индексов записей в выбранном местоположении,
     * который потом изпользуется для чтения всех записей,
     * и сообщает его объекту дисплэя.
     * При безуспешной сообщает об ошибке.
     */
    private void смениНоситель(Носитель новыйНоситель) {
        try {
            опустошиБуфер();
            отправьКоманду(протокол.дайКомандуСменитьНоситель(новыйНоситель));
            РезультатОбмена результат = получиОтвет();
            if (результат == РезультатОбмена.Норма) {
                выбранныйНоситель = новыйНоситель;
                опустошиБуфер();
                отправьКоманду(протокол.дайКомандуУзнатьДиапазонИндексов());
                результат = получиОтвет();
                if (результат == РезультатОбмена.Норма) {
                    Point диапазон = протокол.узнайДиапазонИндексов(ббуф.array());
                    if (диапазон != null) {
                        диапМин = диапазон.x;
                        диапМакс = диапазон.y;
                        logger.log(Level.FINE, "Получен диапазон индексов: от {0} до {1}", new Integer[] { диапМин, диапМакс });
                        дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(РезультатОбмена.Норма, диапазон));
                    } else {
                        дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(РезультатОбмена.Ошибка));
                    }
                } else {
                    дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(результат));
                }
            } else {
                дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(результат));
            }
        } catch (IOException ex) {
            logger.log(Level.SEVERE, "Ошибка {0}", ex.toString());
            дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(РезультатОбмена.ОшибкаОбмена));
        }
    }

    /**
     * Отправляет телефону команду выдать все записи.
     */
    private void дайВсеЗаписи() {
        try {
            опустошиБуфер();
            отправьКоманду(протокол.дайКомандуИзвлечьВсеЗаписи(диапМин, диапМакс));
            РезультатОбмена результат = получиОтвет();
            if (результат == РезультатОбмена.Норма) {
                List<Запись> список = протокол.извлекиЗаписи(ббуф.array());
                logger.log(Level.FINE, "Получен список из {0} записей", список.size());
                дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(РезультатОбмена.Норма, список));
            } else {
                logger.log(Level.WARNING, "Ошибка излечения записей: {0}", результат.toString());
                дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(результат));
            }
        } catch (IOException ex) {
            logger.log(Level.WARNING, "Ошибка обмена: {0}", ex.toString());
            дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(РезультатОбмена.ОшибкаОбмена));
        }
    }

    /**
     * Отправляет в телефон запись на сохранение.
     * @param запись 
     */
    private void сохраниЗапись(Запись запись) {
        try {
            опустошиБуфер();
            отправьКоманду(протокол.дайКомандуСохранитьЗапись(запись));
            РезультатОбмена результат = получиОтвет();
            дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(результат));
        } catch (IOException ex) {
            logger.log(Level.WARNING, "Ошибка обмена {0}", ex.toString());
            дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(РезультатОбмена.ОшибкаОбмена));
        }
    }

    /**
     * Отправляет в телефон команду удаления записи.
     * @param ид - идентификатор удаляемой записи.
     */
    private void удалиЗапись(Integer ид) {
        try {
            опустошиБуфер();
            отправьКоманду(протокол.дайКомандуУдалитьЗапись(ид));
            РезультатОбмена результат = получиОтвет();
            дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(результат));
        } catch (IOException ex) {
            logger.log(Level.WARNING, "Ошибка обмена {0}", ex.toString());
            дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(РезультатОбмена.ОшибкаОбмена));
        }
    }

    /**
     * Открывает заданный порт и задаёт параметры передачи.
     * Результат сообщает слушателю.
     * @param обозначениеПорта Например, "/dev/ttyACM0" в GNU/Linux или "COM1" в Windows
     * @return 
     */
    private void откройПорт(String обозначениеПорта) {
        CommPortIdentifier phonePortId = null;
        try {
            logger.log(Level.FINE, "Открываю порт {0}", обозначениеПорта);
            phonePortId = CommPortIdentifier.getPortIdentifier(обозначениеПорта);
            порт = (SerialPort) phonePortId.open("TeleSpravochnik", 1000);
            порт.setSerialPortParams(СКОРОСТЬ_ПОРТА, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);
            выход = порт.getOutputStream();
            вход = порт.getInputStream();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, "Ошибка открытия порта", ex);
            флагПортОткрыт = false;
            дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(РезультатОбмена.Ошибка));
            return;
        }
        logger.log(Level.FINE, "Порт {0} открыт", обозначениеПорта);
        флагПортОткрыт = true;
        дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(РезультатОбмена.Норма));
    }

    private void закройПорт() {
        порт.close();
        logger.log(Level.FINE, "Порт {0} закрыт", порт.getName());
        дисплэй.получиРезультатОбмена(new ОтветТелеОбменника(РезультатОбмена.Норма));
    }

    @Override
    public void run() {
        СобытиеТелеЭкрана событие = null;
        while (!Thread.interrupted()) {
            try {
                событие = (СобытиеТелеЭкрана) очередь.take();
                logger.log(Level.FINE, "Получено событие {0}", событие);
                обработайСобытие(событие);
            } catch (InterruptedException ex) {
                logger.log(Level.FINE, "Поток обмена с портом прерван");
                break;
            }
        }
        if (флагПортОткрыт) {
            logger.log(Level.FINE, "Закрываю порт");
            закройПорт();
        }
    }

    /**
     * Метод для помещения события в очередь.
     * @param событие 
     */
    public void примиСобытие(СобытиеТелеЭкрана событие) {
        очередь.add(событие);
    }

    private void обработайСобытие(СобытиеТелеЭкрана событие) {
        if (флагПортОткрыт) {
            switch(событие.дайТип()) {
                case ЗакрытьПорт:
                    закройПорт();
                    флагПортОткрыт = false;
                    break;
                case СменитьНоситель:
                    смениНоситель((Носитель) событие.дайАргумент());
                    break;
                case ВыдатьВсеЗаписи:
                    дайВсеЗаписи();
                    break;
                case СохранитьЗапись:
                    сохраниЗапись((Запись) событие.дайАргумент());
                    break;
                case УдалитьЗапись:
                    удалиЗапись((Integer) событие.дайАргумент());
                    break;
            }
        } else {
            switch(событие.дайТип()) {
                case ОткрытьПорт:
                    откройПорт((String) событие.дайАргумент());
                    break;
                default:
                    logger.log(Level.WARNING, "Пришло неожиданное событие {0}", событие);
            }
        }
    }

    public enum Состояния {

        Ожидание, ЧтениеВсехЗаписей, ПереключениеНосителя, СохранениеЗаписи
    }
}
