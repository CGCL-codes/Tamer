package com.agentfactory.afapl.interpreter;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import com.agentfactory.clf.lang.IFormula;
import com.agentfactory.clf.lang.Predicate;
import com.agentfactory.clf.reasoner.IQueryable;

/**
 * This class contains the core belief management model for AgentSpeak. It
 * is responsible for maintaining the current beliefs of the agent, and for
 * generating events in response to belief updates.
 * 
 * @author rem
 */
public class BeliefManager implements IQueryable {

    /**
	 * This class is used to store information on beliefs that are to be added
	 * to / removed from the belief set. Updates generated by the Actions and Sensors
	 * are stored in the toAdd and toRemove lists as is appropriate. These lists
	 * are then used to update the belief model at the start of the next iteration
	 * of the interpreter cycle. This ensures that the belief model remains consistent
	 * for the duration of the current execution cycle.
	 *   
	 * @author rem
	 */
    private class BeliefItem {

        public Object source;

        public Predicate belief;

        public BeliefItem(Predicate belief, Object source) {
            this.belief = belief;
            this.source = source;
        }

        public boolean equals(Object obj) {
            if (!BeliefItem.class.isInstance(obj)) return false;
            BeliefItem item = (BeliefItem) obj;
            return item.belief.equals(belief) && (item.source == source);
        }
    }

    private Map<String, List<Predicate>> beliefMap;

    private List<BeliefItem> toAdd;

    private List<BeliefItem> toRemove;

    private List<Predicate> beliefs;

    public BeliefManager() {
        beliefMap = new HashMap<String, List<Predicate>>();
        new HashMap<String, List<Predicate>>();
        toAdd = new LinkedList<BeliefItem>();
        toRemove = new LinkedList<BeliefItem>();
        beliefs = new LinkedList<Predicate>();
    }

    /**
	 * Method to adopt a new belief. This method creates a belief item
	 * and stores it in the toAdd list (if a similar belief is not already
	 * in the list). If a similar belief is in the list, then the label
	 * lists are merged.
	 * 
	 * @param belief
	 * @param source
	 */
    public void adoptBelief(Predicate belief, Object source) {
        BeliefItem item = new BeliefItem(belief, source);
        if (!toAdd.contains(item)) {
            toAdd.add(item);
        } else {
            mergeSources(toAdd.get(toAdd.indexOf(item)).belief, belief);
        }
    }

    public void dropBelief(Predicate belief, Object source) {
        toRemove.add(new BeliefItem(belief, source));
    }

    public void manage() {
        for (BeliefItem item : toRemove) {
            removeBelief(item.belief, item.source);
        }
        for (BeliefItem item : toAdd) {
            addBelief(item.belief, item.source);
        }
        toAdd.clear();
        toRemove.clear();
    }

    public List<Predicate> beliefs() {
        return beliefs;
    }

    private void addBelief(Predicate belief, Object source) {
        boolean isNew = true;
        List<Predicate> list = beliefMap.get(belief.functor());
        if (list == null) {
            list = new LinkedList<Predicate>();
            beliefMap.put(belief.functor(), list);
        } else {
            int index = list.subList(0, list.size()).indexOf(belief);
            if (index >= 0) {
                isNew = false;
                mergeSources(list.get(index), belief);
            }
        }
        if (isNew) {
            list.add(belief);
            beliefs.add(belief);
        }
    }

    private void removeBelief(Predicate belief, Object source) {
        List<Predicate> list = beliefMap.get(belief.functor());
        if (list != null) {
            int i = list.indexOf(belief);
            if (i > -1) {
                if (belief.getLabels().isEmpty()) {
                    Predicate bel = list.remove(i);
                    beliefs.remove(bel);
                } else {
                    Predicate bel = list.get(i);
                    diffSources(bel, belief);
                    if (bel.getLabels().isEmpty()) {
                        list.remove(i);
                        beliefs.remove(belief);
                    }
                }
            }
        }
    }

    public void wipeBeliefs(String label) {
        Predicate lab = (Predicate) Utilities.factory.createFormula("source(" + label + ")");
        int index = 0;
        while (index < beliefs.size()) {
            if (Predicate.class.isInstance(beliefs.get(index))) {
                Predicate predicate = (Predicate) beliefs.get(index);
                int i = 0;
                while (i < predicate.getLabels().size()) {
                    if (predicate.getLabels().get(i).equals(lab)) {
                        predicate.getLabels().remove(i);
                    } else {
                        i++;
                    }
                }
                if (predicate.getLabels().isEmpty()) {
                    beliefs.remove(index);
                    beliefMap.get(predicate.functor()).remove(predicate);
                } else {
                    index++;
                }
            }
        }
    }

    private void mergeSources(Predicate existing, Predicate belief) {
        for (Predicate pred : belief.getLabels()) {
            if (!existing.getLabels().contains(pred)) {
                existing.getLabels().add(pred);
            }
        }
    }

    private void diffSources(Predicate existing, Predicate belief) {
        for (Predicate pred : belief.getLabels()) {
            existing.getLabels().remove(pred);
        }
    }

    @Override
    public boolean hasType(String type) {
        return true;
    }

    @Override
    public List<IFormula> query(IFormula query) {
        List<IFormula> list = new LinkedList<IFormula>();
        if (Predicate.class.isInstance(query)) {
            Predicate predicate = (Predicate) query;
            List<Predicate> bels = beliefMap.get(predicate.functor());
            if (bels != null) {
                for (Predicate fos : bels) {
                    if (fos.matches(predicate)) {
                        list.add(fos);
                    }
                }
            }
        }
        return list;
    }
}
