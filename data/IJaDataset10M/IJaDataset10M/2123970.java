package com.pentagaia.eclipse.sgs.prjconf;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.Stack;
import java.util.TreeMap;
import org.codehaus.plexus.util.StringInputStream;
import org.codehaus.plexus.util.StringOutputStream;
import org.eclipse.jface.preference.IPreferenceStore;
import com.pentagaia.eclipse.sgs.prjconf.IMavenModuleLayoutProject.ProjectTypes;

/**
 * Implementation of project configuration manager
 * 
 * @author mepeisen
 * @version 0.1.0
 * @since 0.1.0
 * 
 * @TODO Listener to fetch configuration changes
 */
public class ProjectConfigurationManager implements IProjectConfigurationManager {

    /** The project configurations created at runtime (f.e. by other plugins) */
    private final List<IProjectConfig> dynamicConfigurations = new ArrayList<IProjectConfig>();

    /** {@code false} if the configuration was not initialized */
    private boolean configInitialized = false;

    /** List of available configuration urls */
    private final TreeMap<String, IUrlConfigurationFactory> urlConfigurations = new TreeMap<String, IUrlConfigurationFactory>();

    /** List of project configurations generated by urls */
    private final Map<String, IProjectConfig> urlProjectConfigs = new TreeMap<String, IProjectConfig>();

    /** The preference store */
    private IPreferenceStore store;

    /** Key for the url preference */
    private static final String PREF_URLS = ProjectConfigurationManager.class.getName() + ".Prefs.urls";

    /** Key to list all properties */
    private static final String KEY_PROP_LIST = "props";

    /** The version key */
    private static final String KEY_VERSION = "version";

    /** Version 1 */
    private static final String VERSION_1 = "1";

    /** Suffix for the name */
    private static final String KEY_NAME = ".name";

    /** Suffix for the sort order */
    private static final String KEY_SORT_ORDER = ".sortOrder";

    /** Suffix for the url */
    private static final String KEY_URL = ".url";

    /** Suffix for the disabled flag */
    private static final String KEY_DISABLED = ".disabled";

    /** Suffix for the upgrades disabled flag */
    private static final String KEY_UPGRADES_DISABLED = ".upgradesDisabled";

    /** Suffix for the url type */
    private static final String KEY_TYPE = ".type";

    /** Type: File */
    private static final String TYPE_FILE = "file";

    /** Type: Web (http) */
    private static final String TYPE_WEB = "web(http)";

    /** Type: Initialized by class (built in) */
    private static final String TYPE_CLASS = "class";

    /**
     * Constructor
     * @param store
     */
    public ProjectConfigurationManager(final IPreferenceStore store) {
        this.store = store;
        this.initializeConfigs();
    }

    /**
     * Returns the available factories
     * 
     * @return factories
     */
    Iterable<IUrlConfigurationFactory> getFactories() {
        return this.urlConfigurations.values();
    }

    /**
     * Initializes the configuration urls from properties
     */
    private synchronized void initializeConfigs() {
        if (!this.configInitialized) {
            this.configInitialized = true;
            final Properties properties = new Properties();
            String prefs = this.store.getString(PREF_URLS);
            if (prefs == null || prefs.length() == 0) {
                properties.put(KEY_PROP_LIST, "0.1;1.1");
                properties.put(KEY_VERSION, VERSION_1);
                properties.put("0.1" + KEY_NAME, "Pentagaia online configuration");
                properties.put("0.1" + KEY_URL, UrlConfigurationPTBWeb.class.getName());
                properties.put("0.1" + KEY_DISABLED, "false");
                properties.put("0.1" + KEY_UPGRADES_DISABLED, "false");
                properties.put("0.1" + KEY_SORT_ORDER, "0");
                properties.put("0.1" + KEY_TYPE, TYPE_CLASS);
                properties.put("1.1" + KEY_NAME, "Pentagaia offline configuration");
                properties.put("1.1" + KEY_URL, UrlConfigurationPTBFile.class.getName());
                properties.put("1.1" + KEY_DISABLED, "false");
                properties.put("1.1" + KEY_UPGRADES_DISABLED, "false");
                properties.put("1.1" + KEY_SORT_ORDER, "1");
                properties.put("1.1" + KEY_TYPE, TYPE_CLASS);
                final StringOutputStream sos = new StringOutputStream();
                try {
                    properties.store(sos, null);
                    sos.flush();
                } catch (Exception e) {
                }
                this.store.setValue(PREF_URLS, sos.toString());
            } else {
                try {
                    properties.load(new StringInputStream(prefs));
                } catch (IOException e) {
                }
            }
            final String[] configs = properties.getProperty(KEY_PROP_LIST, "").split(";");
            for (final String configKey : configs) {
                final String name = properties.getProperty(configKey + KEY_NAME);
                final String url = properties.getProperty(configKey + KEY_URL);
                final boolean disabled = properties.getProperty(configKey + KEY_DISABLED).equals("true");
                final boolean upgradesDisabled = properties.getProperty(configKey + KEY_UPGRADES_DISABLED).equals("true");
                final int sortOrder = Integer.parseInt(properties.getProperty(configKey + KEY_SORT_ORDER));
                final String type = properties.getProperty(configKey + KEY_TYPE);
                IUrlConfigurationFactory factory = null;
                if (type.equals(TYPE_WEB)) {
                    factory = new UrlConfigurationWeb();
                } else if (type.equals(TYPE_FILE)) {
                    factory = new UrlConfigurationFile();
                } else if (type.equals(TYPE_CLASS)) {
                    try {
                        factory = Class.forName(url).asSubclass(IUrlConfigurationFactory.class).newInstance();
                    } catch (Exception e) {
                    }
                }
                if (factory == null) {
                    continue;
                }
                factory.setName(name);
                factory.setSortOrder(sortOrder);
                factory.setURL(url);
                if (disabled) {
                    factory.disable();
                }
                if (upgradesDisabled) {
                    factory.disableUpdates();
                }
                factory.save();
                this.urlConfigurations.put(configKey, factory);
            }
            final ProjectConfigReader reader = new ProjectConfigReader();
            for (final Map.Entry<String, IUrlConfigurationFactory> entry : this.urlConfigurations.entrySet()) {
                final InputStream stream = entry.getValue().read();
                if (stream != null) {
                    final IProjectConfig config = reader.parse(stream, entry.getValue());
                    if (config != null) {
                        this.urlProjectConfigs.put(entry.getKey(), config);
                    }
                }
            }
        }
    }

    /**
     * {@inheritDoc}
     * 
     * @see com.pentagaia.eclipse.sgs.prjconf.IProjectConfigurationManager#addProjectConfiguration(com.pentagaia.eclipse.sgs.prjconf.IProjectConfig, boolean)
     */
    @Override
    public synchronized void addProjectConfiguration(IProjectConfig config, boolean persistent) {
        if (persistent) {
            throw new IllegalStateException("Persistent configurations not yet supported");
        }
        this.dynamicConfigurations.add(config);
    }

    /**
     * {@inheritDoc}
     * 
     * @see com.pentagaia.eclipse.sgs.prjconf.IProjectConfigurationManager#getConfigReader()
     */
    @Override
    public IProjectConfigReader getConfigReader() {
        return new ProjectConfigReader();
    }

    /**
     * {@inheritDoc}
     * 
     * @see com.pentagaia.eclipse.sgs.prjconf.IProjectConfigurationManager#getProjectConfigurations()
     */
    @Override
    public synchronized IProjectConfig[] getProjectConfigurations() {
        final IProjectConfig[] result = new IProjectConfig[this.dynamicConfigurations.size() + this.urlProjectConfigs.size()];
        int i = 0;
        for (final IProjectConfig config : this.urlProjectConfigs.values()) {
            result[i] = config;
            i++;
        }
        for (final IProjectConfig config : this.dynamicConfigurations) {
            result[i] = config;
            i++;
        }
        return result;
    }

    /**
     * {@inheritDoc}
     * 
     * @see com.pentagaia.eclipse.sgs.prjconf.IProjectConfigurationManager#getProjectLayout(java.lang.String)
     */
    @Override
    public IProjectLayout getProjectLayout(String id) {
        if (id == null) {
            return null;
        }
        for (final IProjectConfig config : this.getProjectConfigurations()) {
            for (final IProjectLayout layout : config.getProjects()) {
                if (layout.getId().equals(id)) {
                    return layout;
                }
            }
        }
        return null;
    }

    /**
     * {@inheritDoc}
     * @see com.pentagaia.eclipse.sgs.prjconf.IProjectConfigurationManager#getServerRuntime(java.lang.String)
     */
    @Override
    public ISgsRuntime getServerRuntime(String version) {
        if (version == null) {
            return null;
        }
        for (final IProjectConfig config : this.getProjectConfigurations()) {
            for (final ISgsRuntime runtime : config.getSgsRuntimes()) {
                if (runtime.getSgsVersion().equals(version)) {
                    return runtime;
                }
            }
        }
        return null;
    }

    /**
     * Returns the effective app config file built from given layout and parent layouts
     * 
     * @param layout
     * @param dynamic {@code true} for dynamic app config and {@code false} for static app config
     * @return inherited maven module
     * @throws IllegalStateException thrown if there is a configuration error (endless loop)
     */
    public String getEffectiveAppConfig(final IProjectLayout layout, final boolean dynamic) {
        IProjectLayout current = layout;
        final Set<String> configSet = new HashSet<String>();
        configSet.add(layout.getId());
        while (current != null) {
            if (dynamic) {
                if (current.getDynamicAppConfig() != null) {
                    return current.getDynamicAppConfig();
                }
            } else {
                if (current.getStaticAppConfig() != null) {
                    return current.getStaticAppConfig();
                }
            }
            current = this.getProjectLayout(current.getProjectInheritance());
            if (current != null && configSet.contains(current.getId())) {
                throw new IllegalStateException("Endless loop while parsing project layout " + layout.getId());
            }
        }
        return null;
    }

    /**
     * Returns the effective source folders built from given layout and parent layouts
     * 
     * @param layout
     * @return source folders
     * @throws IllegalStateException thrown if there is a configuration error (endless loop)
     */
    public String[] getEffectiveSourceFolders(final IProjectLayout layout) {
        IProjectLayout current = layout;
        final Set<String> configSet = new HashSet<String>();
        configSet.add(layout.getId());
        while (current != null) {
            final String[] result = current.getSourceFolders();
            if (result != null && result.length != 0) {
                return result;
            }
            current = this.getProjectLayout(current.getProjectInheritance());
            if (current != null && configSet.contains(current.getId())) {
                throw new IllegalStateException("Endless loop while parsing project layout " + layout.getId());
            }
        }
        return DEFAULT_SOURCE_FOLDERS;
    }

    /**
     * Returns the effective maven repositories built from given layout and parent layouts
     * 
     * @param layout
     * @return maven repositories
     * @throws IllegalStateException thrown if there is a configuration error (endless loop)
     */
    public IMavenRepository[] getEffectiveRepositories(final IProjectLayout layout) {
        final Map<String, IMavenRepository> result = new HashMap<String, IMavenRepository>();
        final Set<String> configSet = new HashSet<String>();
        configSet.add(layout.getId());
        final Stack<IProjectLayout> layouts = new Stack<IProjectLayout>();
        IProjectLayout current = layout;
        while (current != null) {
            layouts.push(current);
            current = this.getProjectLayout(current.getProjectInheritance());
            if (current != null && configSet.contains(current.getId())) {
                throw new IllegalStateException("Endless loop while parsing project layout " + layout.getId());
            }
        }
        while (!layouts.isEmpty()) {
            for (final IMavenRepository repository : layouts.pop().getAdditionalRepositories()) {
                result.put(repository.getId(), repository);
            }
        }
        return result.values().toArray(new IMavenRepository[result.size()]);
    }

    /**
     * Returns the maven properties for given project layout
     * 
     * @param layout
     * @return maven properties
     * @throws IllegalStateException thrown if there is a configuration error (endless loop)
     */
    public Map<String, Map<String, String>> getEffectiveMavenProperties(final IProjectLayout layout) {
        final Map<String, Map<String, String>> result = new HashMap<String, Map<String, String>>();
        final Set<String> configSet = new HashSet<String>();
        configSet.add(layout.getId());
        final Stack<IProjectLayout> layouts = new Stack<IProjectLayout>();
        IProjectLayout current = layout;
        while (current != null) {
            layouts.push(current);
            current = this.getProjectLayout(current.getProjectInheritance());
            if (current != null && configSet.contains(current.getId())) {
                throw new IllegalStateException("Endless loop while parsing project layout " + layout.getId());
            }
        }
        while (!layouts.isEmpty()) {
            for (final Map.Entry<String, Map<String, String>> entry : layouts.pop().getMavenProperties().entrySet()) {
                Map<String, String> props = result.get(entry.getKey());
                if (props == null) {
                    props = new HashMap<String, String>();
                    result.put(entry.getKey(), props);
                }
                props.putAll(entry.getValue());
            }
        }
        return result;
    }

    /**
     * Returns the effective maven dependencies built from given layout and parent layouts
     * 
     * @param layout
     * @param server {@code true} for server dependencies and {@code false} for client dependencies
     * @return maven dependencies
     * @throws IllegalStateException thrown if there is a configuration error (endless loop)
     */
    public IMavenModuleLayoutProject[] getEffectiveModuleLayoutDependencies(final IProjectLayout layout, final boolean server) {
        final List<IMavenModuleLayoutProject> result = new ArrayList<IMavenModuleLayoutProject>();
        final Set<String> configSet = new HashSet<String>();
        configSet.add(layout.getId());
        final Stack<IProjectLayout> layouts = new Stack<IProjectLayout>();
        IProjectLayout current = layout;
        while (current != null) {
            layouts.push(current);
            current = this.getProjectLayout(current.getProjectInheritance());
            if (current != null && configSet.contains(current.getId())) {
                throw new IllegalStateException("Endless loop while parsing project layout " + layout.getId());
            }
        }
        while (!layouts.isEmpty()) {
            for (final IMavenModuleLayoutDependency dep : layouts.pop().getModuleLayoutDependencies()) {
                final IMavenModuleLayout moduleLayout = dep.getLayout();
                IMavenModuleLayoutProject[] projects = EMPTY_PROJECTS;
                switch(dep.getType()) {
                    case TYPE_API:
                        projects = moduleLayout.getProjectsByType(server ? ProjectTypes.TYPE_SRV_API : ProjectTypes.TYPE_SRV_API);
                        break;
                    case TYPE_BASE:
                        projects = moduleLayout.getProjectsByType(server ? ProjectTypes.TYPE_SRV_BASE : ProjectTypes.TYPE_SRV_BASE);
                        break;
                    case TYPE_IMPL:
                        projects = moduleLayout.getProjectsByType(server ? ProjectTypes.TYPE_SRV_IMPL : ProjectTypes.TYPE_SRV_IMPL);
                        break;
                    case TYPE_CLI_API:
                        if (!server) {
                            projects = moduleLayout.getProjectsByType(ProjectTypes.TYPE_CLI_API);
                        }
                        break;
                    case TYPE_CLI_BASE:
                        if (!server) {
                            projects = moduleLayout.getProjectsByType(ProjectTypes.TYPE_CLI_BASE);
                        }
                        break;
                    case TYPE_CLI_IMPL:
                        if (!server) {
                            projects = moduleLayout.getProjectsByType(ProjectTypes.TYPE_CLI_IMPL);
                        }
                        break;
                    case TYPE_SRV_API:
                        if (server) {
                            projects = moduleLayout.getProjectsByType(ProjectTypes.TYPE_SRV_API);
                        }
                        break;
                    case TYPE_SRV_BASE:
                        if (server) {
                            projects = moduleLayout.getProjectsByType(ProjectTypes.TYPE_SRV_BASE);
                        }
                        break;
                    case TYPE_SRV_IMPL:
                        if (server) {
                            projects = moduleLayout.getProjectsByType(ProjectTypes.TYPE_SRV_IMPL);
                        }
                        break;
                    case TYPE_UNKNOWN:
                        break;
                }
                if (projects != null) {
                    for (final IMavenModuleLayoutProject project : projects) {
                        result.add(project);
                    }
                }
            }
        }
        return result.toArray(new IMavenModuleLayoutProject[result.size()]);
    }

    /**
     * Returns the effective maven dependencies built from given layout and parent layouts
     * 
     * @param layout
     * @return maven dependencies
     * @throws IllegalStateException thrown if there is a configuration error (endless loop)
     */
    public Map<String, IMavenModule[]> getEffectiveModuleDependencies(final IProjectLayout layout) {
        final Map<String, List<IMavenModule>> result = new HashMap<String, List<IMavenModule>>();
        final Set<String> configSet = new HashSet<String>();
        configSet.add(layout.getId());
        final Stack<IProjectLayout> layouts = new Stack<IProjectLayout>();
        IProjectLayout current = layout;
        while (current != null) {
            layouts.push(current);
            current = this.getProjectLayout(current.getProjectInheritance());
            if (current != null && configSet.contains(current.getId())) {
                throw new IllegalStateException("Endless loop while parsing project layout " + layout.getId());
            }
        }
        while (!layouts.isEmpty()) {
            for (final Map.Entry<String, IMavenModule[]> entry : layouts.pop().getModuleDependencies().entrySet()) {
                List<IMavenModule> list = result.get(entry.getKey());
                if (list == null) {
                    list = new ArrayList<IMavenModule>();
                    result.put(entry.getKey(), list);
                }
                for (final IMavenModule module : entry.getValue()) {
                    if (!list.contains(module)) {
                        list.add(module);
                    }
                }
            }
        }
        final Map<String, IMavenModule[]> resultMap = new HashMap<String, IMavenModule[]>();
        for (final Map.Entry<String, List<IMavenModule>> entry : result.entrySet()) {
            resultMap.put(entry.getKey(), entry.getValue().toArray(new IMavenModule[entry.getValue().size()]));
        }
        return resultMap;
    }

    /**
     * Returns the effective target folder built from given layout and parent layouts
     * 
     * @param layout
     * @return target folder
     * @throws IllegalStateException thrown if there is a configuration error (endless loop)
     */
    public String getEffectiveTargetFolder(final IProjectLayout layout) {
        IProjectLayout current = layout;
        final Set<String> configSet = new HashSet<String>();
        configSet.add(layout.getId());
        while (current != null) {
            final String result = current.getTargetFolder();
            if (result != null && result.length() != 0) {
                return result;
            }
            current = this.getProjectLayout(current.getProjectInheritance());
            if (current != null && configSet.contains(current.getId())) {
                throw new IllegalStateException("Endless loop while parsing project layout " + layout.getId());
            }
        }
        return DEFAULT_TARGET_FOLDER;
    }

    /**
     * Returns the effective maven inheritance built from given layout and parent layouts
     * 
     * @param layout
     * @return inherited maven module
     * @throws IllegalStateException thrown if there is a configuration error (endless loop)
     */
    public IMavenModule getEffectiveInherit(final IProjectLayout layout) {
        IProjectLayout current = layout;
        final Set<String> configSet = new HashSet<String>();
        configSet.add(layout.getId());
        while (current != null) {
            if (current.getInheritedMavenModule() != null) {
                return current.getInheritedMavenModule();
            }
            current = this.getProjectLayout(current.getProjectInheritance());
            if (current != null && configSet.contains(current.getId())) {
                throw new IllegalStateException("Endless loop while parsing project layout " + layout.getId());
            }
        }
        return null;
    }

    /**
     * Returns the effective project configuration built from given layout and parent layouts
     * 
     * @param layout
     * @return project type
     * @throws IllegalStateException thrown if there is a configuration error (endless loop)
     */
    public IProjectLayout.ProjectTypes getEffectiveProjectType(final IProjectLayout layout) {
        IProjectLayout current = layout;
        final Set<String> configSet = new HashSet<String>();
        configSet.add(layout.getId());
        while (current != null) {
            if (current.getType() != IProjectLayout.ProjectTypes.TYPE_UNKNOWN) {
                return current.getType();
            }
            current = this.getProjectLayout(current.getProjectInheritance());
            if (current != null && configSet.contains(current.getId())) {
                throw new IllegalStateException("Endless loop while parsing project layout " + layout.getId());
            }
        }
        return IProjectLayout.ProjectTypes.TYPE_UNKNOWN;
    }

    /**
     * Stores the factories
     * 
     * @param added
     * @param changed
     * @param removed
     */
    synchronized void storeFactories(List<IUrlConfigurationFactory> added, List<IUrlConfigurationFactory> changed, List<IUrlConfigurationFactory> removed) {
        final IProjectConfigReader reader = this.getConfigReader();
        for (final IUrlConfigurationFactory factory : added) {
            final String lastKey = this.urlConfigurations.lastKey().split(".")[0];
            final String nextKey = String.valueOf(Integer.parseInt(lastKey) + 1) + ".1";
            this.urlConfigurations.put(nextKey, factory);
            final InputStream stream = factory.isActive() ? factory.read() : null;
            final IProjectConfig config = stream == null ? null : reader.parse(stream, factory);
            if (config != null) {
                this.urlProjectConfigs.put(nextKey, config);
            }
            factory.save();
        }
        for (final IUrlConfigurationFactory factory : changed) {
            for (final Map.Entry<String, IUrlConfigurationFactory> entry : this.urlConfigurations.entrySet()) {
                if (factory == entry.getValue()) {
                    final InputStream stream = factory.isActive() ? factory.read() : null;
                    final IProjectConfig config = stream == null ? null : reader.parse(stream, factory);
                    if (config != null) {
                        this.urlProjectConfigs.put(entry.getKey(), config);
                    } else {
                        this.urlProjectConfigs.remove(entry.getKey());
                    }
                    factory.save();
                    break;
                }
            }
        }
        for (final IUrlConfigurationFactory factory : removed) {
            for (final Map.Entry<String, IUrlConfigurationFactory> entry : this.urlConfigurations.entrySet()) {
                if (factory == entry.getValue()) {
                    this.urlProjectConfigs.remove(entry.getKey());
                    this.urlConfigurations.remove(entry.getKey());
                    break;
                }
            }
        }
        final Properties properties = new Properties();
        final StringBuffer props = new StringBuffer();
        properties.put(KEY_PROP_LIST, "0.1;1.1");
        properties.put(KEY_VERSION, VERSION_1);
        for (final Map.Entry<String, IUrlConfigurationFactory> entry : this.urlConfigurations.entrySet()) {
            if (props.length() > 0) {
                props.append(";");
            }
            props.append(entry.getKey());
            final IUrlConfigurationFactory factory = entry.getValue();
            properties.put(entry.getKey() + KEY_NAME, factory.getName());
            properties.put(entry.getKey() + KEY_DISABLED, factory.isActive() ? "true" : "false");
            properties.put(entry.getKey() + KEY_UPGRADES_DISABLED, factory.isUpgradeActive() ? "true" : "false");
            properties.put(entry.getKey() + KEY_SORT_ORDER, String.valueOf(factory.getSortOrder()));
            switch(factory.getUrlType()) {
                case TYPE_CLASS:
                    properties.put(entry.getKey() + KEY_TYPE, TYPE_CLASS);
                    properties.put(entry.getKey() + KEY_URL, factory.getClass().getName());
                    break;
                case TYPE_FILE:
                    properties.put(entry.getKey() + KEY_TYPE, TYPE_FILE);
                    properties.put(entry.getKey() + KEY_URL, factory.getURL());
                    break;
                case TYPE_WEB:
                    properties.put(entry.getKey() + KEY_TYPE, TYPE_WEB);
                    properties.put(entry.getKey() + KEY_URL, factory.getURL());
                    break;
            }
        }
    }
}
