package rpr2_d18.objectClassRepresentations;

import java.util.HashMap;
import hla.rti1516e.AttributeHandleValueMap;
import hla.rti1516e.AttributeHandleValueMapFactory;
import hla.rti1516e.RTIambassador;
import hla.rti1516e.ObjectInstanceHandle;
import hla.rti1516e.ObjectClassHandle;
import hla.rti1516e.AttributeHandle;
import hla.rti1516e.AttributeHandleSet;
import hla.rti1516e.encoding.DecoderException;
import hla.rti1516e.exceptions.AttributeNotDefined;
import hla.rti1516e.exceptions.FederateNotExecutionMember;
import hla.rti1516e.exceptions.InvalidAttributeHandle;
import hla.rti1516e.exceptions.InvalidInteractionClassHandle;
import hla.rti1516e.exceptions.InvalidObjectClassHandle;
import hla.rti1516e.exceptions.NameNotFound;
import hla.rti1516e.exceptions.NotConnected;
import hla.rti1516e.exceptions.ObjectClassNotDefined;
import hla.rti1516e.exceptions.ObjectClassNotPublished;
import hla.rti1516e.exceptions.RTIinternalError;
import hla.rti1516e.exceptions.RestoreInProgress;
import hla.rti1516e.exceptions.SaveInProgress;
import hla.rti1516e.encoding.DataElement;
import hla.rti1516e.encoding.ByteWrapper;
import hla.rti1516e.exceptions.RTIinternalError;
import hla.rti1516e.encoding.DecoderException;
import rpr2_d18.arrayDataRepresentations.BreachableSegmentArray;

/**
 * JAVADOC_COMMENTS
 * name : BreachableLinearObject
 * sharing : PublishSubscribe
 * semantics : A linear object that can be broken or ruptured.
 *
 * @author : auto generated by DRDC FOM Generator
 */
public class BreachableLinearObject extends LinearObject {

    private BreachableSegmentArray SegmentRecords;

    /**
   * Constructor
   */
    public BreachableLinearObject(RTIambassador rtiAmb) throws FederateNotExecutionMember, NotConnected {
        super(rtiAmb);
    }

    /**
   * Constructor
   */
    public BreachableLinearObject(RTIambassador rtiAmb, String className) throws NameNotFound, FederateNotExecutionMember, NotConnected, RTIinternalError {
        super(rtiAmb, className);
    }

    /**
   * Constructor
   */
    public BreachableLinearObject(RTIambassador rtiAmb, ObjectClassHandle classHandle) throws NameNotFound, InvalidObjectClassHandle, FederateNotExecutionMember, NotConnected, RTIinternalError {
        super(rtiAmb, classHandle);
    }

    /**
   * Constructor
   */
    public BreachableLinearObject(RTIambassador rtiAmb, ObjectClassHandle classHandle, String instanceName) throws NameNotFound, InvalidObjectClassHandle, FederateNotExecutionMember, NotConnected, RTIinternalError {
        super(rtiAmb, classHandle, instanceName);
    }

    /**
   * Constructor
   */
    public BreachableLinearObject(RTIambassador rtiAmb, String className, String instanceName) throws NameNotFound, InvalidObjectClassHandle, FederateNotExecutionMember, NotConnected, RTIinternalError {
        super(rtiAmb, className, instanceName);
    }

    /**
   * Constructor
   */
    public BreachableLinearObject(RTIambassador rtiAmb, String className, ObjectInstanceHandle instanceHandle, String instanceName) throws NameNotFound, InvalidObjectClassHandle, FederateNotExecutionMember, NotConnected, RTIinternalError {
        super(rtiAmb, className, instanceHandle, instanceName);
    }

    /**
   * Decode Attributes
   * Calls the decoder for each possible attribute
   * NOTE: since attributes are now in a map, order within the byte stream is not improtant
   */
    public void decodeAttributes(AttributeHandleValueMap attributes) throws NameNotFound, FederateNotExecutionMember, NotConnected, RTIinternalError, InvalidObjectClassHandle, DecoderException {
        super.decodeAttributes(attributes);
        SegmentRecords.decode(attributes.getValueReference(rtiAmb.getAttributeHandle(objectClassHandle, "SegmentRecords")));
    }

    /**
   * Encode Parameters
   * Adds each parameter to the parameter handle / value maop
   */
    public void encodeAttributes() throws NameNotFound, FederateNotExecutionMember, NotConnected, RTIinternalError, InvalidObjectClassHandle, DecoderException {
        super.encodeAttributes();
        addAttribute("SegmentRecords", SegmentRecords.toByteArray());
    }

    public BreachableSegmentArray getSegmentRecords() {
        return this.SegmentRecords;
    }

    public void setSegmentRecords(BreachableSegmentArray SegmentRecords) {
        this.SegmentRecords = SegmentRecords;
    }
}
