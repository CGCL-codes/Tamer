package jaxlib.util;

import java.net.InetAddress;
import java.net.NetworkInterface;
import java.security.AccessController;
import java.security.PrivilegedExceptionAction;
import java.security.SecureRandom;
import java.sql.Timestamp;
import java.util.Enumeration;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.prefs.Preferences;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import jaxlib.array.ByteArrays;
import jaxlib.lang.Longs;
import jaxlib.text.SimpleIntegerFormat;
import jaxlib.time.SystemNanoTime;

/**
 * {@link UUID} related utilities.
 *
 * @author  jw
 * @since   JaXLib 1.0
 * @version $Id: UUIDs.java 2983 2011-09-01 02:15:29Z joerg_wassmer $
 */
public final class UUIDs extends Object {

    private UUIDs() {
        super();
    }

    private static final long LEACH_SALZ_VARIANT = 0x8000000000000000L;

    private static final long NODE_MASK = 0xFFFFFFFFFFFFL;

    private static final int MAX_CLOCK_SEQUENCE = 0x3FFF;

    private static final long TO_BEGIN_OF_GREGORIAN_CALENDAR = 0x01B21DD213814000L;

    private static final long VERSION_1 = 0x1000L;

    public static final int LENGTH = 36;

    private static final long baseTime = SystemNanoTime.baseMillis * 10000;

    private static final SecureRandom random = new SecureRandom();

    private static final AtomicInteger clockSequence = new AtomicInteger(random.nextInt(MAX_CLOCK_SEQUENCE));

    private static final long sharedNodeRandom;

    static {
        long sharedRandom = 0;
        while ((sharedRandom <= 0) || (sharedRandom >= UUIDs.NODE_MASK)) sharedRandom = (long) (UUIDs.random.nextDouble() * NODE_MASK);
        sharedNodeRandom = sharedRandom;
    }

    private static final UUID sharedTimeBasedRandom = createTimeBasedRandom();

    private static long generateTimeBits() {
        final long t = nextTime();
        return (t << 32) | ((t & 0xFFFF00000000L) >> 16) | ((t >> 48) & 0x0FFF);
    }

    private static long nextClockSequence() {
        while (true) {
            final int v = UUIDs.clockSequence.incrementAndGet();
            if ((v >= 0) && (v <= MAX_CLOCK_SEQUENCE)) return ((long) v) << 48;
            UUIDs.clockSequence.compareAndSet(v, -1);
        }
    }

    private static long nextTime() {
        return UUIDs.baseTime + ((System.nanoTime() - SystemNanoTime.baseNanos) / 100) + TO_BEGIN_OF_GREGORIAN_CALENDAR;
    }

    /**
   * Create a new time based UUID which encodes a newly generated timestamp and the lower 48 of the specified node
   * bits.
   * The risk of dupes generated by this call is near zero, as long as you have no need to generate more than
   * 2<sup>60</sup> UUIDs for the same node bits per Java VM. Inside the same Java VM the risk is zero as long as
   * you are staying below the limit for same node bits.
   *
   * @throws IllegalArgumentException
   *  if the argument uses bits above the 48th.
   *
   * @see UUID#node()
   * @see UUID#timestamp()
   *
   * @since JaXLib 1.0
   */
    @Nonnull
    public static UUID createTimeBased(final long node) {
        if ((node & NODE_MASK) != node) throw new IllegalArgumentException("the argument uses bits above the 48th: " + Long.toHexString(node));
        return new UUID(VERSION_1 | generateTimeBits(), LEACH_SALZ_VARIANT | nextClockSequence() | node);
    }

    /**
   * Create a new time based UUID which also identifies the network interface address of the current runtime.
   * Each call returns a unique UUID which contains the first 6-byte hardware (MAC) address found and a newly
   * generated timestamp.
   * <p>
   * If the hardware address can not be determined, then this call uses a random number which is generated once per
   * operating system, if absent. If this class has not the privileges to store the random number on operating system
   * level, then it uses one stored on user level.
   * If latter also fails then a random number unique per Java VM is used.
   * </p>
   * {@stickWarning
   *  You should use this only in a trusted environment. It may affect your security needs when publishing the
   *  hardware address. There also is a high chance to create dupe UUIDs in multiple Java VMs running simultaneously
   *  on the same system. Additionaly there is no guarantee that hardware addresses are unique. It's a fact that there
   *  are dupes existing.
   * }
   * Supposing the hardware address is unique, the risk of dupes generated by this call is near zero, as long as you
   * have no need to generate more than 2<sup>60</sup> UUIDs per Java VM.
   *
   *
   * @see UUID#node()
   * @see UUID#timestamp()
   *
   * @since JaXLib 1.0
   */
    @Nonnull
    public static UUID createTimeBasedHw() {
        return UUIDs.SharedNodeHw.createTimeBasedHw();
    }

    /**
   * Create a new time based UUID with node bits shared per Java VM.
   * Each call returns an unique UUID with a newly generated timestamp, where in the same Java VM the node bits are
   * always the same. The risk of dupes generated by this call is near zero, as long as you have no need to generate
   * more than 2<sup>60</sup> UUIDs per Java VM. Inside the same Java VM the risk is zero as long as you are
   * staying below the limit.
   *
   * @see UUID#node()
   * @see UUID#timestamp()
   *
   * @since JaXLib 1.0
   */
    @Nonnull
    public static UUID createTimeBasedRandom() {
        return new UUID(VERSION_1 | generateTimeBits(), LEACH_SALZ_VARIANT | nextClockSequence() | UUIDs.sharedNodeRandom);
    }

    public static UUID fromBytes(@Nullable final byte[] a) {
        if ((a == null) || (a.length == 0)) return null;
        CheckArg.equals(16, a.length, "byte count");
        return new UUID(Longs.fromBytesLE(a, 0), Longs.fromBytesLE(a, 8));
    }

    /**
   * Get the node bits used by {@link #getSharedTimeBasedHw()}.
   *
   * @since JaXLib 1.0
   */
    public static long getSharedNodeHw() {
        return UUIDs.SharedNodeHw.sharedNodeHw;
    }

    /**
   * Get the node bits used by {@link #getSharedTimeBasedRandom()}.
   *
   * @since JaXLib 1.0
   */
    public static long getSharedNodeRandom() {
        return UUIDs.sharedNodeRandom;
    }

    /**
   * Get a shared time based UUID which identifies the process and the network interface address of the current
   * runtime. Each call in the same Java VM returns the same object.
   * This call uses the first 6-byte hardware (MAC) address found and a timestamp which is generated once per Java VM.
   * <p>
   * If the hardware address can not be determined, then this call uses a random number which is generated once per
   * operating system, if absent. If this class has not the privileges to store the random number on operating system
   * level, then it uses one stored on user level.
   * If latter also fails then a random number unique per Java VM is used.
   * </p>
   * {@stickWarning
   *  You should use this only in a trusted environment. It may affect your security needs when publishing the
   *  hardware address. Additionaly there is no guarantee that hardware addresses are unique. It's a fact that there
   *  are dupes existing.
   * }
   *
   * @since JaXLib 1.0
   */
    @Nonnull
    public static UUID getSharedTimeBasedHw() {
        return UUIDs.SharedNodeHw.sharedTimeBasedHw;
    }

    /**
   * Get a shared time based UUID which identifies the current runtime.
   * Each call in the same Java VM returns the same object.
   * This call uses a random number and a timestamp which are generated once per Java VM.
   *
   * @since JaXLib 1.0
   */
    @Nonnull
    public static UUID getSharedTimeBasedRandom() {
        return UUIDs.sharedTimeBasedRandom;
    }

    /**
   * Convert the timestamp carried by the specified uuid from 100-nanosecond units since
   * {@code 1582-10-15 00:00:00.000 UTC} to milliseconds since {@code 1970-01-01 00:00:00.000 UTC}.
   * This call looses precision below millisecond units.
   *
   * @see #getTimestamp(UUID)
   * @see UUID#timestamp()
   *
   * @since JaXLib 1.0
   */
    public static long getTimeInMillis(final UUID uuid) {
        return (uuid.timestamp() - TO_BEGIN_OF_GREGORIAN_CALENDAR) / 10000;
    }

    /**
   * Convert the timestamp carried by the specified uuid from 100-nanosecond units since
   * {@code 1582-10-15 00:00:00.000 UTC} to a SQL timestamp inclusive nanosecond fraction.
   *
   * @see UUID#timestamp()
   * @see Timestamp#getNanos()
   *
   * @since JaXLib 1.0
   */
    @Nonnull
    public static Timestamp getTimestamp(final UUID uuid) {
        final long a = uuid.timestamp() - TO_BEGIN_OF_GREGORIAN_CALENDAR;
        final long s = (a / 10000000) * 1000;
        final Timestamp ts = new Timestamp(s);
        ts.setNanos((int) ((a - (s * 10000)) * 100));
        return ts;
    }

    /**
   * Performance optimized version of {@link UUID#fromString(String) UUID.fromString(s)} as of Sun JDK 1.6
   *
   * @throws NullPointerException
   *  if the argument is {@code null}.
   * @throws IllegalArgumentException
   *  if the argument is not a valid {@code UUID}.
   *
   * @since JaXLib 1.0
   */
    @Nonnull
    public static UUID parse(final CharSequence s) {
        if (s.length() != 36) throw new IllegalArgumentException("malformed UUID: '" + s + "'");
        try {
            return new UUID(((((SimpleIntegerFormat.HEX.parseLong(s, 0, 8)) << 16) | ((long) SimpleIntegerFormat.HEX.parseInt(s, 9, 13))) << 16) | SimpleIntegerFormat.HEX.parseInt(s, 14, 18), (((long) SimpleIntegerFormat.HEX.parseInt(s, 19, 23)) << 48) | SimpleIntegerFormat.HEX.parseLong(s, 24, 36));
        } catch (final NumberFormatException ex) {
            throw new IllegalArgumentException("malformed UUID: '" + s + "'", ex);
        }
    }

    public static byte[] toBytes(@Nullable final UUID v) {
        if (v == null) return null;
        final byte[] a = new byte[16];
        Longs.toBytes(v.getMostSignificantBits(), a, 0);
        Longs.toBytes(v.getLeastSignificantBits(), a, 8);
        return a;
    }

    private static final class SharedNodeHw extends Object {

        static final long sharedNodeHw;

        static {
            long sharedHw = 0;
            try {
                final InetAddress a = InetAddress.getLocalHost();
                final NetworkInterface nic = NetworkInterface.getByInetAddress(a);
                if ((nic != null) && !nic.isLoopback() && !nic.isVirtual()) {
                    final byte[] mac = nic.getHardwareAddress();
                    if ((mac != null) && (mac.length == 6) && (ByteArrays.count(mac, (byte) 0) < 3)) sharedHw = Longs.fromBytesLE(mac[5], mac[4], mac[3], mac[2], mac[1], mac[0], (byte) 0, (byte) 0);
                }
            } catch (final Exception ex) {
                ex.printStackTrace();
            }
            if (sharedHw == 0) {
                try {
                    for (final Enumeration<NetworkInterface> it = NetworkInterface.getNetworkInterfaces(); it.hasMoreElements(); ) {
                        final NetworkInterface nic = it.nextElement();
                        if (!nic.isLoopback() && !nic.isVirtual()) {
                            final byte[] mac = nic.getHardwareAddress();
                            if ((mac != null) && (mac.length == 6) && (ByteArrays.count(mac, (byte) 0) < 3)) {
                                sharedHw = Longs.fromBytesLE(mac[5], mac[4], mac[3], mac[2], mac[1], mac[0], (byte) 0, (byte) 0);
                                break;
                            }
                        }
                    }
                } catch (final Exception ex) {
                    ex.printStackTrace();
                }
                if (sharedHw == 0) {
                    try {
                        sharedHw = AccessController.doPrivileged(new PrivilegedExceptionAction<Long>() {

                            @Override
                            public final Long run() throws Exception {
                                Preferences prefs;
                                try {
                                    prefs = Preferences.systemNodeForPackage(UUIDs.class);
                                } catch (final SecurityException ex) {
                                    prefs = Preferences.userNodeForPackage(UUIDs.class);
                                }
                                long v = prefs.getLong("UUIDs.sharedNode", 0);
                                if ((v <= 0) || (v >= UUIDs.NODE_MASK)) {
                                    v = UUIDs.sharedNodeRandom;
                                    prefs.putLong("UUIDs.sharedNode", v);
                                    prefs.flush();
                                }
                                return v;
                            }
                        });
                    } catch (final Exception ex) {
                        ex.printStackTrace();
                    }
                }
                if (sharedHw == 0) sharedHw = UUIDs.sharedNodeRandom;
            }
            sharedNodeHw = sharedHw;
        }

        static final UUID sharedTimeBasedHw = SharedNodeHw.createTimeBasedHw();

        @Nonnull
        static UUID createTimeBasedHw() {
            return new UUID(VERSION_1 | generateTimeBits(), LEACH_SALZ_VARIANT | nextClockSequence() | UUIDs.SharedNodeHw.sharedNodeHw);
        }

        private SharedNodeHw() {
            super();
        }
    }
}
