package com.jedox.etl.core.node;

import java.util.HashMap;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.HashSet;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import com.jedox.etl.core.component.RuntimeException;
import com.jedox.etl.core.logging.MessageHandler;
import com.jedox.etl.core.node.IColumn.ColumnTypes;
import com.jedox.etl.core.node.IColumn.ElementTypes;
import com.jedox.etl.core.util.TypeConversionUtil;

/**
 * Class for {@link TreeElement} and {@link TreeNode} Management.
 * A TreeNodeManager holds and manipulates the intermediate representation of all tree based data (e.g. used for olap dimensions) generated by various datasources.
 * To form a tree this class provides exactly one internal root node. All nodes are descending from this root node.
 * <br>
 * {@link TreeElement TreeElements} represent the unique elements of a Tree and are registered by their technical name. {@link TreeNode TreeNodes} are used to form a hierarchy of TreeElements and allow multiple consoldiations of TreeNodes by specifying parent-child relationships.
 * @author Christian Schwarzinger. Mail: christian.schwarzinger@proclos.com
 *
 */
public class TreeManager {

    private HashMap<String, TreeElement> elements = new HashMap<String, TreeElement>();

    private HashMap<TreeElement, Row> parents = new HashMap<TreeElement, Row>();

    private HashMap<TreeElement, Row> children = new HashMap<TreeElement, Row>();

    private TreeElement root = null;

    private String name = "unknown";

    private static final Log log = new MessageHandler(LogFactory.getLog(TreeManager.class));

    /**
	 * Constructor
	 * @param rootname the name of the root node to create
	 */
    public TreeManager(String sourcename, String rootname) {
        this.name = sourcename;
        setRoot(new TreeElement(rootname));
    }

    /**
	 * gets the name of this TreeManager, which is the name of the underlying datasource.
	 * @return
	 */
    public String getName() {
        return name;
    }

    /**
	 * gets a specific parent of a TreeElement by its name
	 * @param element the base TreeElement
	 * @param parent the name of the parent to get.
	 * @return the parent as TreeNode or null, if no such parent exists.
	 */
    public TreeNode getParent(TreeElement element, String parent) {
        Row p = getParents(element);
        return (p != null) ? (TreeNode) p.getColumn(parent) : null;
    }

    /**
	 * gets all parents of a TreeElement
	 * @param element the base TreeElement to get its parent.
	 * @return a Row containing the parents as TreeNodes or an empty Row, if no parents exists.
	 */
    public Row getParents(TreeElement element) {
        Row p = parents.get(element);
        return (p != null) ? p : new Row();
    }

    /**
	 * gets a specific child of a TreeElement by its name
	 * @param element the base TreeElement
	 * @param child the name of the child to get
	 * @return the child as TreeNode or null, if no such child exists
	 */
    public TreeNode getChild(TreeElement element, String child) {
        Row c = children.get(element);
        return (c != null) ? (TreeNode) c.getColumn(child) : null;
    }

    /**
	 * gets all children of a TreeElement. As a special case all unassigned TreeElements are returned as children of the internal root node.
	 * @param element the base TreeElement
	 * @return a Row containing the children as TreeNodes or an empty Row, if no children exists.
	 */
    public Row getChildren(TreeElement element) {
        Row c = children.get(element);
        if (c == null) c = new Row();
        if (isRoot(element.getName())) {
            Row overlay = new Row();
            overlay.addColumns(c);
            for (String nodeName : elements.keySet()) {
                TreeElement e = getElement(nodeName);
                if ((getParents(e).size() == 0) && !isRoot(nodeName)) {
                    TreeNode consolidation = new TreeNode(element, e, 1);
                    overlay.addColumn(consolidation);
                }
            }
            return overlay;
        }
        return c;
    }

    private boolean isCyclic(TreeNode consolidation) {
        if (consolidation.getName().equals(consolidation.getParent())) return true;
        ArrayList<TreeNode> ancestors = getAncestors(this, new ArrayList<TreeNode>(), consolidation.getParent());
        for (TreeNode ancestor : ancestors) {
            if (ancestor.getName().equals(consolidation.getName())) {
                if (consolidation.getName().equals(consolidation.getParent().getName())) {
                    log.warn("Node " + consolidation.getName() + " cannot be consolidated under itself in source " + getName() + ". The consolidation is ignored.");
                } else {
                    log.warn("Failed to consolidate node " + consolidation.getName() + " with parent " + consolidation.getParent().getName() + " due to a circular reference in source " + getName() + ".");
                }
                return true;
            }
        }
        return false;
    }

    /**
	 * adds a consolidation in form of a TreeNode specifying a parent-child relationship inducing a hierarchy.
	 * @param consolidation the relation to add.
	 */
    public void addConsolidation(TreeNode consolidation) {
        if (!isCyclic(consolidation)) {
            Row p = parents.get(consolidation.getElement());
            Row c = children.get(consolidation.getParent());
            if (p == null) {
                p = new Row();
                parents.put(consolidation.getElement(), p);
            }
            if (c == null) {
                c = new Row();
                children.put(consolidation.getParent(), c);
            }
            p.addColumn(consolidation, consolidation.getParentName());
            c.addColumn(consolidation);
            if (consolidation.getParentName() != getRoot().getName() && p.containsColumn(getRoot().getName())) {
                p.removeColumn(getRoot().getName());
                (children.get(getRoot())).removeColumn(consolidation.getElement().getName());
            }
        }
    }

    /**
	 * adds a consolidation in form of a TreeNode specifying a parent-child relationship inducing a hierarchy.
	 * @param node the name of the base/child TreeElement
	 * @param parent the name of the parent TreeElement
	 * @param weight the weight of the relationship.
	 */
    public void addConsolidation(String node, String parent, double weight) {
        TreeNode consolidation = new TreeNode(getElement(parent), getElement(node), weight);
        addConsolidation(consolidation);
    }

    /**
	 * removes a consolidation in form of a TreeNode removing a parent-child relationship from the hierarchy.
	 * @param consolidation the relation to remove
	 */
    public void removeConsolidation(TreeNode consolidation) {
        if (consolidation != null) {
            Row p = parents.get(consolidation.getElement());
            Row c = children.get(consolidation.getParent());
            if (p != null) p.removeColumn(consolidation);
            if (c != null) c.removeColumn(consolidation);
        }
    }

    /**
	 * renames a TreeElement
	 * @param oldName the current name of the TreeElement
	 * @param newName the new name of the TreeElement
	 */
    public void renameElement(String oldName, String newName) {
        TreeElement element = elements.remove(oldName);
        if (element != null) {
            element.setName(newName);
            elements.put(newName, element);
        }
    }

    /**
	 * Sets an externally provided {@link TreeElement} as root node. All children of the original root node are preserved as children of the new root node.
	 * @param root the root node to set
	 * @return the original root node
	 */
    public TreeElement setRoot(TreeElement root) {
        TreeElement original = getRoot();
        this.root = root;
        addNodeInternal(root);
        if (original != null) {
            Row c = getChildren(original);
            for (TreeNode n : getNodesFromRow(c)) {
                n.setParent(root);
            }
            children.remove(original);
            children.put(root, c);
            elements.remove(original);
        }
        return original;
    }

    /**
	 * gets the TreeElement serving as internal tree root.
	 * @return the TreeElement serving as internal tree root.
	 */
    public TreeElement getRoot() {
        return root;
    }

    /**
	 * determines if a TreeElement is the internal root of this manager.
	 * @param name the name of the TreeElement
	 * @return true, if TreeElement is the internal root, false otherwise.
	 */
    public boolean isRoot(String name) {
        return root.getName().equals(name);
    }

    /**
	 * gets the TreeElement serving as internal root node as TreeNode relation with no parent. Convenience method when working on TreeNode level.
	 * @return the TreeElement serving as internal tree root in TreeNode representation
	 */
    public TreeNode getRootNode() {
        return new TreeNode(null, getRoot(), 1);
    }

    /**
	 * gets the number of registered {@Link TreeNode}s of this manager
	 * @return the number of registered {@Link TreeNode}s of this manager
	 */
    public int getSize() {
        return elements.size();
    }

    private TreeElement addNodeInternal(TreeElement element) {
        TreeElement presentElement = getElement(element.getName());
        if (presentElement != null) {
            for (IColumn column : element.getAttributes().getColumns()) {
                addAttribute(presentElement.getName(), column.getName(), column.getValue(), column.getColumnType(), column.getElementType());
            }
        } else elements.put(element.getName(), element);
        return getElement(element.getName());
    }

    protected void addDescendants(TreeManager manager, List<TreeNode> nodes) {
        for (int i = 0; i < nodes.size(); i++) {
            TreeNode d = nodes.get(i);
            addNodeInternal(manager.getElement(d.getName()));
            addConsolidation(d.getName(), d.getParentName(), d.getWeight());
        }
    }

    /**
	 * Adds a full subtree of an external manager to this manager.
	 * @param manager the external manager providing the subtree to add
	 * @param node the TreeElement serving as root of the subtree of the external manager
	 * @param parent the TreeElement serving as parent / hook in this manager for the subtree of the external manager.
	 * @param weight the weight for the new consolidation between the internal parent node and the external subtree to add.
	 * @return the consolidation created between the internal and the external node.
	 */
    public TreeNode addSubtree(TreeManager manager, TreeElement node, TreeElement parent, double weight) {
        TreeNode result = null;
        if (node != null) {
            if (parent == null) parent = getRoot();
            TreeElement element = addNodeInternal(node);
            result = new TreeNode(parent, element, weight);
            addConsolidation(result);
            addDescendants(manager, getDescendants(manager, new ArrayList<TreeNode>(), node));
        }
        return result;
    }

    private TreeNode addNode(TreeElement node, TreeElement parent, double weight) {
        return addSubtree(this, node, parent, weight);
    }

    /**
	 * Builds a new TreeNode consolidation. If the child TreeElement does not yet exist, it is created. The parent TreeElement has to already exist within this manager.
	 * @param name the name of the TreeElement to use as child in the relation.
	 * @param parent the name of the (already registered) TreeElement serving as parent in the new relation. if null the internal root is used as parent.
	 * @param weight the weight of this new parent-child relation.
	 * @return the TreeNode defining the new consolidation or null, if the parent does not exist.
	 */
    public TreeNode createNode(String name, String parent, double weight) {
        return createNode(name, getElement(parent), weight);
    }

    /**
	 * Builds a new TreeNode consolidation. If the child TreeElement does not yet exist, it is created. As parent the internal root is used.
	 * @param name the name of the TreeElement to use as child in the relation.
	 * @param weight the weight of this new parent-child relation.
	 * @return the TreeNode defining the new consolidation.
	 */
    public TreeNode createNode(String name, double weight) {
        return createNode(name, getRoot(), weight);
    }

    /**
	 * Builds a new TreeNode consolidation. If the child TreeElement does not yet exist, it is created. The parent TreeElement has to already exist within this manager.
	 * @param name name the name of the TreeElement to use as child in the relation.
	 * @param parent the (already registered) TreeElement serving as parent in the new relation. if null the internal root is used as parent.
	 * @param weight the weight of this new parent-child relation.
	 * @return
	 */
    public TreeNode createNode(String name, TreeElement parent, double weight) {
        if (name != null) {
            TreeElement n = getElement(name);
            if (n == null) n = createElement(name);
            return addNode(n, parent, weight);
        }
        return null;
    }

    /**
	 * creates a new TreeElement without assigning it to the internal hierarchy. Until assigned otherwise, this TreeElement is considered as foster child of the internal root. If a TreeElement with this name already exists, no action is taken.
	 * @param name the name of the new TreeElement to create.
	 * @return the newly created TreeElement.
	 */
    public TreeElement createElement(String name) {
        TreeElement t = getElement(name);
        if (t == null) {
            t = new TreeElement(name);
            addNodeInternal(t);
        }
        return t;
    }

    /**
	 * removes a TreeElement and all its consolidations from this manager. Orphaned TreeElements are are considered as foster children of the internal root node until assigned otherwise. The internal root node cannot be removed but only renamed.
	 * @param name the name of the TreeElement to remove
	 * @return the removed TreeElement or null, if no such TreeElement exists.
	 */
    public TreeElement removeElement(String name) {
        if (!isRoot(name)) {
            TreeElement result = elements.remove(name);
            if (result != null) {
                ArrayList<IColumn> myChildren = new ArrayList<IColumn>();
                ArrayList<IColumn> myParents = new ArrayList<IColumn>();
                myChildren.addAll(getChildren(result).getColumns());
                myParents.addAll(getParents(result).getColumns());
                for (IColumn c : myChildren) {
                    TreeNode tn = (TreeNode) c;
                    removeConsolidation(tn);
                }
                for (IColumn c : myParents) {
                    TreeNode tn = (TreeNode) c;
                    removeConsolidation(tn);
                }
                parents.remove(result);
                children.remove(result);
            }
            return result;
        }
        return null;
    }

    /**
	 * gets a TreeElement by its name
	 * @param name the name of the TreeElement
	 * @return the TreeElement or null, if no such TreeElement exists.
	 */
    public TreeElement getElement(String name) {
        if (name == null) return null;
        TreeElement n = elements.get(name);
        return n;
    }

    private ArrayList<TreeNode> getAncestors(TreeManager manager, ArrayList<TreeNode> nodes, TreeElement n) {
        Row row = manager.getParents(n);
        if (row.size() > 0) {
            for (IColumn c : row.getColumns()) {
                TreeNode node = (TreeNode) c;
                nodes.add(node);
                getAncestors(manager, nodes, node.getParent());
            }
        }
        nodes.add(getRootNode());
        return nodes;
    }

    /**
	 * Recursivly gets all descendants of a node
	 * @param nodes the list to be populated
	 * @param n the actual node to be processed
	 * @return all descendant nodes
	 */
    private ArrayList<TreeNode> getDescendants(TreeManager manager, ArrayList<TreeNode> nodes, TreeElement n) {
        Row row = manager.getChildren(n);
        if (row.size() > 0) {
            for (IColumn c : row.getColumns()) {
                TreeNode node = (TreeNode) c;
                nodes.add(node);
                getDescendants(manager, nodes, node.getElement());
            }
        }
        return nodes;
    }

    /**
	 * Gets an ordered subtree as list of TreeNodes. The order is determinded by the tree (depth first). Siblings are in the order as inserted.
	 * @param n the node to use as subtree root
	 * @param ignoreRoot if true the subtree root itself is ommitted in the result.
	 * @return the list of ordered TreeNodes of the subtree.
	 */
    public ArrayList<TreeNode> getOrderedSubtree(TreeNode n, boolean ignoreRoot) {
        ArrayList<TreeNode> result = getDescendants(this, new ArrayList<TreeNode>(), n.getElement());
        if (!ignoreRoot) result.add(0, n);
        return result;
    }

    /**
	 * Gets the full ordered tree as list of TreeNodes. The order is determinded by the tree (depth first). Siblings are in the order as inserted.
	 * @param ignoreRoot if true the internal root itself is ommitted in the result.
	 * @return the list of ordered TreeNodes of the full tree
	 */
    public ArrayList<TreeNode> getOrderedTree(boolean ignoreRoot) {
        return getOrderedSubtree(getRootNode(), ignoreRoot);
    }

    /**
	 * Gets all unique TreeNodes from a given list of TreeNodes possible containing duplicates. Convenience method.
	 * @param nodes the list of TreeNodes to consider.
	 * @return a list of TreeNodes, where each TreeNode is unique.
	 */
    public ArrayList<TreeNode> getUniqueNodes(List<TreeNode> nodes) {
        ArrayList<TreeNode> result = new ArrayList<TreeNode>();
        HashSet<String> added = new HashSet<String>();
        for (TreeNode t : nodes) {
            if (!added.contains(t.getName())) {
                result.add(t);
                added.add(t.getName());
            }
        }
        return result;
    }

    /**
	 * gets all TreeNodes, which act as leafs in the tree.
	 * @param ignoreRoot ignore the internal root node in the result (only affects the result, when tree is empty)
	 * @return the list of leaf nodes.
	 */
    public ArrayList<TreeNode> getLeafNodes(boolean ignoreRoot) {
        ArrayList<TreeNode> result = new ArrayList<TreeNode>();
        for (TreeNode t : getOrderedTree(ignoreRoot)) {
            if (getChildren(t.getElement()).size() == 0) {
                result.add(t);
            }
        }
        return result;
    }

    /**
	 * gets all TreeNodes, which do not act as leafs in the tree
	 * @param ignoreRoot ignore the internal root node in the result
	 * @return the list of branch nodes (all nodes, which are not leafs)
	 */
    public LinkedList<TreeNode> getBranchNodes(boolean ignoreRoot) {
        LinkedList<TreeNode> result = new LinkedList<TreeNode>();
        HashSet<String> added = new HashSet<String>();
        for (TreeNode t : getOrderedTree(ignoreRoot)) {
            if ((getChildren(t.getElement()).size() > 0) && !added.contains(t.getName())) {
                result.add(0, t);
                added.add(t.getName());
            }
        }
        return result;
    }

    /**
	 * gets all TreeNodes, which have a given attribute value set.
	 * @param attributeName the name of the attribute
	 * @param attributeValue the value of the attribute
	 * @return the list of TreeNodes having this attribute value
	 */
    public LinkedList<TreeNode> getNodesByAttribute(String attributeName, String attributeValue) {
        LinkedList<TreeNode> result = new LinkedList<TreeNode>();
        HashSet<String> added = new HashSet<String>();
        for (TreeNode t : getOrderedTree(true)) {
            IColumn attribute = t.getAttributes().getColumn(attributeName);
            if (attribute != null && attribute.getValueAsString().equals(attributeValue) && !added.contains(t.getName())) {
                result.add(0, t);
                added.add(t.getName());
            }
        }
        return result;
    }

    /**
	 * gets the TreeNodes stored in a Row as list. Convenience method for accessing the TreeNodes, since Row only gives access to the generic {@link IColumn} interface.
	 * @param row the Row containing the TreeNodes.
	 * @return the list of TreeNodes
	 */
    public ArrayList<TreeNode> getNodesFromRow(Row row) {
        ArrayList<TreeNode> result = new ArrayList<TreeNode>();
        for (IColumn node : row.getColumns()) if (node instanceof TreeNode) result.add((TreeNode) node);
        return result;
    }

    /**
	 * gets the underlying TreeElements from a list of TreeNodes. The TreeElements returned are the elements acting as child in the parent-child relation established by the TreeNodes. Convenience method.
	 * @param nodes the list of TreeNodes
	 * @return the list of the underlying TreeElements.
	 */
    public ArrayList<TreeElement> getElementsFromNodes(List<TreeNode> nodes) {
        ArrayList<TreeElement> result = new ArrayList<TreeElement>();
        HashSet<String> added = new HashSet<String>();
        for (IColumn node : nodes) {
            if (!added.contains(node.getName())) {
                result.add(getElement(node.getName()));
                added.add(node.getName());
            }
        }
        return result;
    }

    /**
	 * Recursivly gets all nodes from a specified level (distance to the root node) in the tree
	 * @param nodes to list to be populated.
	 * @param n the current node to be inspected.
	 * @param currentLevel the level the current nodes resides in.
	 * @param targetLevel the level where nodes should be delivered.
	 * @return a list of nodes of a given level (distance) with respect to the root node.
	 */
    private ArrayList<TreeNode> getNodesFromLevel(ArrayList<TreeNode> nodes, TreeNode n, int currentLevel, int targetLevel) {
        if (currentLevel < targetLevel - 1) {
            for (IColumn c : getChildren(n.getElement()).getColumns()) {
                getNodesFromLevel(nodes, (TreeNode) c, currentLevel + 1, targetLevel);
            }
        }
        if (currentLevel == targetLevel - 1) {
            for (IColumn c : getChildren(n.getElement()).getColumns()) {
                nodes.add((TreeNode) c);
            }
        }
        if (targetLevel == 0) nodes.add(getRootNode());
        return nodes;
    }

    /**
	 * Gets all TreeNodes from a specified level (distance to the root node) in the tree
	 * @param level the distance to the root node (root node itself is on level 0)
	 * @return a list of TreeNodes of a given level (distance) with respect to the root node.
	 */
    public ArrayList<TreeNode> getNodesFromLevel(int level) {
        return getNodesFromLevel(new ArrayList<TreeNode>(), getRootNode(), 0, level);
    }

    /**
	 * Recursivly gets the set of used attribute-names of all nodes in a subtree.
	 * @param n the node to be inspected
	 * @param a the attribute set to be populated
	 * @return the set of used attributes
	 */
    private Row getAttributes(TreeElement n, Row a) throws RuntimeException {
        if (n.getAttributes() != null) {
            for (IColumn nodeAttribute : n.getAttributes().getColumns()) {
                IColumn rowAttribute = a.getColumn(nodeAttribute.getName());
                if (rowAttribute != null) {
                    if (!rowAttribute.getColumnType().equals(nodeAttribute.getColumnType()) || !rowAttribute.getElementType().equals(nodeAttribute.getElementType())) {
                        log.warn("Attribute " + rowAttribute.getName() + " has occurrences of different types in tree " + getName() + ". Regarding it as text attribute.");
                        ((Column) rowAttribute).setColumnType(ColumnTypes.attribute);
                        rowAttribute.setElementType(ElementTypes.TEXT.toString());
                    }
                } else a.addColumn(nodeAttribute);
            }
        }
        for (IColumn c : getChildren(n).getColumns()) {
            getAttributes(getElement(c.getName()), a);
        }
        return a;
    }

    /**
	 * Gets all defined attributes of all TreeNodes in a subtree.
	 * @return a ColumnManager holding the attributes
	 */
    public ColumnManager getAttributes() throws RuntimeException {
        ColumnManager attributes = new ColumnManager();
        attributes.addColumns(getAttributes(getRoot(), new Row()));
        return attributes;
    }

    /**
	 * adds an attribute to a TreeElement
	 * @param elementName the name of the TreeElement
	 * @param key the name of the attribute
	 * @param value the value of the attribute to set
	 * @param ctype the type of attribute (alias, data, attribute, etc)
	 * @param etype the element type of attribute (text, numeric)
	 */
    public void addAttribute(String elementName, String key, Object value, IColumn.ColumnTypes ctype, IColumn.ElementTypes etype) {
        if (etype.equals(ElementTypes.NUMERIC) && value != null) {
            boolean numeric = new TypeConversionUtil().isNumeric(value.toString());
            if (!numeric) {
                log.warn("Attribut " + key + " of Element " + elementName + " is of type numeric, but attribut value is not numeric: " + value.toString());
                value = null;
            }
        }
        TreeElement element = getElement(elementName);
        if (element != null) {
            element.addAttribute(key, value, ctype, etype);
        }
    }

    /**
	 * adds a text attribute to a TreeElement
	 * @param elementName the name of the TreeElement
	 * @param key the name of the attribute
	 * @param value the value of the attribute to set
	 * @param ctype the type of attribute (alias, data, attribute, etc)
	 */
    public void addAttribute(String elementName, String key, Object value, IColumn.ColumnTypes ctype) {
        addAttribute(elementName, key, value, ctype, IColumn.ElementTypes.TEXT);
    }

    private ArrayList<TreeNode> filter(TreeNode n, ArrayList<TreeNode> toRemove) {
        for (IColumn c : getChildren(n.getElement()).getColumns()) {
            filter((TreeNode) c, toRemove);
        }
        if (!n.isMasked() && getChildren(n.getElement()).size() == 0 && n.getParent() != null) toRemove.add(n);
        return toRemove;
    }

    public void filterTree() {
        ArrayList<TreeNode> toRemove = filter(getRootNode(), new ArrayList<TreeNode>());
        while (toRemove.size() > 0) {
            for (TreeNode n : toRemove) {
                removeConsolidation(n);
                if (getParents(n.getElement()).size() == 0) removeElement(n.getElement().getName());
            }
            toRemove = filter(getRootNode(), new ArrayList<TreeNode>());
        }
    }

    /**
	 * clears this manager removing all TreeElements (except for the internal root) and TreeNodes.
	 */
    public void clear() {
        elements.clear();
        children.clear();
        parents.clear();
        addNodeInternal(getRoot());
    }
}
