package org.ldp.jdasm;

import java.io.*;
import java.lang.reflect.Method;
import java.util.*;
import org.ldp.jdasm.attribute.*;
import org.ldp.jdasm.attribute.instruction.opcode.*;
import org.ldp.jdasm.constantpool.*;
import org.ldp.jdasm.exception.*;

/**
 * This is the main class of JDasm project: it is a disassembled 
 * representation of a java class.<br>
 * <br>
 * You can create a DClass from scratch or open an existing
 * java class as a DClass to disassemble, read, modify it and finally
 * create a new class ready to be instanced and used.<br>
 * DClass is the representation of java class file, so you can perform almost
 * any operation you want to do in a class file: e.g. the class fields management 
 * is allowed through the class {@link DField}, while the methods management 
 * (bytecode inclusive) is performed due to the {@link DMethod} class.<br>
 * When you get done with editing, you are able to build a real java class:
 * the bytecode is autogenerated as the class Constant Pool is automatically
 * build.<br>
 * <br>
 * In java class file:<br>
 * <br>
 * <i>ClassFile {
 * <blockquote>
 *		u4 magic;<br>
 *		u2 minor_version;<br>
 *   	u2 major_version;<br>
 *   	u2 constant_pool_count;<br>
 *  	cp_info constant_pool[constant_pool_count-1];<br>
 *  	u2 access_flags;<br>
 *  	u2 this_class;<br>
 *  	u2 super_class;<br>
 *  	u2 interfaces_count;<br>
 *  	u2 interfaces[interfaces_count];<br>
 *  	u2 fields_count;<br>
 *  	field_info fields[fields_count];<br>
 *  	u2 methods_count;<br>
 *  	method_info methods[methods_count];<br>
 *  	u2 attributes_count;<br>
 *  	attribute_info attributes[attributes_count];
 * </blockquote>
 *  }</i><br>
 * <br>
 * 
 * <br>
 * @see DConstantPool
 * @see DField
 * @see DMethod
 * @see DAttribute
 */
public class DClass extends Attributable {

    public static final short ACC_NOTSET = 0x0000;

    public static final short ACC_PUBLIC = 0x0001;

    public static final short ACC_FINAL = 0x0010;

    public static final short ACC_SUPER = 0x0020;

    public static final short ACC_INTERFACE = 0x0200;

    public static final short ACC_ABSTRACT = 0x0400;

    public static final short ACC_SYNTHETIC = 0x1000;

    public static final short ACC_ANNOTATION = 0x2000;

    public static final short ACC_ENUM = 0x4000;

    private int magic = 0xCAFEBABE;

    private short minorVersion = 0;

    private short majorVersion = 49;

    private DConstantPool cpool = new DConstantPool();

    private short accessFlags = ACC_NOTSET;

    private String className = "";

    private String superclassName = "";

    private Vector<String> interfaces = new Vector<String>();

    private Vector<DField> fields = new Vector<DField>();

    private Vector<DMethod> methods = new Vector<DMethod>();

    private short cpool_nameIndex = -1;

    private short cpool_supernameIndex = -1;

    private Vector<Short> cpool_interfaces = new Vector<Short>();

    /** once the build is done, this will be the bytecode */
    private byte[] bytecode = null;

    private static boolean buildCustomAttribute = false;

    /** Constructs an empty DClass. */
    public DClass() {
    }

    /** Constructs an empty DClass with given name and public accessFlags; 
	 * superclass is also set to Object */
    public DClass(String name) {
        this.setAccessFlags((short) (ACC_PUBLIC | ACC_SUPER));
        this.setClassName(name);
        this.setSuperclassName("java.lang.Object");
    }

    /** Constructs a DClass reading a java class. */
    public DClass(Class<?> clazz) throws ClassNotFoundException, IOException, ClassFileParseException {
        CommonConstructor(new FileInputStream(new File(ClassDefiner.locateClass(clazz))));
    }

    /** Constructs a DClass reading the bytecode from an input stream. */
    public DClass(InputStream is) throws ClassNotFoundException, IOException, ClassFileParseException {
        CommonConstructor(is);
    }

    private void CommonConstructor(InputStream is) throws ClassNotFoundException, IOException, ClassFileParseException {
        CONSTANT_Class_Info info;
        int size;
        this.magic = ParseFacilities.getIntFromInputStream(is, true);
        if (this.magic != 0xCAFEBABE) throw new ClassNotFoundException("Magic number is not 0xCAFEBABE (" + Integer.toHexString(this.magic) + ")");
        this.minorVersion = ParseFacilities.getShortFromInputStream(is);
        this.majorVersion = ParseFacilities.getShortFromInputStream(is);
        this.cpool = new DConstantPool(is);
        this.accessFlags = ParseFacilities.getShortFromInputStream(is);
        this.cpool_nameIndex = ParseFacilities.getShortFromInputStream(is);
        this.cpool_supernameIndex = ParseFacilities.getShortFromInputStream(is);
        info = (CONSTANT_Class_Info) this.cpool.getConstant(this.cpool_nameIndex);
        this.className = ((CONSTANT_Utf8_Info) this.cpool.getConstant(info.getConstantPoolClassNameStringIndex())).getValue();
        info = (CONSTANT_Class_Info) this.cpool.getConstant(this.cpool_supernameIndex);
        this.superclassName = ((CONSTANT_Utf8_Info) this.cpool.getConstant(info.getConstantPoolClassNameStringIndex())).getValue();
        size = ParseFacilities.getShortFromInputStream(is);
        for (int i = 0; i < size; i++) {
            short idx = ParseFacilities.getShortFromInputStream(is);
            this.cpool_interfaces.add(idx);
            info = (CONSTANT_Class_Info) this.cpool.getConstant(idx);
            this.interfaces.add(((CONSTANT_Utf8_Info) this.cpool.getConstant(info.getConstantPoolClassNameStringIndex())).getValue());
        }
        size = ParseFacilities.getShortFromInputStream(is);
        for (int i = 0; i < size; i++) this.fields.add(new DField(is, this.cpool));
        size = ParseFacilities.getShortFromInputStream(is);
        for (int i = 0; i < size; i++) this.methods.add(new DMethod(is, this.cpool));
        size = ParseFacilities.getShortFromInputStream(is);
        for (int i = 0; i < size; i++) this.attributes.add(DAttribute.getDAttributeFromInputStream(is, this.cpool));
    }

    /** Get the magic number for this class file (default is 0xCAFEBABE). */
    public int getMagic() {
        return magic;
    }

    /** Set the magic number for this class file (default is 0xCAFEBABE). */
    public void setMagic(int magic) {
        this.magic = magic;
    }

    /** Get the minor number for this class file (default is 0). */
    public short getMinorVersion() {
        return minorVersion;
    }

    /** Set the minor number for this class file (default is 0). */
    public void setMinorVersion(short minorVersion) {
        this.minorVersion = minorVersion;
    }

    /** Get the major number for this class file (default is 49). */
    public short getMajorVersion() {
        return majorVersion;
    }

    /** Set the major number for this class file (default is 49). */
    public void setMajorVersion(short majorVersion) {
        this.majorVersion = majorVersion;
    }

    /** Get the access permission qualifier for this class. */
    public short getAccessFlags() {
        return accessFlags;
    }

    /** Get the access permission qualifier for this class. */
    public void setAccessFlags(short accessFlags) {
        this.accessFlags = accessFlags;
    }

    /** Get the class name. */
    public String getClassName() {
        int np = this.className.lastIndexOf('.');
        int ns = this.className.lastIndexOf('/');
        if (np > ns) return this.className.substring(np + 1);
        if (ns > np) return this.className.substring(ns + 1);
        return className;
    }

    /** Get the fully qualified class name. */
    public String getFullyQualifiedClassName() {
        return className;
    }

    /** Set the class name. */
    public void setClassName(String className) {
        this.className = className;
    }

    /** Get the fully qualified super class name. */
    public String getFullyQualifiedSuperClassName() {
        return superclassName;
    }

    /** Get the name of the super class. */
    public String getSuperclassName() {
        int np = this.superclassName.lastIndexOf('.');
        int ns = this.superclassName.lastIndexOf('/');
        if (np > ns) return this.superclassName.substring(np + 1);
        if (ns > np) return this.superclassName.substring(ns + 1);
        return superclassName;
    }

    /** 
	 * Set the name of the super class. 
	 * Remember that when a class X is supposed to be child of a super parent class Y,
	 * then X is also supposed to have a call to the Y constructor in any of X constructor methods
	 * */
    public void setSuperclassName(String superclassName) {
        this.superclassName = superclassName;
    }

    /** Returns the buildCustomAttribute flag for this DClass. 
	 * When loaded from a class, they probably have references into the constant table
	 * that cannot be updated without the attribute knowledge. So false (default) is a safe choice. */
    public static boolean isBuildCustomAttribute() {
        return DClass.buildCustomAttribute;
    }

    /** Sets the buildCustomAttribute flag for this DClass.
	 * When loaded from a class, they probably have references into the constant table
	 * that cannot be updated without the attribute knowledge. So false (default) is a safe choice.
	 * If you want to build custom attribute pass <code>true</code> here. If you want to use
	 * custom attribute with constant pool reference you can add manually constants you need
	 * and tell the constant pool to build the unlinked constants too.
	 * @see DConstantPool#addConstant(org.ldp.jdasm.constantpool.CpInfo) 
	 * @see DConstantPool#setKeepUnlinkedConstant(boolean) 
	 * */
    public static void setBuildCustomAttribute(boolean buildCustomAttribute) {
        DClass.buildCustomAttribute = buildCustomAttribute;
    }

    public DConstantPool getConstantPool() {
        return this.cpool;
    }

    /** Returns the number of interfaces held */
    public int interfaceCount() {
        return this.interfaces.size();
    }

    /** Adds an interface with given name */
    public void addInterface(String name) {
        this.interfaces.add(name);
        this.cpool_interfaces.add((short) -1);
    }

    /** Removes the interface with given name 
	 * @return true if the interface is found in the list and removed, false if it is not present */
    public boolean removeInterface(String name) {
        int ret = this.interfaces.indexOf(name);
        if (ret >= 0) {
            this.interfaces.remove(ret);
            this.cpool_interfaces.remove(ret);
        }
        return ret >= 0;
    }

    /** Removes the interface at given index */
    public void removeInterface(int idx) {
        this.interfaces.remove(idx);
        this.cpool_interfaces.remove(idx);
    }

    /** Get the interface name at specified index */
    public String getInterface(int idx) {
        return this.interfaces.elementAt(idx);
    }

    /** Get all the interface names */
    public String[] getInterfaces() {
        return this.interfaces.toArray(new String[this.interfaceCount()]);
    }

    /** Returns the number of fields for this class */
    public int fieldCount() {
        return this.fields.size();
    }

    /** Adds a DField; if a field with the same name already exists, it is replaced.
	 * @return the inserted DField */
    public DField addField(DField field) {
        this.fields.add(field);
        return field;
    }

    /** 
	 * Adds a java field to this class; the field is obtained by parsing the code
	 * passed as argument. If a field with the same name already exists, it is replaced.
	 * @return the inserted DField 
	 * @see DField#DField(String) 
	*/
    public DField addField(String code) throws CodeParseException {
        DField f = new DField(code);
        return this.addField(f);
    }

    /** Removes the given field (match is done on the name) from the list.
	 * @param field A DField with the name of the field you want to remove.
	 * @return true if a field is removed (if it was present), false it it is not present in the list.
	 */
    public boolean removeField(DField field) {
        int idx = this.fields.indexOf(field);
        if (idx >= 0) this.fields.remove(idx);
        return idx >= 0;
    }

    /** Removes the field with the given name.
	 * @return true if a field is removed (if it was present), false it it is not present in the list.
	 */
    public boolean removeField(String name) {
        for (int i = 0; i < this.fields.size(); i++) if (this.fields.elementAt(i).equals(name)) {
            this.fields.remove(i);
            return true;
        }
        return false;
    }

    /** Get the field with the given name.
	 * @return a DField with matched name, or null if no such DField exists */
    public DField getField(String name) {
        for (int i = 0; i < this.fields.size(); i++) if (this.fields.elementAt(i).equals(name)) return this.fields.elementAt(i);
        return null;
    }

    /** Returns all the fields */
    public DField[] getFields() {
        return this.fields.toArray(new DField[this.fieldCount()]);
    }

    /** Returns the number of methods for this class */
    public int methodCount() {
        return this.methods.size();
    }

    /** Adds a DMethod; if a method with the same signature already exists, it is replaced. 
	 * @return the inserted DMethod */
    public DMethod addMethod(DMethod method) {
        this.methods.add(method);
        return method;
    }

    /** 
	 * Adds a java method to this class; the method is obtained by parsing the code
	 * passed as argument. If a method with the same signature already exists, it is replaced.
	 * @return the inserted DMethod
	 * @see DMethod#DMethod(String) 
	*/
    public DMethod addMethod(String code) throws CodeParseException {
        return this.addMethod(new DMethod(code));
    }

    /** Removes the given method (match is done on the signature) from the list.
	 * @param method A DMethod with the signature of the method you want to remove.
	 * @return true if a method is removed (if it was present), false it it is not present in the list.
	 */
    public boolean removeMethod(DMethod method) {
        int idx = this.methods.indexOf(method);
        if (idx >= 0) this.methods.remove(idx);
        return idx >= 0;
    }

    /** Removes the method with the given method signature
	 * @return true if a method is removed (if it was present), false it it is not present in the list.
	 * @see DMethod#DMethod(String)
	 * @see DMethod#getSignature()
	 */
    public boolean removeMethod(String signature) {
        for (int i = 0; i < this.methods.size(); i++) if (this.methods.elementAt(i).equals(signature)) {
            this.methods.remove(i);
            return true;
        }
        return false;
    }

    /** Get the method with the given signature.
	 * @see DMethod#DMethod(String)
	 * @see DMethod#getSignature()
	 * @return a DMethod with matched signature, or null if no such DMethod exists */
    public DMethod getMethod(String signature) {
        for (int i = 0; i < this.methods.size(); i++) if (this.methods.elementAt(i).equals(signature)) return this.methods.elementAt(i);
        return null;
    }

    /** Get the method associated to the given reflective <code>method</code>.<br>
	 * If you load this DClass from a java class, you can use the reflection to inspect the methods
	 * inside the original class and use this method to get the correspondent DMethod. Returns null
	 * if no dmethod is found. */
    public DMethod getMethod(Method method) {
        for (int i = 0; i < this.methods.size(); i++) if (this.methods.elementAt(i).equals(method)) return this.methods.elementAt(i);
        return null;
    }

    /** Returns all the methods */
    public DMethod[] getMethods() {
        return this.methods.toArray(new DMethod[this.methodCount()]);
    }

    /** Adds an empty constructor which calls the super constructor and returns.<br>
	 * The added method will be public, named <code>&lt;init&gt;</code> and its
	 * descriptor will be <code>()V</code>. Such new inserted method will call an 
	 * identical method of the same class of this DClass's super constructor. */
    public void addEmptyConstructor() {
        try {
            CodeAttribute code = this.addMethod(new DMethod("public void <init> ()")).getCodeAttribute();
            code.addCode(new ALOAD_0());
            code.addCode(new INVOKESPECIAL(this.superclassName + " <init> ()V"));
            code.addCode(new RETURN());
            code.setMaxLocals(1);
            code.setMaxStack(1);
        } catch (CodeParseException e) {
            System.err.println("Uh..oh.. fix me!: " + e);
            e.printStackTrace();
        }
    }

    /**
	 * 
	 * @param newname
	 * @throws MethodDescriptorException if some of the constructor methods have errors in
	 * their types specification, and JDasm cannot create their method descriptor. 
	 */
    public void makeChildOfItself(String newname) throws MethodDescriptorException {
        String newSuperConstructorClassName = this.getFullyQualifiedClassName();
        String oldSuperConstructorClassName = this.getFullyQualifiedSuperClassName();
        this.setClassName(newname);
        this.setSuperclassName(newSuperConstructorClassName);
        CodeAttribute code;
        for (DMethod m : this.getMethods()) {
            if (m.isConstructor() && (code = m.getCodeAttribute(false)) != null) {
                code.setMethodDescriptor(m.getMethodDescriptor(), (m.getAccessFlags() & DMethod.ACC_STATIC) > 0);
                try {
                    code.wrapSuperConstructor(oldSuperConstructorClassName, newSuperConstructorClassName);
                } catch (MethodDescriptorException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    /** Convert the bytecode into a class. If no build has been done yet, then
	 * this method calls {@link DClass#build()} before, otherwise the already
	 * computed bytecode is used.
	 * @return The java Class representing the DClass on success, or null if something goes wrong 
	 */
    public Class<?> toClass() {
        try {
            byte[] b = toBytecode();
            java.lang.reflect.Method method = ClassDefiner.getDefineClassMethod();
            method.setAccessible(true);
            Class<?> c = (Class<?>) method.invoke(ClassDefiner.getClassLoader(), new Object[] { getClassName(), b, new Integer(0), new Integer(b.length) });
            method.setAccessible(false);
            return c;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /** Returns this DClass converted to java bytecode. If no build has been done yet, then
	 * this method calls {@link DClass#build()} before, otherwise the already
	 * computed bytecode is used. */
    public byte[] toBytecode() {
        if (this.bytecode == null) build();
        return this.bytecode;
    }

    /** Returns the bytecode that is already built. If no build has been done yet, then
	 * it returns null */
    public byte[] getComputedBytecode() {
        return this.bytecode;
    }

    /** Constructs the java bytecode representing this DClass and returns it 
	 * @see DClass#toBytecode()
	 * @see DClass#getComputedBytecode() */
    public byte[] build() {
        try {
            if (true) {
                ByteArrayOutputStream output = new ByteArrayOutputStream(2048);
                build(output);
                this.bytecode = output.toByteArray();
            } else {
                build(null);
            }
            return this.bytecode;
        } catch (IOException e) {
            System.err.println("Error while building the class: " + e);
            e.printStackTrace();
            return null;
        }
    }

    /** The real build method that use an output stream, either a file
	 * or a byte array 
	 * @param output the output stream to write the class onto. If output
	 * is null, then a slower method, consisting in first computing the needed
	 * length and then create the right byte array, is used
	 * @throws IOException on error while writing onto the output stream
	 */
    private void build(OutputStream output) throws IOException {
        if (output == null) {
            int len = 22;
            this.cpool.linkConstants(this);
            len += this.cpool.getBuildLength();
            len += this.interfaces.size() * 2;
            for (int i = 0; i < this.fields.size(); i++) len += this.fields.elementAt(i).getBuildLength();
            for (int i = 0; i < this.methods.size(); i++) len += this.methods.elementAt(i).getBuildLength();
            for (int i = 0; i < this.attributes.size(); i++) len += this.attributes.elementAt(i).getBuildLength();
            byte[] ret = new byte[len];
            int idx = 0;
            idx += ParseFacilities.addIntToByteArray(this.magic, ret, idx);
            idx += ParseFacilities.addShortToByteArray(this.minorVersion, ret, idx);
            idx += ParseFacilities.addShortToByteArray(this.majorVersion, ret, idx);
            idx += this.cpool.build(ret, idx);
            idx += ParseFacilities.addShortToByteArray(this.accessFlags, ret, idx);
            idx += ParseFacilities.addShortToByteArray(this.cpool_nameIndex, ret, idx);
            idx += ParseFacilities.addShortToByteArray(this.cpool_supernameIndex, ret, idx);
            idx += ParseFacilities.addShortToByteArray((short) this.interfaces.size(), ret, idx);
            for (int i = 0; i < this.interfaces.size(); i++) idx += ParseFacilities.addShortToByteArray(this.cpool_interfaces.elementAt(i).shortValue(), ret, idx);
            idx += ParseFacilities.addShortToByteArray((short) this.fields.size(), ret, idx);
            for (int i = 0; i < this.fields.size(); i++) idx += this.fields.elementAt(i).build(ret, idx);
            idx += ParseFacilities.addShortToByteArray((short) this.methods.size(), ret, idx);
            for (int i = 0; i < this.methods.size(); i++) idx += this.methods.elementAt(i).build(ret, idx);
            int attSizePosition = idx;
            short attBuilt = 0;
            idx += 2;
            for (int i = 0; i < this.attributes.size(); i++) {
                DAttribute att = this.attributes.elementAt(i);
                if (att instanceof CustomAttribute == false || DClass.isBuildCustomAttribute()) {
                    attBuilt += 1;
                    idx += this.attributes.elementAt(i).build(ret, idx);
                }
            }
            ParseFacilities.addShortToByteArray(attBuilt, ret, attSizePosition);
            if (idx != len) System.err.println("Uh-Oh.. Parsing problems: we calculate a need of " + len + " bytes but we write only " + idx + " bytes");
            this.bytecode = ret;
        } else {
            this.cpool.linkConstants(this);
            ParseFacilities.addIntToOutputStream(this.magic, output);
            ParseFacilities.addShortToOutputStream(this.minorVersion, output);
            ParseFacilities.addShortToOutputStream(this.majorVersion, output);
            this.cpool.build(output);
            ParseFacilities.addShortToOutputStream(this.accessFlags, output);
            ParseFacilities.addShortToOutputStream(this.cpool_nameIndex, output);
            ParseFacilities.addShortToOutputStream(this.cpool_supernameIndex, output);
            ParseFacilities.addShortToOutputStream((short) this.interfaces.size(), output);
            for (int i = 0; i < this.interfaces.size(); i++) ParseFacilities.addShortToOutputStream(this.cpool_interfaces.elementAt(i).shortValue(), output);
            ParseFacilities.addShortToOutputStream((short) this.fields.size(), output);
            for (int i = 0; i < this.fields.size(); i++) this.fields.elementAt(i).build(output);
            ParseFacilities.addShortToOutputStream((short) this.methods.size(), output);
            for (int i = 0; i < this.methods.size(); i++) this.methods.elementAt(i).build(output);
            short rAtt = 0;
            for (int i = 0; i < this.attributes.size(); i++) if (this.attributes.elementAt(i) instanceof CustomAttribute == false || DClass.isBuildCustomAttribute()) rAtt += 1;
            ParseFacilities.addShortToOutputStream(rAtt, output);
            for (int i = 0; i < this.attributes.size(); i++) {
                DAttribute att = this.attributes.elementAt(i);
                if (att instanceof CustomAttribute == false || DClass.isBuildCustomAttribute()) att.build(output);
            }
        }
    }

    /** Returns the number of IConstantPoolUser instances of this class. */
    public int constantPoolUserChildSize() {
        return this.fieldCount() + this.methodCount() + this.attributeCount();
    }

    /** Returns the idx-th IConstantPoolUser instance of this class. */
    public AConstantPoolUser getConstantPoolUserChild(int idx) {
        int l1 = this.fieldCount();
        int l2 = this.methodCount();
        if (idx < l1) return this.fields.elementAt(idx);
        if (idx < l1 + l2) return this.methods.elementAt(idx - l1);
        return this.attributes.elementAt(idx - l1 - l2);
    }

    /** Returns the number of values that this constant pool user
	 * wants to insert into the constant pool. */
    public int constantPoolValueSize() {
        return 2 + this.interfaceCount();
    }

    /** Returns the idx-th value that this constant pool user
	 * wants to insert into the constant pool. 
	 * @throws Exception if the value is not ready (since the control is done only at build time) */
    public Object getConstantValue(int idx) throws Exception {
        if (idx == 0) return this.getFullyQualifiedClassName();
        if (idx == 1) return this.getFullyQualifiedSuperClassName();
        return this.interfaces.elementAt(idx - 2);
    }

    /** Returns the value type of the idx-th value that this constant 
	 * pool user wants to insert into the constant pool. The list
	 * of the types is declared in {@link DConstantPool} */
    public int getConstantValueType(int idx) {
        return DConstantPool.CONSTANT_Class;
    }

    /** The constant pool tells the user that the value retrieved
	 * with {@link AConstantPoolUser#getConstantValue(int)} at index
	 * "idx" has received the "cpool_index" index in the  constant pool.
	 * @param idx the index of the value mapped with the ones returned by getConstantValue(int)
	 * @param cpool_index the index of the value in the constant pool
	 */
    public void setConstantValueIndex(int idx, short cpool_index) {
        if (idx == 0) this.cpool_nameIndex = cpool_index; else if (idx == 1) this.cpool_supernameIndex = cpool_index; else {
            this.cpool_interfaces.set(idx - 2, cpool_index);
        }
    }

    /**
	 * Returns a printable String with this DClass information.
	 * @param indent_level The indentation level (in white-spaces) for each generated line 
	 */
    public String classFileInfo(int indent_level) {
        DField[] farr = this.getFields();
        DMethod[] marr = this.getMethods();
        DAttribute[] aarr = this.getAttributes();
        int naarr = this.attributeCount();
        String indent = ParseFacilities.getIndent(indent_level);
        String info;
        info = indent + "Magic: 0x" + Integer.toHexString(this.magic) + "\n";
        info += indent + "Minor: " + this.minorVersion + "\n";
        info += indent + "Major: " + this.majorVersion + "\n";
        info += this.cpool.classFileInfo(indent_level) + "\n";
        info += indent + "Access Flags: " + this.accessFlags + " (" + DClass.getAccessFlagDescription(this.accessFlags) + ")\n";
        info += indent + "This Class: " + this.className + " (" + ParseFacilities.classInfoPrintIntLink(this.cpool_nameIndex) + ")\n";
        info += indent + "Super Class: " + this.superclassName + " (" + ParseFacilities.classInfoPrintIntLink(this.cpool_supernameIndex) + ")\n";
        info += indent + "Interfaces count: " + this.interfaceCount() + "\n";
        info += indent + "Fields count: " + this.fieldCount() + "\n";
        for (int i = 0; i < this.fieldCount(); i++) info += farr[i].classFileInfo(indent_level + 2) + "\n";
        info += indent + "Methods count: " + this.methodCount() + "\n";
        for (int i = 0; i < this.methodCount(); i++) info += marr[i].classFileInfo(indent_level + 2) + "\n";
        info += indent + "Attributes count: " + this.attributeCount() + (naarr == 0 ? "" : "\n");
        for (int i = 0; i < naarr; i++) info += aarr[i].classFileInfo(indent_level + 1) + (i + 1 == naarr ? "" : "\n");
        return info;
    }

    /**
	 * Returns a printable String with this DField information. It
	 * uses a default indentation level of 2 white spaces
	 */
    public String classFileInfo() {
        return this.classFileInfo(2);
    }

    /**
	 * Prints on stdout the info returned by {@link DClass#classFileInfo()}
	 */
    public void showClassInfo() {
        String info = this.classFileInfo();
        System.out.println("- - - - - - - - - - - - - -");
        System.out.println(info);
        System.out.println("- - - - - - - - - - - - - -");
    }

    /**
	 * Returns a printable String of the access permission qualifiers passed as argument. 
	 * @param flag The access permission qualifier typical of each DClass class.
	 */
    public static String getAccessFlagDescription(short flag) {
        String ret = "";
        if ((flag & ACC_PUBLIC) > 0) ret += "public ";
        if ((flag & ACC_FINAL) > 0) ret += "final ";
        if ((flag & ACC_SUPER) > 0) ret += "super ";
        if ((flag & ACC_INTERFACE) > 0) ret += "interface ";
        if ((flag & ACC_ABSTRACT) > 0) ret += "abstract ";
        return ret.length() > 0 ? ret.substring(0, ret.length() - 1) : "";
    }

    /** We give a fast method to write the class to a file.
	 * No exception are thrown, it just returns true on success, false
	 * on error (error print on output). 
	 * @param filename the path where to write the class. If it is a directory, 
	 * then the file name will be the class name plus ".class"
	 */
    public boolean writeClassToFile(String filename) {
        try {
            byte[] bc = toBytecode();
            File f = new File(filename);
            if (f.isDirectory()) f = new File(filename + "/" + this.getClassName() + ".class");
            FileOutputStream fos = new FileOutputStream(f);
            fos.write(bc);
            fos.close();
            return true;
        } catch (Exception e) {
            System.out.println("Error while writing the output file: " + e);
            e.printStackTrace();
            return false;
        }
    }
}
