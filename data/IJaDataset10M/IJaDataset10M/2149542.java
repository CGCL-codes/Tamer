package edu.mit.wi.omnigene.jaxb.tequila;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.xml.bind.ConversionException;
import javax.xml.bind.Dispatcher;
import javax.xml.bind.DuplicateAttributeException;
import javax.xml.bind.Element;
import javax.xml.bind.IdentifiableElement;
import javax.xml.bind.InvalidAttributeException;
import javax.xml.bind.InvalidContentObjectException;
import javax.xml.bind.LocalValidationException;
import javax.xml.bind.MarshallableObject;
import javax.xml.bind.Marshaller;
import javax.xml.bind.MissingAttributeException;
import javax.xml.bind.PredicatedLists;
import javax.xml.bind.PredicatedLists.Predicate;
import javax.xml.bind.StructureValidationException;
import javax.xml.bind.UnmarshalException;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.ValidatableObject;
import javax.xml.bind.Validator;
import javax.xml.marshal.XMLScanner;
import javax.xml.marshal.XMLWriter;

/**
 * This class is generated by JAXB using AGAVE XML DTD version 2.3 from DoubleTwist, Inc.
 * CompResult contains result alignments, scores, and other properties.  CompResult can be nested using a ResultGroup
 *
 * @author Hui Gong
 * @version 1.0
 */
public class CompResult extends MarshallableObject implements Element, IdentifiableElement {

    private String _ElementId;

    private String _ResultId;

    private String _GroupOrder;

    private String _ResultType;

    private String _FeatureType;

    private String _OnComplementStrand;

    private boolean isDefaulted_OnComplementStrand = true;

    private static final String DEFAULT_ONCOMPLEMENTSTRAND = String.valueOf("false");

    private String _Confidence;

    private String _AlignLength;

    private String _AlignUnits;

    private String _Note;

    private String _MatchDesc;

    private String _MatchAlign;

    private QueryRegion _QueryRegion;

    private MatchRegion _MatchRegion;

    private List _ResultProperty = PredicatedLists.createInvalidating(this, new ResultPropertyPredicate(), new ArrayList());

    private PredicatedLists.Predicate pred_ResultProperty = new ResultPropertyPredicate();

    private List _ResultGroup = PredicatedLists.createInvalidating(this, new ResultGroupPredicate(), new ArrayList());

    private PredicatedLists.Predicate pred_ResultGroup = new ResultGroupPredicate();

    private List _RelatedAnnot = PredicatedLists.createInvalidating(this, new RelatedAnnotPredicate(), new ArrayList());

    private PredicatedLists.Predicate pred_RelatedAnnot = new RelatedAnnotPredicate();

    /**
     * Gets an XML ID for this class.
     */
    public String getElementId() {
        return _ElementId;
    }

    /**
     * Sets an XML ID for this class.
     */
    public void setElementId(String _ElementId) {
        this._ElementId = _ElementId;
        if (_ElementId == null) {
            invalidate();
        }
    }

    /**
     * Gets object id.
     */
    public String id() {
        return _ElementId.toString();
    }

    /**
     * Gets a unique key for database storage.
     */
    public String getResultId() {
        return _ResultId;
    }

    /**
     * Sets a unique key for database storage.
     */
    public void setResultId(String _ResultId) {
        this._ResultId = _ResultId;
        if (_ResultId == null) {
            invalidate();
        }
    }

    /**
     * Gets is the order of a result when it appears inside a group.
     * The group_order is only needed as a database storage id.
     */
    public String getGroupOrder() {
        return _GroupOrder;
    }

    /**
     * Sets is the order of a result when it appears inside a group.
     * The group_order is only needed as a database storage id.
     */
    public void setGroupOrder(String _GroupOrder) {
        this._GroupOrder = _GroupOrder;
        if (_GroupOrder == null) {
            invalidate();
        }
    }

    /**
     * Gets a result type code.
     */
    public String getResultType() {
        return _ResultType;
    }

    /**
     * Sets a result type code.
     */
    public void setResultType(String _ResultType) {
        this._ResultType = _ResultType;
        if (_ResultType == null) {
            invalidate();
        }
    }

    /**
     * Gets GeneBank feature type.
     */
    public String getFeatureType() {
        return _FeatureType;
    }

    /**
     * Sets Genebank feature type.
     */
    public void setFeatureType(String _FeatureType) {
        this._FeatureType = _FeatureType;
        if (_FeatureType == null) {
            invalidate();
        }
    }

    /**
     * Checks to see if OnComplementStrand has been set.
     *
     * @return boolean true if it is using defaulte value "false" for OnComplementStrand, otherwise return false.
     */
    public boolean defaultedOnComplementStrand() {
        return (_OnComplementStrand != null);
    }

    /**
     * Sees if match is on complementary strand.
     *
     * @return String "true" when match is on complementary strand, otherwise is "false"
     */
    public String getOnComplementStrand() {
        if (_OnComplementStrand == null) {
            return DEFAULT_ONCOMPLEMENTSTRAND;
        }
        return _OnComplementStrand;
    }

    /**
     * Sets OnComplementStrand to true or false
     */
    public void setOnComplementStrand(String _OnComplementStrand) {
        this._OnComplementStrand = _OnComplementStrand;
        if (_OnComplementStrand == null) {
            invalidate();
        }
    }

    /**
     * Gets the confidence number.
     *
     * @return String a string in the range 0-100
     */
    public String getConfidence() {
        return _Confidence;
    }

    /**
     * Sets the confidence number.
     * It expresses the confidence in the result, and is usually a rough summary of the algorithm scores.
     * Applications can use the confidence score for filtering, querying, and sorting.
     *
     * @param _Confidence a string in the range 0-100.
     */
    public void setConfidence(String _Confidence) {
        this._Confidence = _Confidence;
        if (_Confidence == null) {
            invalidate();
        }
    }

    /**
     * Gets the length of the alignment in the alignment units
     *
     * @return the length of the alignment.
     */
    public String getAlignLength() {
        return _AlignLength;
    }

    /**
     * Sets the length of the alignment in the alignment units
     *
     * @param _AlignLength the length of the alignment.
     */
    public void setAlignLength(String _AlignLength) {
        this._AlignLength = _AlignLength;
        if (_AlignLength == null) {
            invalidate();
        }
    }

    /**
     * Gets the alignment length units.
     *
     * @return String the alignment length units.
     */
    public String getAlignUnits() {
        return _AlignUnits;
    }

    /**
     * Sets the alignment length units.
     *
     * @param _AlignUnits the alignment length units
     */
    public void setAlignUnits(String _AlignUnits) {
        this._AlignUnits = _AlignUnits;
        if (_AlignUnits == null) {
            invalidate();
        }
    }

    /**
     * Gets note for the computation result.
     *
     * @return String the note.
     */
    public String getNote() {
        return _Note;
    }

    /**
     * Sets the note for the computation result.
     *
     * @param _Note note content.
     */
    public void setNote(String _Note) {
        this._Note = _Note;
        if (_Note == null) {
            invalidate();
        }
    }

    /**
     * Gets the description of an alignment.
     *
     * @return String the description of march alignment.
     */
    public String getMatchDesc() {
        return _MatchDesc;
    }

    /**
     * Sets the description of an alignment.
     *
     * @param _MatchDesc  the description of march alignment.
     */
    public void setMatchDesc(String _MatchDesc) {
        this._MatchDesc = _MatchDesc;
        if (_MatchDesc == null) {
            invalidate();
        }
    }

    /**
     * Gets the text representation of an alignment.
     *
     * @return String the text representation of an alignment.
     */
    public String getMatchAlign() {
        return _MatchAlign;
    }

    /**
     * Sets the text representation of an alignment.
     *
     * @param _MatchAlign the text representation of an alignment.
     */
    public void setMatchAlign(String _MatchAlign) {
        this._MatchAlign = _MatchAlign;
        if (_MatchAlign == null) {
            invalidate();
        }
    }

    /**
     * Gets the region of the query sequence.
     *
     * @return QueryRegion the region of the query sequence.
     */
    public QueryRegion getQueryRegion() {
        return _QueryRegion;
    }

    /**
     * Sets the region of the query sequence.
     *
     * @param _QueryRegion the region of the query sequence.
     */
    public void setQueryRegion(QueryRegion _QueryRegion) {
        this._QueryRegion = _QueryRegion;
        if (_QueryRegion == null) {
            invalidate();
        }
    }

    /**
     * Gets the region of the match or hit sequence.
     *
     * @return MatchRegion the region of the match.
     */
    public MatchRegion getMatchRegion() {
        return _MatchRegion;
    }

    /**
     * Sets the region of the match or hit sequence.
     *
     * @param _MatchRegion the region of the match or hit sequence.
     */
    public void setMatchRegion(MatchRegion _MatchRegion) {
        this._MatchRegion = _MatchRegion;
        if (_MatchRegion == null) {
            invalidate();
        }
    }

    /**
     * Gets ResultProperty object list, also be used to add new objects in.
     *
     * @return List  ResultProperty object list.
     */
    public List getResultProperty() {
        return _ResultProperty;
    }

    /**
     * Deletes the ResultProperty list, also invalidate this class object.
     */
    public void deleteResultProperty() {
        _ResultProperty = null;
        invalidate();
    }

    /**
     * Creates a new empty list for ResultProperty.
     */
    public void emptyResultProperty() {
        _ResultProperty = PredicatedLists.createInvalidating(this, pred_ResultProperty, new ArrayList());
    }

    /**
     * Gets ResultGroup object list, also be used to add new ResultGroup objects in.
     *
     * @return List  ResultGroup object list.
     */
    public List getResultGroup() {
        return _ResultGroup;
    }

    /**
     * Deletes the ResultGroup list, also invalidate this class object.
     */
    public void deleteResultGroup() {
        _ResultGroup = null;
        invalidate();
    }

    /**
     * Creates a new empty list for ResultGroup.
     */
    public void emptyResultGroup() {
        _ResultGroup = PredicatedLists.createInvalidating(this, pred_ResultGroup, new ArrayList());
    }

    /**
     * Gets RelatedAnnot object list, also be used to add new RelatedAnnot objects in.
     *
     * @return List  object list.
     */
    public List getRelatedAnnot() {
        return _RelatedAnnot;
    }

    /**
     * Deletes the RelatedAnnot list, also invalidate this class object.
     */
    public void deleteRelatedAnnot() {
        _RelatedAnnot = null;
        invalidate();
    }

    /**
     * Creates a new empty list for RelatedAnnot.
     */
    public void emptyRelatedAnnot() {
        _RelatedAnnot = PredicatedLists.createInvalidating(this, pred_RelatedAnnot, new ArrayList());
    }

    /**
     * Ensures that this object does not violate any local structural constraints.
     * ResultType cannot be null.
     *
     * @see javax.xml.bind.MarshallableObject#validateThis()
     */
    public void validateThis() throws LocalValidationException {
        if (_ResultType == null) {
            throw new MissingAttributeException("result_type");
        }
    }

    /**
     * Recursively validates this object's children using the given validator and
     * updates the validator with any local information that is subject to global constraints.
     *
     * @param v The validator to be applied to this object's children
     * @see javax.xml.bind.MarshallableObject#validate(Validator v)
     */
    public void validate(Validator v) throws StructureValidationException {
        if (_QueryRegion != null) v.validate(_QueryRegion);
        if (_MatchRegion != null) v.validate(_MatchRegion);
        for (Iterator i = _ResultProperty.iterator(); i.hasNext(); ) {
            v.validate(((ValidatableObject) i.next()));
        }
        for (Iterator i = _ResultGroup.iterator(); i.hasNext(); ) {
            v.validate(((ValidatableObject) i.next()));
        }
        for (Iterator i = _RelatedAnnot.iterator(); i.hasNext(); ) {
            v.validate(((ValidatableObject) i.next()));
        }
    }

    /**
     * Marshals the content tree rooted at this object to the <code>Marshaller<code>.
     * Method validate() needs to be called before marshal the object.
     *
     * @param m a <code> Marshaller containing XMLWriter to write out xml contents.
     * @see javax.xml.bind.MarshallableObject#marshal(Marshaller m)
     */
    public void marshal(Marshaller m) throws IOException {
        XMLWriter w = m.writer();
        w.start("comp_result");
        if (_ElementId != null) {
            w.attribute("element_id", _ElementId.toString());
        }
        if (_ResultId != null) {
            w.attribute("result_id", _ResultId.toString());
        }
        if (_GroupOrder != null) {
            w.attribute("group_order", _GroupOrder.toString());
        }
        w.attribute("result_type", _ResultType.toString());
        if (_FeatureType != null) {
            w.attribute("feature_type", _FeatureType.toString());
        }
        if (_OnComplementStrand != null) {
            w.attribute("on_complement_strand", _OnComplementStrand.toString());
        }
        if (_Confidence != null) {
            w.attribute("confidence", _Confidence.toString());
        }
        if (_AlignLength != null) {
            w.attribute("align_length", _AlignLength.toString());
        }
        if (_AlignUnits != null) {
            w.attribute("align_units", _AlignUnits.toString());
        }
        if (_Note != null) {
            w.leaf("note", _Note.toString());
        }
        if (_MatchDesc != null) {
            w.leaf("match_desc", _MatchDesc.toString());
        }
        if (_MatchAlign != null) {
            w.leaf("match_align", _MatchAlign.toString());
        }
        if (_QueryRegion != null) {
            m.marshal(_QueryRegion);
        }
        if (_MatchRegion != null) {
            m.marshal(_MatchRegion);
        }
        if (_ResultProperty.size() > 0) {
            for (Iterator i = _ResultProperty.iterator(); i.hasNext(); ) {
                m.marshal(((MarshallableObject) i.next()));
            }
        }
        if (_ResultGroup.size() > 0) {
            for (Iterator i = _ResultGroup.iterator(); i.hasNext(); ) {
                m.marshal(((MarshallableObject) i.next()));
            }
        }
        if (_RelatedAnnot.size() > 0) {
            for (Iterator i = _RelatedAnnot.iterator(); i.hasNext(); ) {
                m.marshal(((MarshallableObject) i.next()));
            }
        }
        w.end("comp_result");
    }

    /**
     * Unmarshals an element or some character data into this object, converting data as necessary, checking type constraints
     * and local structural constraints, and recording the information required to check global structural constraints.
     *
     * @param u Unmarshaller to be used
     * @throws UnmarshalException   If the scanner is not currently positioned at a start tag, or if some other invalid content is later encountered.
     *         If the element name in the current start tag is not registered, or if some other unrecognized element name is encountered.
     *         If an attribute that is not permitted for the current element is scanned.
     *         If an I/O error occurs.
     *         If the input document is not well-formed.
     *         If the input document violates the constraints expressed in the source schema, or some other validation error is detected.
     */
    public void unmarshal(Unmarshaller u) throws UnmarshalException {
        XMLScanner xs = u.scanner();
        Validator v = u.validator();
        xs.takeStart("comp_result");
        while (xs.atAttribute()) {
            String an = xs.takeAttributeName();
            if (an.equals("element_id")) {
                if (_ElementId != null) {
                    throw new DuplicateAttributeException(an);
                }
                _ElementId = xs.takeAttributeValue();
                continue;
            }
            if (an.equals("result_id")) {
                if (_ResultId != null) {
                    throw new DuplicateAttributeException(an);
                }
                _ResultId = xs.takeAttributeValue();
                continue;
            }
            if (an.equals("group_order")) {
                if (_GroupOrder != null) {
                    throw new DuplicateAttributeException(an);
                }
                _GroupOrder = xs.takeAttributeValue();
                continue;
            }
            if (an.equals("result_type")) {
                if (_ResultType != null) {
                    throw new DuplicateAttributeException(an);
                }
                _ResultType = xs.takeAttributeValue();
                continue;
            }
            if (an.equals("feature_type")) {
                if (_FeatureType != null) {
                    throw new DuplicateAttributeException(an);
                }
                _FeatureType = xs.takeAttributeValue();
                continue;
            }
            if (an.equals("on_complement_strand")) {
                if (_OnComplementStrand != null) {
                    throw new DuplicateAttributeException(an);
                }
                _OnComplementStrand = xs.takeAttributeValue();
                continue;
            }
            if (an.equals("confidence")) {
                if (_Confidence != null) {
                    throw new DuplicateAttributeException(an);
                }
                _Confidence = xs.takeAttributeValue();
                continue;
            }
            if (an.equals("align_length")) {
                if (_AlignLength != null) {
                    throw new DuplicateAttributeException(an);
                }
                _AlignLength = xs.takeAttributeValue();
                continue;
            }
            if (an.equals("align_units")) {
                if (_AlignUnits != null) {
                    throw new DuplicateAttributeException(an);
                }
                _AlignUnits = xs.takeAttributeValue();
                continue;
            }
            throw new InvalidAttributeException(an);
        }
        if (xs.atStart("note")) {
            xs.takeStart("note");
            String s;
            if (xs.atChars(XMLScanner.WS_COLLAPSE)) {
                s = xs.takeChars(XMLScanner.WS_COLLAPSE);
            } else {
                s = "";
            }
            try {
                _Note = String.valueOf(s);
            } catch (Exception x) {
                throw new ConversionException("note", x);
            }
            xs.takeEnd("note");
        }
        if (xs.atStart("match_desc")) {
            xs.takeStart("match_desc");
            String s;
            if (xs.atChars(XMLScanner.WS_COLLAPSE)) {
                s = xs.takeChars(XMLScanner.WS_COLLAPSE);
            } else {
                s = "";
            }
            try {
                _MatchDesc = String.valueOf(s);
            } catch (Exception x) {
                throw new ConversionException("match_desc", x);
            }
            xs.takeEnd("match_desc");
        }
        if (xs.atStart("match_align")) {
            xs.takeStart("match_align");
            String s;
            if (xs.atChars(XMLScanner.WS_COLLAPSE)) {
                s = xs.takeChars(XMLScanner.WS_COLLAPSE);
            } else {
                s = "";
            }
            try {
                _MatchAlign = String.valueOf(s);
            } catch (Exception x) {
                throw new ConversionException("match_align", x);
            }
            xs.takeEnd("match_align");
        }
        if (xs.atStart("query_region")) {
            _QueryRegion = ((QueryRegion) u.unmarshal());
        }
        if (xs.atStart("match_region")) {
            _MatchRegion = ((MatchRegion) u.unmarshal());
        }
        {
            List l = PredicatedLists.create(this, pred_ResultProperty, new ArrayList());
            while (xs.atStart("result_property")) {
                l.add(((ResultProperty) u.unmarshal()));
            }
            _ResultProperty = PredicatedLists.createInvalidating(this, pred_ResultProperty, l);
        }
        {
            List l = PredicatedLists.create(this, pred_ResultGroup, new ArrayList());
            while (xs.atStart("result_group")) {
                l.add(((ResultGroup) u.unmarshal()));
            }
            _ResultGroup = PredicatedLists.createInvalidating(this, pred_ResultGroup, l);
        }
        {
            List l = PredicatedLists.create(this, pred_RelatedAnnot, new ArrayList());
            while (xs.atStart("related_annot")) {
                l.add(((RelatedAnnot) u.unmarshal()));
            }
            _RelatedAnnot = PredicatedLists.createInvalidating(this, pred_RelatedAnnot, l);
        }
        xs.takeEnd("comp_result");
    }

    /**
     * Unmarshals and validates a content tree created from XML <code>InputStream<code>.
     *
     * @param in XML <code>InputStream<code>
     * @return CompResult   Unmarshalled and Validated object from the XML InputStream.
     * @see javax.xml.bind.UnmarshalException
     */
    public static CompResult unmarshal(InputStream in) throws UnmarshalException {
        return unmarshal(XMLScanner.open(in));
    }

    /**
    * Unmarshals and validates a content tree using the given scanner. After freezing both the element-name and class maps,
    * this method examines the scanner's current start tag, maps it to a marshallable-object class via the lookup method,
    * and then invokes the unmarshal(XMLScanner, Class) method, passing the scanner and the class.
    *
    * @param xs    The scanner from which data will be unmarshalled
    * @see javax.xml.bind.UnmarshalException
    */
    public static CompResult unmarshal(XMLScanner xs) throws UnmarshalException {
        return unmarshal(xs, newDispatcher());
    }

    /**
     * Unmarshals and validates a content tree using the given scanner and dispatcher.
     *
     * @param xs  The scanner from which data will be unmarshalled
     * @param d a dispatcher used to map element names to class names, and to initiate the unmarshalling process
     * @throws UnmarshalException
     * @see javax.xml.bind.UnmarshalException
     */
    public static CompResult unmarshal(XMLScanner xs, Dispatcher d) throws UnmarshalException {
        return ((CompResult) d.unmarshal(xs, (CompResult.class)));
    }

    /**
     * Indicates whether some other object is "equal to" this one.
     *
     * @param ob the reference object with which to compare.
     * @return boolean true if this object is the same as the obj argument; false otherwise.
     */
    public boolean equals(Object ob) {
        if (this == ob) {
            return true;
        }
        if (!(ob instanceof CompResult)) {
            return false;
        }
        CompResult tob = ((CompResult) ob);
        if (_ElementId != null) {
            if (tob._ElementId == null) {
                return false;
            }
            if (!_ElementId.equals(tob._ElementId)) {
                return false;
            }
        } else {
            if (tob._ElementId != null) {
                return false;
            }
        }
        if (_ResultId != null) {
            if (tob._ResultId == null) {
                return false;
            }
            if (!_ResultId.equals(tob._ResultId)) {
                return false;
            }
        } else {
            if (tob._ResultId != null) {
                return false;
            }
        }
        if (_GroupOrder != null) {
            if (tob._GroupOrder == null) {
                return false;
            }
            if (!_GroupOrder.equals(tob._GroupOrder)) {
                return false;
            }
        } else {
            if (tob._GroupOrder != null) {
                return false;
            }
        }
        if (_ResultType != null) {
            if (tob._ResultType == null) {
                return false;
            }
            if (!_ResultType.equals(tob._ResultType)) {
                return false;
            }
        } else {
            if (tob._ResultType != null) {
                return false;
            }
        }
        if (_FeatureType != null) {
            if (tob._FeatureType == null) {
                return false;
            }
            if (!_FeatureType.equals(tob._FeatureType)) {
                return false;
            }
        } else {
            if (tob._FeatureType != null) {
                return false;
            }
        }
        if (_OnComplementStrand != null) {
            if (tob._OnComplementStrand == null) {
                return false;
            }
            if (!_OnComplementStrand.equals(tob._OnComplementStrand)) {
                return false;
            }
        } else {
            if (tob._OnComplementStrand != null) {
                return false;
            }
        }
        if (_Confidence != null) {
            if (tob._Confidence == null) {
                return false;
            }
            if (!_Confidence.equals(tob._Confidence)) {
                return false;
            }
        } else {
            if (tob._Confidence != null) {
                return false;
            }
        }
        if (_AlignLength != null) {
            if (tob._AlignLength == null) {
                return false;
            }
            if (!_AlignLength.equals(tob._AlignLength)) {
                return false;
            }
        } else {
            if (tob._AlignLength != null) {
                return false;
            }
        }
        if (_AlignUnits != null) {
            if (tob._AlignUnits == null) {
                return false;
            }
            if (!_AlignUnits.equals(tob._AlignUnits)) {
                return false;
            }
        } else {
            if (tob._AlignUnits != null) {
                return false;
            }
        }
        if (_Note != null) {
            if (tob._Note == null) {
                return false;
            }
            if (!_Note.equals(tob._Note)) {
                return false;
            }
        } else {
            if (tob._Note != null) {
                return false;
            }
        }
        if (_MatchDesc != null) {
            if (tob._MatchDesc == null) {
                return false;
            }
            if (!_MatchDesc.equals(tob._MatchDesc)) {
                return false;
            }
        } else {
            if (tob._MatchDesc != null) {
                return false;
            }
        }
        if (_MatchAlign != null) {
            if (tob._MatchAlign == null) {
                return false;
            }
            if (!_MatchAlign.equals(tob._MatchAlign)) {
                return false;
            }
        } else {
            if (tob._MatchAlign != null) {
                return false;
            }
        }
        if (_QueryRegion != null) {
            if (tob._QueryRegion == null) {
                return false;
            }
            if (!_QueryRegion.equals(tob._QueryRegion)) {
                return false;
            }
        } else {
            if (tob._QueryRegion != null) {
                return false;
            }
        }
        if (_MatchRegion != null) {
            if (tob._MatchRegion == null) {
                return false;
            }
            if (!_MatchRegion.equals(tob._MatchRegion)) {
                return false;
            }
        } else {
            if (tob._MatchRegion != null) {
                return false;
            }
        }
        if (_ResultProperty != null) {
            if (tob._ResultProperty == null) {
                return false;
            }
            if (!_ResultProperty.equals(tob._ResultProperty)) {
                return false;
            }
        } else {
            if (tob._ResultProperty != null) {
                return false;
            }
        }
        if (_ResultGroup != null) {
            if (tob._ResultGroup == null) {
                return false;
            }
            if (!_ResultGroup.equals(tob._ResultGroup)) {
                return false;
            }
        } else {
            if (tob._ResultGroup != null) {
                return false;
            }
        }
        if (_RelatedAnnot != null) {
            if (tob._RelatedAnnot == null) {
                return false;
            }
            if (!_RelatedAnnot.equals(tob._RelatedAnnot)) {
                return false;
            }
        } else {
            if (tob._RelatedAnnot != null) {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns a hash code value for the object.
     * This method is supported for the benefit of hashtables such as those provided by java.util.Hashtable.
     *
     * @return int  a hash code value for this object.
     */
    public int hashCode() {
        int h = 0;
        h = ((127 * h) + ((_ElementId != null) ? _ElementId.hashCode() : 0));
        h = ((127 * h) + ((_ResultId != null) ? _ResultId.hashCode() : 0));
        h = ((127 * h) + ((_GroupOrder != null) ? _GroupOrder.hashCode() : 0));
        h = ((127 * h) + ((_ResultType != null) ? _ResultType.hashCode() : 0));
        h = ((127 * h) + ((_FeatureType != null) ? _FeatureType.hashCode() : 0));
        h = ((127 * h) + ((_OnComplementStrand != null) ? _OnComplementStrand.hashCode() : 0));
        h = ((127 * h) + ((_Confidence != null) ? _Confidence.hashCode() : 0));
        h = ((127 * h) + ((_AlignLength != null) ? _AlignLength.hashCode() : 0));
        h = ((127 * h) + ((_AlignUnits != null) ? _AlignUnits.hashCode() : 0));
        h = ((127 * h) + ((_Note != null) ? _Note.hashCode() : 0));
        h = ((127 * h) + ((_MatchDesc != null) ? _MatchDesc.hashCode() : 0));
        h = ((127 * h) + ((_MatchAlign != null) ? _MatchAlign.hashCode() : 0));
        h = ((127 * h) + ((_QueryRegion != null) ? _QueryRegion.hashCode() : 0));
        h = ((127 * h) + ((_MatchRegion != null) ? _MatchRegion.hashCode() : 0));
        h = ((127 * h) + ((_ResultProperty != null) ? _ResultProperty.hashCode() : 0));
        h = ((127 * h) + ((_ResultGroup != null) ? _ResultGroup.hashCode() : 0));
        h = ((127 * h) + ((_RelatedAnnot != null) ? _RelatedAnnot.hashCode() : 0));
        return h;
    }

    /**
     * Returns a string representation of the object and includes the tree contents from it's child.
     *
     * @return String a string representation of the object.
     */
    public String toString() {
        StringBuffer sb = new StringBuffer("<<comp_result");
        if (_ElementId != null) {
            sb.append(" element_id=");
            sb.append(_ElementId.toString());
        }
        if (_ResultId != null) {
            sb.append(" result_id=");
            sb.append(_ResultId.toString());
        }
        if (_GroupOrder != null) {
            sb.append(" group_order=");
            sb.append(_GroupOrder.toString());
        }
        if (_ResultType != null) {
            sb.append(" result_type=");
            sb.append(_ResultType.toString());
        }
        if (_FeatureType != null) {
            sb.append(" feature_type=");
            sb.append(_FeatureType.toString());
        }
        sb.append(" on_complement_strand=");
        sb.append(getOnComplementStrand().toString());
        if (_Confidence != null) {
            sb.append(" confidence=");
            sb.append(_Confidence.toString());
        }
        if (_AlignLength != null) {
            sb.append(" align_length=");
            sb.append(_AlignLength.toString());
        }
        if (_AlignUnits != null) {
            sb.append(" align_units=");
            sb.append(_AlignUnits.toString());
        }
        if (_Note != null) {
            sb.append(" note=");
            sb.append(_Note.toString());
        }
        if (_MatchDesc != null) {
            sb.append(" match_desc=");
            sb.append(_MatchDesc.toString());
        }
        if (_MatchAlign != null) {
            sb.append(" match_align=");
            sb.append(_MatchAlign.toString());
        }
        if (_QueryRegion != null) {
            sb.append(" query_region=");
            sb.append(_QueryRegion.toString());
        }
        if (_MatchRegion != null) {
            sb.append(" match_region=");
            sb.append(_MatchRegion.toString());
        }
        if (_ResultProperty != null) {
            sb.append(" result_property=");
            sb.append(_ResultProperty.toString());
        }
        if (_ResultGroup != null) {
            sb.append(" result_group=");
            sb.append(_ResultGroup.toString());
        }
        if (_RelatedAnnot != null) {
            sb.append(" related_annot=");
            sb.append(_RelatedAnnot.toString());
        }
        sb.append(">>");
        return sb.toString();
    }

    /**
     * Creates a <code>Dispatcher<code> containing two maps, an element-name map and a class map.
     * The element-name map maps element names to marshallable-object classes;
     * the class map maps marshallable-object classes to user-defined subclasses.
     *
     * @return Dispatcher   a Dispatcher contains element-name map and class map.
     */
    public static Dispatcher newDispatcher() {
        return AltIds.newDispatcher();
    }

    private static class ResultPropertyPredicate implements PredicatedLists.Predicate {

        public void check(Object ob) {
            if (!(ob instanceof ResultProperty)) {
                throw new InvalidContentObjectException(ob, (ResultProperty.class));
            }
        }
    }

    private static class ResultGroupPredicate implements PredicatedLists.Predicate {

        public void check(Object ob) {
            if (!(ob instanceof ResultGroup)) {
                throw new InvalidContentObjectException(ob, (ResultGroup.class));
            }
        }
    }

    private static class RelatedAnnotPredicate implements PredicatedLists.Predicate {

        public void check(Object ob) {
            if (!(ob instanceof RelatedAnnot)) {
                throw new InvalidContentObjectException(ob, (RelatedAnnot.class));
            }
        }
    }
}
