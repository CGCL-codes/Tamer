package org.aperion.sub2text;

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;

/**
 * This class is designed to read the subtitle file generated by tcextract.<br>
 * It was tested with version 1.0.2.<br>
 * <br>
 * If you just want to generate all the images, do it like that:<br>
 * <code>
 * SubtitleDecoder sd = new SubtitleDecoder(new FileInputStream("en.ps1"));
 * for(int i=1;sd.hasMoreImages();i++){
 *     BufferedImage img = new BufferedImage(sd.getWidth(),sd.getHeight(),BufferedImage.TYPE_INT_ARGB);
 *     img.setRGB(0,0,sd.getWidth(),sd.getHeight(),sd.getARGB(null),0,sd.getWidth());
 *     ImageIO.write(img,"png",new File("en_"+i+".png"));
 * }
 * sd.close();
 * </code>
 * <br>
 * While of course <code>en.ps1</code> was generated with:<br>
 * <code>tccat -i /dev/dvd -T 1,-1 | tcextract -x ps1 -t vob -a 0x2x > en.ps1</code><br>
 * <br>
 * The use of pipes (use System.in) or named pipes (use a FileInputStream) is also possible.<br>
 * <br>
 * Alot of the code (variable names and so on) is based on transcode's spudec.
 * 
 * @author Christian Wasserthal
 */
public final class SubtitleDecoder {

    private static final String MAGIC = "SUBTITLE";

    private static final String SRT_ARROW = " --> ";

    private final boolean debug = false;

    private final InputStream in;

    private byte[] packet_buffer, image_buffer;

    private long bytes_read;

    private int packet_buffer_offset;

    private double chuck_pts;

    private int stream_id;

    private int width, height;

    private int even_lines_start, odd_lines_start;

    private double start_pts, end_pts;

    private final int[] palette;

    private boolean is_forced;

    /**
	 * The sole Contructor.
	 * @param input the {@link InputStream} to read from.
	 */
    public SubtitleDecoder(InputStream input) {
        in = input;
        packet_buffer = new byte[4096];
        image_buffer = new byte[16384];
        palette = new int[4];
        stream_id = -1;
        bytes_read = 0L;
    }

    /**
	 * Read the next image from the {@link InputStream}.
	 * It throws Exceptions for various kinds of reasons, and i'm not gonna list them here :(.
	 * @param verbose if set, the subtitle version and subtitle id (of the first chunk) will be displayed
	 * @throws IOException if something IO-ish wents wrong
	 * @throws EOFException if an empty chuck was found or the subtitle id changes (or the file ends, duh.)
	 */
    public void readNextImage(boolean verbose) throws IOException {
        packet_buffer_offset = 0;
        do {
            readNextChunk(verbose);
            verbose = false;
            if (getShortBE(0) + 10 > packet_buffer.length) {
                byte[] new_packet_buffer = new byte[5 * getShortBE(0) / 4];
                System.arraycopy(packet_buffer, 0, new_packet_buffer, 0, packet_buffer_offset);
                packet_buffer = new_packet_buffer;
            }
        } while (packet_buffer_offset < getShortBE(0));
        if (debug) {
            System.err.println("package information:");
            System.err.println("  packet size: " + packet_buffer_offset);
        }
        checkPointerIntegrity();
        decodePackageHeader();
        if (debug) {
            System.err.println("  image width: " + width);
            System.err.println("  image height: " + height);
            System.err.println("  start of even lines: " + even_lines_start / 2);
            System.err.println("  start of odd lines: " + odd_lines_start / 2);
            System.err.println("  start pts: " + start_pts);
            System.err.println("  end pts: " + end_pts);
            System.err.println("  palette (emph2):      0x" + Integer.toHexString(palette[0]));
            System.err.println("  palette (emph1):      0x" + Integer.toHexString(palette[1]));
            System.err.println("  palette (pattern):    0x" + Integer.toHexString(palette[2]));
            System.err.println("  palette (background): 0x" + Integer.toHexString(palette[3]));
            System.err.println();
        }
        if (width * height > image_buffer.length) {
            image_buffer = new byte[5 * width * height / 4];
        }
        decodePackageData();
    }

    private void checkPointerIntegrity() throws IOException {
        for (int x = 0, y = 0; ; x = y) {
            y = getShortBE(x + 2);
            if (x >= 4 && x == y) {
                break;
            }
            if (y <= x || y >= packet_buffer_offset) {
                throw new IOException("broken package (pointer chain not closed)");
            }
        }
    }

    private void readNextChunk(boolean verbose) throws IOException {
        readFully(8);
        String magic = new String(packet_buffer, packet_buffer_offset, 8);
        if (!magic.equals(MAGIC)) {
            throw new IOException("invalid file header (wrong magic)");
        }
        int header_length = readIntLE();
        int header_version = readIntLE();
        int payload_length = readIntLE();
        int lpts = readIntLE();
        double rpts = readDoubleLE();
        int major_version = header_version >> 16;
        int minor_version = header_version & 0x0000FFFF;
        chuck_pts = (rpts > 0 ? rpts : lpts / 300.0 / 90000.0);
        if (debug) {
            System.err.println("chunk information:");
            System.err.println("  header_length: " + header_length);
            System.err.println("  header_version: " + major_version + "." + minor_version);
            System.err.println("  payload_length: " + payload_length);
            System.err.println("  lpts: " + lpts);
            System.err.println("  rpts: " + rpts);
            System.err.println("  pts: " + chuck_pts);
            System.err.println("  skipping: " + (header_length - 24));
        }
        if (major_version != 3) {
            throw new IOException("version " + major_version + "." + minor_version + " is not supported");
        }
        if (verbose) {
            System.out.println("Subtitle version " + major_version + "." + minor_version + " detected. Executing version 3.x support.");
        }
        if (payload_length - 1 == 0) {
            throw new EOFException("empty packet found (signals eof)");
        }
        if (packet_buffer.length < packet_buffer_offset + payload_length) {
            byte[] new_packet_buffer = new byte[packet_buffer_offset + 2 * payload_length];
            System.arraycopy(packet_buffer, 0, new_packet_buffer, 0, packet_buffer_offset);
            packet_buffer = new_packet_buffer;
        }
        readFully(header_length - 24);
        int sid = in.read();
        bytes_read++;
        if (verbose) {
            System.out.println("Stream ID: 0x" + Integer.toHexString(sid));
        }
        if (debug) {
            System.err.println("  stream id: 0x" + Integer.toHexString(sid));
        }
        if (stream_id == -1) {
            stream_id = sid;
        } else if (stream_id != sid) {
            throw new EOFException("the subtitle id changed");
        }
        readFully(payload_length - 1);
        packet_buffer_offset += payload_length - 1;
        if (debug) {
            System.err.println("  is last chunk: " + (packet_buffer_offset == getShortBE(0)));
            System.err.println();
        }
    }

    private void decodePackageHeader() {
        int date;
        int off;
        int start_off = 0;
        int control_start = getShortBE(2);
        palette[0] = palette[1] = palette[2] = palette[3] = 0;
        is_forced = false;
        if (debug) {
            System.err.println("  control_start: " + control_start);
        }
        for (int next_off = control_start; start_off != next_off; ) {
            start_off = next_off;
            date = getShortBE(start_off);
            next_off = getShortBE(start_off + 2);
            off = start_off + 4;
            for (int type = packet_buffer[off++]; type != -1; type = packet_buffer[off++]) {
                switch(type) {
                    case 0:
                        is_forced = true;
                    case 1:
                        start_pts = chuck_pts + (date * 1024) / 90000.0;
                        break;
                    case 2:
                        end_pts = chuck_pts + (date * 1024) / 90000.0;
                        return;
                    case 3:
                        int gray = (packet_buffer[off] & 0x000000F0) / 16 * 17;
                        palette[0] |= gray << 16 | gray << 8 | gray;
                        gray = (packet_buffer[off] & 0x0000000F) * 17;
                        palette[1] |= gray << 16 | gray << 8 | gray;
                        gray = (packet_buffer[off + 1] & 0x000000F0) / 16 * 17;
                        palette[2] |= gray << 16 | gray << 8 | gray;
                        gray = (packet_buffer[off + 1] & 0x0000000F) * 17;
                        palette[3] |= gray << 16 | gray << 8 | gray;
                        off += 2;
                        break;
                    case 4:
                        palette[0] |= (((~packet_buffer[off]) & 0x000000F0) / 16 * 17) << 24;
                        palette[1] |= (((~packet_buffer[off]) & 0x0000000F) * 17) << 24;
                        palette[2] |= (((~packet_buffer[off + 1]) & 0x000000F0) / 16 * 17) << 24;
                        palette[3] |= (((~packet_buffer[off + 1]) & 0x0000000F) * 17) << 24;
                        off += 2;
                        break;
                    case 5:
                        int start_col = getNibble(2 * off) << 8 | getNibble(2 * off + 1) << 4 | getNibble(2 * off + 2);
                        int end_col = getNibble(2 * off + 3) << 8 | getNibble(2 * off + 4) << 4 | getNibble(2 * off + 5);
                        int start_row = getNibble(2 * off + 6) << 8 | getNibble(2 * off + 7) << 4 | getNibble(2 * off + 8);
                        int end_row = getNibble(2 * off + 9) << 8 | getNibble(2 * off + 10) << 4 | getNibble(2 * off + 11);
                        width = end_col - start_col + 1;
                        height = end_row - start_row + 1;
                        off += 6;
                        break;
                    case 6:
                        even_lines_start = 2 * getShortBE(off);
                        odd_lines_start = 2 * getShortBE(off + 2);
                        off += 4;
                        break;
                    default:
                        System.out.println("> invalid control type");
                        System.exit(1);
                }
            }
        }
    }

    private void decodePackageData() throws IOException {
        for (int x = 0, y = 0, nid = even_lines_start; ; ) {
            int rle = getNibble(nid++);
            if (rle < 0x04) {
                rle = (rle << 4) | getNibble(nid++);
                if (rle < 0x10) {
                    rle = (rle << 4) | getNibble(nid++);
                    if (rle < 0x040) {
                        rle = (rle << 4) | getNibble(nid++);
                    }
                }
            }
            byte color = (byte) (rle % 4);
            int len = rle >> 2;
            if (len == 0) {
                len = width - x;
            }
            if (x + len > width) {
                throw new IOException("invalid run-length (line too long)");
            }
            for (int i = 0; i < len; i++) {
                image_buffer[y * width + x + i] = color;
            }
            x += len;
            if (x == width) {
                x = 0;
                y += 2;
                if (nid % 2 == 1) {
                    nid++;
                }
                if (nid == odd_lines_start) {
                    y = 1;
                } else if (y >= height && y % 2 == 1) {
                    break;
                }
            }
        }
    }

    /**
	 * @return true, if the {@link InputStream} has more data available
	 * @throws IOException
	 */
    public boolean hasMoreImages() throws IOException {
        return in.available() > 1;
    }

    /**
	 * Closes the {@link InputStream} assosiated with is decoder.
	 * @throws IOException if an IO error occours
	 */
    public void close() throws IOException {
        in.close();
    }

    /**
	 * Get the number of bytes that have been read from the stream.
	 * @return the number of bytes that have been read from the stream
	 */
    public long getBytesRead() {
        return bytes_read;
    }

    protected byte[][] generateMask(boolean[] selection) {
        byte[][] mask = new byte[width][height];
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                mask[x][y] = selection[image_buffer[y * width + x]] ? SubToText.FORGROUND : SubToText.BACKGROUND;
            }
        }
        return mask;
    }

    /**
	 * Get the current image data as an array.
	 * If <code>dest==null</code> a new array will be created.
	 * @param dest the array to store the pixels in
	 * @return dest, or a new int[] of size {@link #getWidth()}}*{@link #getHeight()}}
	 * @see #getARGB(int[], int[])
	 * @see #getWidth()
	 * @see #getHeight()
	 */
    public int[] getARGB(int[] dest) {
        return getARGB(dest, palette);
    }

    /**
	 * Get the current image data as an array.
	 * If <code>dest==null</code> a new array will be created.
	 * The Order of the palette entries is: background, pattern, emph1 and emph2.
	 * @param dest the array to store the pixels in
	 * @param pal an alternative palette (which contains 4 colors)
	 * @return dest, or a new int[] of size {@link #getWidth()}}*{@link #getHeight()}}
	 * @see #getARGB(int[])
	 * @see #getWidth()
	 * @see #getHeight()
	 */
    public int[] getARGB(int[] dest, int[] pal) {
        if (dest == null) {
            dest = new int[width * height];
        }
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                dest[y * width + x] = pal[image_buffer[y * width + x]];
            }
        }
        return dest;
    }

    /**
	 * Get the width of the current image.
	 * @return the width of the current image
	 * @see #getHeight()
	 */
    public int getWidth() {
        return width;
    }

    /**
	 * Get the height of the current image.
	 * @return the height of the current image
	 * @see #getWidth()
	 */
    public int getHeight() {
        return height;
    }

    /**
	 * Get the start second of the current image.
	 * @return the start second of the current image
	 * @see #getEndSecond()
	 * @see #getSrtTimestamp()
	 */
    public double getStartSecond() {
        return start_pts;
    }

    /**
	 * Get the end second of the current image.
	 * @return the end second of the current image
	 * @see #getStartSecond()
	 * @see #getSrtTimestamp()
	 */
    public double getEndSecond() {
        return end_pts;
    }

    /**
	 * Get an srt-style timestamp for the current image.
	 * Like this: "00:03:25,009 --&gt; 00:03:26,840".
	 * @return an srt-style timestamp for the current image
	 */
    public String getSrtTimestamp() {
        StringBuffer st = new StringBuffer(29);
        long start_ms = Math.round(1000.0 * start_pts);
        long end_ms = Math.round(1000.0 * end_pts);
        long start_sec = (start_ms / 1000L) % 60;
        long end_sec = (end_ms / 1000L) % 60;
        long start_min = (start_ms / 60000L) % 60;
        long end_min = (end_ms / 60000L) % 60;
        long start_hrs = start_ms / 3600000L;
        long end_hrs = end_ms / 3600000L;
        start_ms = start_ms % 1000L;
        end_ms = end_ms % 1000L;
        if (start_hrs < 10) {
            st.append('0');
        }
        st.append(start_hrs);
        st.append(':');
        if (start_min < 10) {
            st.append('0');
        }
        st.append(start_min);
        st.append(':');
        if (start_sec < 10) {
            st.append('0');
        }
        st.append(start_sec);
        st.append(',');
        if (start_ms < 10) {
            st.append('0');
        }
        if (start_ms < 100) {
            st.append('0');
        }
        st.append(start_ms);
        st.append(SRT_ARROW);
        if (end_hrs < 10) {
            st.append('0');
        }
        st.append(end_hrs);
        st.append(':');
        if (end_min < 10) {
            st.append('0');
        }
        st.append(end_min);
        st.append(':');
        if (end_sec < 10) {
            st.append('0');
        }
        st.append(end_sec);
        st.append(',');
        if (end_ms < 10) {
            st.append('0');
        }
        if (end_ms < 100) {
            st.append('0');
        }
        st.append(end_ms);
        return st.toString();
    }

    /**
	 * Get whether or not this image is a forced sub.
	 * @return true, if this image is (meant to be) forced to be displayed
	 */
    public boolean isForced() {
        return is_forced;
    }

    /**
	 * Get the stream id of this subtitle stream.
	 * It should be the same as in tcextract's '-a' option.
	 * @return the stream id of this subtitle stream
	 */
    public int getStreamID() {
        return stream_id;
    }

    private void readFully(int len) throws IOException {
        bytes_read += len;
        int read = 0;
        do {
            read += in.read(packet_buffer, packet_buffer_offset + read, len - read);
        } while (read < len);
    }

    private int readIntLE() throws IOException {
        bytes_read += 4;
        return in.read() | (in.read() << 8) | (in.read() << 16) | (in.read() << 24);
    }

    private double readDoubleLE() throws IOException {
        bytes_read += 8;
        return Double.longBitsToDouble(in.read() + (((long) (in.read())) << 8) + (((long) (in.read())) << 16) + (((long) (in.read())) << 24) + (((long) (in.read())) << 32) + (((long) (in.read())) << 40) + (((long) (in.read())) << 48) + (((long) (in.read())) << 56));
    }

    private int getShortBE(int off) {
        bytes_read += 2;
        return (packet_buffer[off] << 8) | (packet_buffer[off + 1] & 0xFF);
    }

    private int getNibble(int index) {
        if (index % 2 == 0) {
            return (packet_buffer[index / 2] & 0x000000F0) >> 4;
        } else {
            return packet_buffer[index / 2] & 0x0000000F;
        }
    }
}
