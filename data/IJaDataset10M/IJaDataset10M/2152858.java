package org.deft.repository.repositorymanager.impl;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import org.deft.repository.artifacttype.MultiArtifactDependencies;
import org.deft.repository.datamodel.FragmentFilter;
import org.deft.repository.datamodel.adapter.ecore.EcoreWrapper;
import org.deft.repository.datamodel.ecoredatamodel.Artifact;
import org.deft.repository.datamodel.ecoredatamodel.ArtifactReference;
import org.deft.repository.datamodel.ecoredatamodel.ArtifactReferenceUpdateType;
import org.deft.repository.datamodel.ecoredatamodel.Chapter;
import org.deft.repository.datamodel.ecoredatamodel.DatamodelFactory;
import org.deft.repository.datamodel.ecoredatamodel.Dependency;
import org.deft.repository.datamodel.ecoredatamodel.Folder;
import org.deft.repository.datamodel.ecoredatamodel.Fragment;
import org.deft.repository.datamodel.ecoredatamodel.FragmentType;
import org.deft.repository.datamodel.ecoredatamodel.Identifiable;
import org.deft.repository.datamodel.ecoredatamodel.Project;
import org.deft.repository.datamodel.ecoredatamodel.Revision;
import org.deft.repository.datamodel.ecoredatamodel.Tutorial;
import org.deft.repository.event.IContentChangeListener;
import org.deft.repository.repositorymanager.ContentManager;

/**
 * A ContentManager working with on an Ecore model. 
 * 
 * A ContentManager is responsible for updating
 * the data structure that represents the logical repository content (projects, chapters, 
 * artifacts, ...). This ContentManager is backed up by an Ecore model. Projects, chapters
 * and stuff are instances of Ecore classes.
 * 
 * It has been decided that the classes generated by Ecore will not be modified. However, the
 * repository contents must implement the org.deft.repository.datamodel interfaces. Therefore,
 * wrapper classes have been created (in package org.deft.repository.datamodel.adapter.ecore).
 * 
 * This ContentManager creates new repository content by first creating a new instance of the
 * Ecore class and then wrapping it in the appropriate wrapper class. The actual wrapping has
 * been externalized to class EcoreDataModelTransformer.
 * 
 * This ContentManager is passed as an argument to the wrapping methods. The ContentManager is
 * forwarded to the wrapper classes which will keep a reference to it. This makes it possible to
 * delegate certain operations on the data model to the ContentManager. For example
 * 
 *  {@link Fragment#getParentProject()} 
 *  
 *  can be delegated to 
 *  
 *  {@link ContentManager#getProjectOf(org.deft.repository.datamodel.Fragment)}
 */
public class ContentManagerEcoreDataModelImpl implements ContentManager {

    private EcoreDataModelImplCore core;

    private DatamodelFactory factory;

    private Map<String, Identifiable> idMap = new HashMap<String, Identifiable>();

    private List<IContentChangeListener> lContentChangeListeners = new LinkedList<IContentChangeListener>();

    private EcoreWrapper wrapper;

    public ContentManagerEcoreDataModelImpl(EcoreDataModelImplCore core, EcoreWrapper wrapper) {
        this.core = core;
        this.factory = DatamodelFactory.eINSTANCE;
        this.core.addContentChangeListener(new CoreContentChangeListener());
        this.wrapper = wrapper;
    }

    public void clear() {
        core.clear();
    }

    public EcoreDataModelImplCore getCore() {
        return core;
    }

    @Override
    public org.deft.repository.datamodel.Project createProject(String name, String projectType) {
        Project project = factory.createProject();
        project.setName(name);
        project.setProjectType(projectType);
        addId(project);
        core.getRootContainer().getProjects().add(project);
        fireContentChanged();
        return wrapper.wrap(project);
    }

    @Override
    public String getProjectType(org.deft.repository.datamodel.Project project) {
        Project eProject = wrapper.unwrap(project);
        String type = eProject.getProjectType();
        return type;
    }

    @Override
    public List<org.deft.repository.datamodel.Project> getProjects() {
        List<Project> allProjects = ecoreGetProjects();
        return wrapper.convertProjectList(allProjects);
    }

    private List<Project> ecoreGetProjects() {
        List<Project> allProjects = new LinkedList<Project>();
        allProjects.addAll(core.getRootContainer().getProjects());
        return allProjects;
    }

    @Override
    public org.deft.repository.datamodel.Project getProject(String name) {
        for (Project p : core.getRootContainer().getProjects()) {
            if (p.getName().equals(name)) {
                return wrapper.wrap(p);
            }
        }
        return null;
    }

    @Override
    public org.deft.repository.datamodel.Project getProjectOf(org.deft.repository.datamodel.Fragment fragment) {
        Fragment ecoreFragment = wrapper.unwrap(fragment);
        Project project = getProjectOf(ecoreFragment);
        return wrapper.wrap(project);
    }

    private Project getProjectOf(Fragment fragment) {
        Project project = fragment.getParentProject();
        return project;
    }

    @Override
    public org.deft.repository.datamodel.Chapter createChapter(org.deft.repository.datamodel.Project project, String name, String chapterType) {
        Project eProject = wrapper.unwrap(project);
        Chapter chapter = createChapter(eProject, name, chapterType);
        fireContentChanged();
        return wrapper.wrap(chapter);
    }

    private Chapter createChapter(Project project, String name, String chapterType) {
        Chapter chapter = factory.createChapter();
        chapter.setName(name);
        chapter.setChapterType(chapterType);
        addId(chapter);
        chapter.setParentProject(project);
        project.getChapters().add(chapter);
        return chapter;
    }

    @Override
    public String getChapterType(org.deft.repository.datamodel.Chapter chapter) {
        Chapter eChapter = wrapper.unwrap(chapter);
        String type = eChapter.getChapterType();
        return type;
    }

    @Override
    public org.deft.repository.datamodel.Tutorial createTutorial(org.deft.repository.datamodel.Project project, String name) {
        Project ecoreProject = wrapper.unwrap(project);
        Tutorial tutorial = factory.createTutorial();
        tutorial.setName(name);
        addId(tutorial);
        tutorial.setParentProject(ecoreProject);
        ecoreProject.getTutorials().add(tutorial);
        fireContentChanged();
        return wrapper.wrap(tutorial);
    }

    @Override
    public org.deft.repository.datamodel.Artifact createArtifact(org.deft.repository.datamodel.Project project, String fragmentSourceId, String location, String artifactTypeId, int revision, MultiArtifactDependencies dependencies, String name) {
        Project ecoreProject = wrapper.unwrap(project);
        Artifact ecoreArtifact = createArtifact(ecoreProject, fragmentSourceId, location, artifactTypeId, revision, dependencies, name);
        return wrapper.wrap(ecoreArtifact);
    }

    private Artifact createArtifact(Project project, String fragmentSourceId, String location, String artifactTypeId, int revision, MultiArtifactDependencies dependencies, String name) {
        Artifact artifact = factory.createArtifact();
        artifact.setName(name);
        artifact.setSourceId(fragmentSourceId);
        artifact.setArtifactType(artifactTypeId);
        addId(artifact);
        artifact.setParentProject(project);
        project.getArtifacts().add(artifact);
        addRevisionIndex(artifact, location, revision, dependencies);
        return artifact;
    }

    @Override
    public org.deft.repository.datamodel.Folder createFolder(org.deft.repository.datamodel.Project project, org.deft.repository.datamodel.FragmentType fragType, String name) {
        Project eProject = wrapper.unwrap(project);
        FragmentType eFragType = wrapper.unwrap(fragType);
        Folder folder = createFolder(eProject, eFragType, name);
        fireContentChanged();
        return wrapper.wrap(folder);
    }

    private Folder createFolder(Project project, FragmentType fragType, String name) {
        Folder folder = factory.createFolder();
        folder.setName(name);
        addId(folder);
        folder.setFragmentTypeAffiliation(fragType);
        folder.setParentProject(project);
        project.getFolders().add(folder);
        return folder;
    }

    @Override
    public org.deft.repository.datamodel.Folder createFolder(org.deft.repository.datamodel.Folder parent, String name) {
        Folder eParent = wrapper.unwrap(parent);
        Folder eNewFolder = createFolder(eParent, name);
        fireContentChanged();
        return wrapper.wrap(eNewFolder);
    }

    private Folder createFolder(Folder parent, String name) {
        Project project = getProjectOf(parent);
        FragmentType fragType = parent.getFragmentTypeAffiliation();
        Folder folder = factory.createFolder();
        folder.setName(name);
        addId(folder);
        folder.setFragmentTypeAffiliation(fragType);
        folder.setParentProject(project);
        folder.setParent(parent);
        return folder;
    }

    @Override
    public org.deft.repository.datamodel.Folder getParentFolder(org.deft.repository.datamodel.Fragment fragment) {
        Fragment eFragment = wrapper.unwrap(fragment);
        Folder folder = getParentFolder(eFragment);
        return wrapper.wrap(folder);
    }

    private Folder getParentFolder(Fragment fragment) {
        Folder folder = fragment.getParent();
        return folder;
    }

    @Override
    public void setParentFolder(org.deft.repository.datamodel.Fragment fragment, org.deft.repository.datamodel.Folder parentFolder) {
        Fragment eFragment = wrapper.unwrap(fragment);
        Folder eParentFolder = wrapper.unwrap(parentFolder);
        setParentFolder(eFragment, eParentFolder);
        fireContentChanged();
    }

    /**
	 * A fragment is in one of the following lists of EReferences:
	 * chapters, artifacts, tutorials, or folders (see EClass Project)
	 */
    private void setParentFolder(Fragment fragment, Folder parentFolder) {
        Project project = fragment.getParentProject();
        fragment.setParent(parentFolder);
        if (parentFolder == null) {
            if (fragment instanceof Chapter) {
                project.getChapters().add((Chapter) fragment);
            } else if (fragment instanceof Artifact) {
                project.getArtifacts().add((Artifact) fragment);
            } else if (fragment instanceof Tutorial) {
                project.getTutorials().add((Tutorial) fragment);
            }
        }
    }

    @Override
    public void addChapterToTutorial(org.deft.repository.datamodel.Tutorial tutorial, org.deft.repository.datamodel.Chapter chapter) {
        Tutorial ecoreTutorial = wrapper.unwrap(tutorial);
        Chapter ecoreChapter = wrapper.unwrap(chapter);
        ecoreTutorial.getChapters().add(ecoreChapter);
        fireContentChanged();
    }

    @Override
    public void removeChapterFromTutorial(org.deft.repository.datamodel.Tutorial tutorial, org.deft.repository.datamodel.Chapter chapter) {
        Tutorial eTutorial = wrapper.unwrap(tutorial);
        Chapter eChapter = wrapper.unwrap(chapter);
        removeChapterFromTutorial(eTutorial, eChapter);
        fireContentChanged();
    }

    private void removeChapterFromTutorial(Tutorial tutorial, Chapter chapter) {
        tutorial.getChapters().remove(chapter);
    }

    @Override
    public List<org.deft.repository.datamodel.Chapter> getChaptersForTutorial(org.deft.repository.datamodel.Tutorial tutorial) {
        Tutorial eTutorial = wrapper.unwrap(tutorial);
        List<Chapter> eList = getChaptersForTutorial(eTutorial);
        return wrapper.convertFragmentList(eList, org.deft.repository.datamodel.Chapter.class);
    }

    private List<Chapter> getChaptersForTutorial(Tutorial tutorial) {
        List<Chapter> chapters = new LinkedList<Chapter>();
        chapters.addAll(tutorial.getChapters());
        return chapters;
    }

    @Override
    public List<org.deft.repository.datamodel.Tutorial> getTutorialsForChapter(org.deft.repository.datamodel.Chapter chapter) {
        Chapter eChapter = wrapper.unwrap(chapter);
        List<Tutorial> eList = getTutorialsForChapter(eChapter);
        return wrapper.convertFragmentList(eList, org.deft.repository.datamodel.Tutorial.class);
    }

    private List<Tutorial> getTutorialsForChapter(Chapter chapter) {
        List<Tutorial> tutorials = new LinkedList<Tutorial>();
        tutorials.addAll(chapter.getInTutorials());
        return tutorials;
    }

    @Override
    public org.deft.repository.datamodel.Fragment getFragment(String id) {
        Identifiable identifiable = idMap.get(id);
        if (identifiable == null || !(identifiable instanceof Fragment)) {
            return null;
        }
        return wrapper.wrap((Fragment) identifiable);
    }

    @Override
    public List<org.deft.repository.datamodel.Fragment> getFragments(org.deft.repository.datamodel.Project project, FragmentFilter filter) {
        Project eProject = wrapper.unwrap(project);
        List<Fragment> eList = getFragments(eProject, filter);
        return wrapper.convertFragmentList(eList, org.deft.repository.datamodel.Fragment.class);
    }

    private List<Fragment> getFragments(Project project, FragmentFilter filter) {
        List<Fragment> list = new LinkedList<Fragment>();
        for (Identifiable ident : idMap.values()) {
            if (ident instanceof Fragment) {
                Fragment frag = (Fragment) ident;
                Project parentProject = frag.getParentProject();
                if (project == parentProject && (filter == null || filter.accept(wrapper.wrap(frag)))) {
                    list.add(frag);
                }
            }
        }
        return list;
    }

    @Override
    public org.deft.repository.datamodel.FragmentType getFragmentTypeAffiliation(org.deft.repository.datamodel.Folder folder) {
        return folder.getFragmentTypeAffiliation();
    }

    @Override
    public void remove(org.deft.repository.datamodel.Fragment fragment) {
        Fragment eFragment = wrapper.unwrap(fragment);
        remove(eFragment);
        fireContentChanged();
    }

    private void remove(Fragment fragment) {
        idMap.remove(fragment.getId());
        Project parentProject = fragment.getParentProject();
        fragment.setParentProject(null);
        fragment.setParent(null);
        if (fragment instanceof Chapter) {
            Chapter chapter = (Chapter) fragment;
            for (Tutorial tutorial : getTutorialsForChapter(chapter)) {
                removeChapterFromTutorial(tutorial, chapter);
            }
            parentProject.getChapters().remove(fragment);
        } else if (fragment instanceof Artifact) {
            parentProject.getArtifacts().remove(fragment);
        } else if (fragment instanceof Tutorial) {
            Tutorial tutorial = (Tutorial) fragment;
            for (Chapter chapter : getChaptersForTutorial(tutorial)) {
                removeChapterFromTutorial(tutorial, chapter);
            }
            parentProject.getTutorials().remove(fragment);
        } else if (fragment instanceof Folder) {
            Folder folder = (Folder) fragment;
            assert !hasChildren(folder) : "Folder is not expected to have children here! Remove them first.";
            parentProject.getFolders().remove(folder);
            folder.setParent(null);
        } else {
            throw new UnsupportedOperationException("Fragments of type " + fragment.getClass() + " cannot be handled at the moment.");
        }
    }

    private boolean hasChildren(Folder folder) {
        List<Fragment> children = folder.getChildren();
        return !children.isEmpty();
    }

    @Override
    public void remove(org.deft.repository.datamodel.Project project) {
        Project ecoreProject = wrapper.unwrap(project);
        core.getRootContainer().getProjects().remove(ecoreProject);
        fireContentChanged();
    }

    @Override
    public void setChapterPosition(org.deft.repository.datamodel.Tutorial tutorial, org.deft.repository.datamodel.Chapter chapter, int position) {
        Tutorial ecoreTutorial = wrapper.unwrap(tutorial);
        Chapter ecoreChapter = wrapper.unwrap(chapter);
        int nrChapters = ecoreTutorial.getChapters().size();
        boolean contained = ecoreTutorial.getChapters().remove(ecoreChapter);
        if (contained && position >= 0 && position < nrChapters) {
            ecoreTutorial.getChapters().add(position, ecoreChapter);
        }
        fireContentChanged();
    }

    @Override
    public int getChapterPosition(org.deft.repository.datamodel.Tutorial tutorial, org.deft.repository.datamodel.Chapter chapter) {
        Tutorial ecoreTutorial = wrapper.unwrap(tutorial);
        Chapter ecoreChapter = wrapper.unwrap(chapter);
        int pos = ecoreTutorial.getChapters().indexOf(ecoreChapter);
        return pos;
    }

    @Override
    public void rename(org.deft.repository.datamodel.Fragment fragment, String newName) {
        Fragment ecoreFragment = wrapper.unwrap(fragment);
        ecoreFragment.setName(newName);
        fireContentChanged();
    }

    @Override
    public void rename(org.deft.repository.datamodel.Project project, String newName) {
        Project ecoreProject = wrapper.unwrap(project);
        ecoreProject.setName(newName);
        fireContentChanged();
    }

    private void addId(Identifiable identifiable) {
        String idPrefix = prefix(identifiable);
        String id = IdGenerator.generateId(idPrefix, idMap.keySet());
        identifiable.setId(id);
        idMap.put(id, identifiable);
    }

    private String prefix(Identifiable identifiable) {
        if (identifiable instanceof Project) {
            return "project";
        }
        if (identifiable instanceof Artifact) {
            return "artifact";
        }
        if (identifiable instanceof Chapter) {
            return "chapter";
        }
        if (identifiable instanceof Tutorial) {
            return "tutorial";
        }
        if (identifiable instanceof Folder) {
            return "folder";
        }
        if (identifiable instanceof ArtifactReference) {
            return "ref";
        }
        return "";
    }

    @Override
    public List<org.deft.repository.datamodel.Fragment> getChildren(org.deft.repository.datamodel.Folder folder) {
        Folder eFolder = wrapper.unwrap(folder);
        List<Fragment> list = getChildren(eFolder);
        return wrapper.convertFragmentList(list, org.deft.repository.datamodel.Fragment.class);
    }

    private List<Fragment> getChildren(Folder folder) {
        List<Fragment> children = new LinkedList<Fragment>();
        children.addAll(folder.getChildren());
        return children;
    }

    @Override
    public List<org.deft.repository.datamodel.Fragment> getChildren(org.deft.repository.datamodel.Project project, org.deft.repository.datamodel.FragmentType fragmentType) {
        Project eProject = wrapper.unwrap(project);
        FragmentType eFragmentType = wrapper.unwrap(fragmentType);
        List<Fragment> eChildren = getChildren(eProject, eFragmentType);
        List<org.deft.repository.datamodel.Fragment> children = wrapper.convertFragmentList(eChildren, org.deft.repository.datamodel.Fragment.class);
        return children;
    }

    private List<Fragment> getChildren(Project project, final FragmentType fragmentType) {
        FragmentFilter filter = new FragmentFilter() {

            @Override
            public boolean accept(org.deft.repository.datamodel.Fragment fragment) {
                Fragment eFragment = wrapper.unwrap(fragment);
                if (getParentFolder(eFragment) == null) {
                    if (isOfFragmentType(eFragment, fragmentType) || isFolderOfAffiliation(eFragment, fragmentType)) {
                        return true;
                    }
                }
                return false;
            }
        };
        List<Fragment> children = getFragments(project, filter);
        return children;
    }

    /**
	 * Checks if a Fragment corresponds to a FragmentType.
	 * 
	 * For example, a Chapter corresponds to FragmentType.CHAPTER.
	 */
    private boolean isOfFragmentType(Fragment fragment, FragmentType fragmentType) {
        return fragment instanceof Chapter && fragmentType == FragmentType.CHAPTER || fragment instanceof Artifact && fragmentType == FragmentType.ARTIFACT || fragment instanceof Tutorial && fragmentType == FragmentType.TUTORIAL || fragment instanceof Folder && fragmentType == FragmentType.FOLDER;
    }

    /**
	 * Checks if a fragment is a folder with a specific fragment type affiliation 
	 * (i.e. the ability to hold fragments of a specific type) 
	 */
    private boolean isFolderOfAffiliation(Fragment fragment, FragmentType fragmentType) {
        if (isOfFragmentType(fragment, FragmentType.FOLDER)) {
            Folder folder = (Folder) fragment;
            FragmentType affiliation = folder.getFragmentTypeAffiliation();
            return affiliation == fragmentType;
        }
        return false;
    }

    @Override
    public org.deft.repository.datamodel.ArtifactReference createArtifactReference(org.deft.repository.datamodel.Chapter chapter, org.deft.repository.datamodel.Artifact artifact, String operationChainId, String integratorId) {
        ArtifactReference eRef = factory.createArtifactReference();
        addId(eRef);
        Chapter eChapter = wrapper.unwrap(chapter);
        Artifact eArtifact = wrapper.unwrap(artifact);
        int latestRevision = getLatestRevision(eArtifact);
        eRef.setChapter(eChapter);
        eRef.setArtifact(eArtifact);
        eRef.setOperationChainId(operationChainId);
        eRef.setIntegratorId(integratorId);
        eRef.setLatestCheckedRevision(latestRevision);
        eChapter.getArtifactReferences().add(eRef);
        eArtifact.getArtifactReferences().add(eRef);
        return wrapper.wrap(eRef);
    }

    private int getLatestRevision(Artifact artifact) {
        List<Integer> revisionNumbers = new LinkedList<Integer>();
        for (Revision eRevision : artifact.getRevisions()) {
            int revisionNumber = eRevision.getRevisionNumber();
            revisionNumbers.add(revisionNumber);
        }
        int max = getMax(revisionNumbers);
        return max;
    }

    private int getMax(List<Integer> intList) {
        int max = 0;
        for (int i : intList) {
            max = Math.max(i, max);
        }
        return max;
    }

    @Override
    public org.deft.repository.datamodel.ArtifactReference getArtifactReference(String refId) {
        Identifiable identifiable = idMap.get(refId);
        if (identifiable == null || !(identifiable instanceof ArtifactReference)) {
            return null;
        }
        return wrapper.wrap((ArtifactReference) identifiable);
    }

    @Override
    public void removeArtifactReference(org.deft.repository.datamodel.ArtifactReference reference) {
        ArtifactReference eReference = wrapper.unwrap(reference);
        removeArtifactReference(eReference);
        fireContentChanged();
    }

    private void removeArtifactReference(ArtifactReference reference) {
        idMap.remove(reference.getId());
        Chapter eChapter = reference.getChapter();
        Artifact eArtifact = reference.getArtifact();
        eChapter.getArtifactReferences().remove(reference);
        if (eArtifact != null) {
            eArtifact.getArtifactReferences().remove(reference);
        }
        reference.setChapter(null);
        reference.setArtifact(null);
    }

    @Override
    public void clearArtifactOfArtifactReference(org.deft.repository.datamodel.ArtifactReference reference) {
        ArtifactReference eReference = wrapper.unwrap(reference);
        clearArtifactOfArtifactReference(eReference);
        fireContentChanged();
    }

    public void clearArtifactOfArtifactReference(ArtifactReference reference) {
        reference.setArtifact(null);
    }

    public List<String> getArtifactReferenceIds() {
        return new LinkedList<String>(idMap.keySet());
    }

    @Override
    public void addContentChangeListener(IContentChangeListener listener) {
        lContentChangeListeners.add(listener);
    }

    @Override
    public void removeContentChangeListener(IContentChangeListener listener) {
        lContentChangeListeners.remove(listener);
    }

    private void fireContentChanged() {
        for (IContentChangeListener listener : lContentChangeListeners) {
            listener.contentChanged();
        }
    }

    private class CoreContentChangeListener implements IContentChangeListener {

        @Override
        public void contentChanged() {
            recomputeIdMap();
        }
    }

    @Override
    public List<org.deft.repository.datamodel.ArtifactReference> getArtifactReferences(org.deft.repository.datamodel.Project project) {
        List<ArtifactReference> eReferences = new LinkedList<ArtifactReference>();
        Project eProject = wrapper.unwrap(project);
        List<Fragment> eChapters = getFragments(eProject, FragmentFilter.CHAPTERFILTER);
        for (Fragment eChapterFragment : eChapters) {
            List<ArtifactReference> chapRefs = ((Chapter) eChapterFragment).getArtifactReferences();
            eReferences.addAll(chapRefs);
        }
        List<org.deft.repository.datamodel.ArtifactReference> references = wrapper.convertArtifactReferenceList(eReferences, org.deft.repository.datamodel.ArtifactReference.class);
        return references;
    }

    @Override
    public List<org.deft.repository.datamodel.ArtifactReference> getArtifactReferences(org.deft.repository.datamodel.Chapter chapter) {
        Chapter eChapter = wrapper.unwrap(chapter);
        List<ArtifactReference> eReferences = new LinkedList<ArtifactReference>(eChapter.getArtifactReferences());
        List<org.deft.repository.datamodel.ArtifactReference> references = wrapper.convertArtifactReferenceList(eReferences, org.deft.repository.datamodel.ArtifactReference.class);
        return references;
    }

    @Override
    public List<org.deft.repository.datamodel.ArtifactReference> getArtifactReferences(org.deft.repository.datamodel.Artifact artifact) {
        Artifact eArtifact = wrapper.unwrap(artifact);
        List<ArtifactReference> eReferences = new LinkedList<ArtifactReference>(eArtifact.getArtifactReferences());
        List<org.deft.repository.datamodel.ArtifactReference> references = wrapper.convertArtifactReferenceList(eReferences, org.deft.repository.datamodel.ArtifactReference.class);
        return references;
    }

    @Override
    public org.deft.repository.datamodel.Chapter getChapter(org.deft.repository.datamodel.ArtifactReference reference) {
        ArtifactReference eReference = wrapper.unwrap(reference);
        Chapter eChapter = getChapter(eReference);
        return wrapper.wrap(eChapter);
    }

    private Chapter getChapter(ArtifactReference reference) {
        Chapter chapter = reference.getChapter();
        return chapter;
    }

    @Override
    public org.deft.repository.datamodel.Artifact getArtifact(org.deft.repository.datamodel.ArtifactReference reference) {
        ArtifactReference eReference = wrapper.unwrap(reference);
        Artifact eArtifact = getArtifact(eReference);
        return wrapper.wrap(eArtifact);
    }

    private Artifact getArtifact(ArtifactReference reference) {
        Artifact artifact = reference.getArtifact();
        return artifact;
    }

    @Override
    public int getLatestCheckedRevision(org.deft.repository.datamodel.ArtifactReference reference) {
        ArtifactReference eReference = wrapper.unwrap(reference);
        int latestCheckedRevision = getLatestCheckedRevision(eReference);
        return latestCheckedRevision;
    }

    private int getLatestCheckedRevision(ArtifactReference reference) {
        int revision = reference.getLatestCheckedRevision();
        return revision;
    }

    @Override
    public void setLatestCheckedRevision(org.deft.repository.datamodel.ArtifactReference reference, int latestRevision) {
        ArtifactReference eReference = wrapper.unwrap(reference);
        setLatestCheckedRevision(eReference, latestRevision);
    }

    private void setLatestCheckedRevision(ArtifactReference reference, int latestRevision) {
        reference.setLatestCheckedRevision(latestRevision);
    }

    @Override
    public org.deft.repository.datamodel.ArtifactReferenceUpdateType getUpdateType(org.deft.repository.datamodel.ArtifactReference reference) {
        ArtifactReference eReference = wrapper.unwrap(reference);
        ArtifactReferenceUpdateType updateType = getUpdateType(eReference);
        return wrapper.wrap(updateType);
    }

    private ArtifactReferenceUpdateType getUpdateType(ArtifactReference reference) {
        ArtifactReferenceUpdateType type = reference.getUpdateType();
        return type;
    }

    @Override
    public void setUpdateType(org.deft.repository.datamodel.ArtifactReference reference, org.deft.repository.datamodel.ArtifactReferenceUpdateType updateType) {
        ArtifactReference eReference = wrapper.unwrap(reference);
        ArtifactReferenceUpdateType eUpdateType = wrapper.unwrap(updateType);
        setUpdateType(eReference, eUpdateType);
    }

    private void setUpdateType(ArtifactReference reference, ArtifactReferenceUpdateType updateType) {
        reference.setUpdateType(updateType);
    }

    @Override
    public String getOriginalLocation(org.deft.repository.datamodel.Artifact artifact, int revision) {
        Artifact eArtifact = wrapper.unwrap(artifact);
        Revision eRevision = getRevision(eArtifact, revision);
        String location = eRevision.getOriginalLocation();
        return location;
    }

    private Revision getRevision(Artifact eArtifact, int revisionIndex) {
        for (Revision eRevision : eArtifact.getRevisions()) {
            if (eRevision.getRevisionNumber() == revisionIndex) {
                return eRevision;
            }
        }
        return null;
    }

    @Override
    public String getOriginalLocation(org.deft.repository.datamodel.Artifact artifact, String dependentFileId, int revision) {
        List<Dependency> dependencies = getAllFileDependencies(artifact, revision);
        for (Dependency dependency : dependencies) {
            String id = dependency.getId();
            if (id.equals(dependentFileId)) {
                String location = dependency.getOriginalLocation();
                return location;
            }
        }
        return null;
    }

    /**
	 * Executed when new repository contents are loaded
	 */
    private void recomputeIdMap() {
        idMap.clear();
        for (Project project : core.getRootContainer().getProjects()) {
            addProjectToMap(project);
            addChaptersToMap(project);
            addArtifactsToMap(project);
            addTutorialsToMap(project);
            addFoldersAndItsDescendantsToMap(project);
            addReferencesToMap(project);
        }
    }

    private void addProjectToMap(Project project) {
        idMap.put(project.getId(), project);
    }

    private void addChaptersToMap(Project project) {
        for (Chapter chapter : project.getChapters()) {
            addFragmentToMap(chapter);
        }
    }

    private void addArtifactsToMap(Project project) {
        for (Artifact artifact : project.getArtifacts()) {
            addFragmentToMap(artifact);
        }
    }

    private void addTutorialsToMap(Project project) {
        for (Tutorial tutorial : project.getTutorials()) {
            addFragmentToMap(tutorial);
        }
    }

    private void addFoldersAndItsDescendantsToMap(Project project) {
        for (Folder folder : project.getFolders()) {
            addFragmentToMap(folder);
            addFoldersAndItsDescendantsToMap(folder);
        }
    }

    private void addFoldersAndItsDescendantsToMap(Folder folder) {
        for (Fragment fragment : folder.getChildren()) {
            addFragmentToMap(fragment);
            if (fragment instanceof Folder) {
                addFoldersAndItsDescendantsToMap((Folder) fragment);
            }
        }
    }

    private void addFragmentToMap(Fragment fragment) {
        idMap.put(fragment.getId(), fragment);
    }

    private void addReferencesToMap(Project project) {
        List<Fragment> chapters = getFragments(project, FragmentFilter.CHAPTERFILTER);
        for (Fragment chapterFrag : chapters) {
            Chapter chapter = (Chapter) chapterFrag;
            addArtifactReferencesToMap(chapter);
        }
    }

    private void addArtifactReferencesToMap(Chapter chapter) {
        for (ArtifactReference ref : chapter.getArtifactReferences()) {
            idMap.put(ref.getId(), ref);
        }
    }

    @Override
    public void addRevisionIndex(org.deft.repository.datamodel.Artifact artifact, int revision, String location, MultiArtifactDependencies dependencies) {
        Artifact eArtifact = wrapper.unwrap(artifact);
        addRevisionIndex(eArtifact, location, revision, dependencies);
    }

    private void addRevisionIndex(Artifact eArtifact, String location, int revision, MultiArtifactDependencies dependencies) {
        Revision eRevision = factory.createRevision();
        eRevision.setRevisionNumber(revision);
        eRevision.setOriginalLocation(location);
        eArtifact.getRevisions().add(eRevision);
        List<String> ids = dependencies.getChildIdsFromRoot();
        for (String id : ids) {
            String dependencyLocation = dependencies.getLocationForId(id);
            Dependency eDependency = factory.createDependency();
            eDependency.setId(id);
            eDependency.setOriginalLocation(dependencyLocation);
            eRevision.getDependencies().add(eDependency);
            addSubDependencies(eDependency, dependencies, id);
        }
    }

    private void addSubDependencies(Dependency eParentDependency, MultiArtifactDependencies dependencies, String id) {
        List<String> childIds = dependencies.getDirectChildIds(id);
        for (String childId : childIds) {
            String location = dependencies.getLocationForId(childId);
            Dependency eDependency = factory.createDependency();
            eDependency.setId(childId);
            eDependency.setOriginalLocation(location);
            eParentDependency.getDependencies().add(eDependency);
            addSubDependencies(eDependency, dependencies, childId);
        }
    }

    @Override
    public void removeRevision(org.deft.repository.datamodel.Artifact artifact, int revision) {
        Artifact ecoreArtifact = wrapper.unwrap(artifact);
        Revision r = getRevision(ecoreArtifact, revision);
        ecoreArtifact.getRevisions().remove(r);
    }

    /**
	 * Scans through all revisions from all Artifacts of a Project to find the
	 * highest revision number. 
	 * 
	 * @param project
	 *            the Project for which to find the highest revision number
	 */
    @Override
    public int getLatestRevision(org.deft.repository.datamodel.Project project) {
        int maxRevision = 0;
        for (org.deft.repository.datamodel.Fragment frag : getFragments(project, FragmentFilter.ARTIFACTFILTER)) {
            List<Integer> revisionIndexes = getRevisionIndexes((org.deft.repository.datamodel.Artifact) frag);
            for (int rev : revisionIndexes) {
                if (rev > maxRevision) {
                    maxRevision = rev;
                }
            }
        }
        return maxRevision;
    }

    @Override
    public List<Integer> getRevisionIndexes(org.deft.repository.datamodel.Artifact artifact) {
        List<Integer> indexes = artifact.getRevisions();
        return new LinkedList<Integer>(indexes);
    }

    @Override
    public int getLatestRevision(org.deft.repository.datamodel.Artifact artifact) {
        List<Integer> revisionIndexes = getRevisionIndexes(artifact);
        int max = getMax(revisionIndexes);
        return max;
    }

    @Override
    public List<String> getDependentFileIds(org.deft.repository.datamodel.Artifact artifact, int revision) {
        List<String> ids = new LinkedList<String>();
        for (Dependency dep : getAllFileDependencies(artifact, revision)) {
            if (!ids.contains(dep.getId())) {
                ids.add(dep.getId());
            }
        }
        return ids;
    }

    private List<Dependency> getAllFileDependencies(org.deft.repository.datamodel.Artifact artifact, int revision) {
        List<Dependency> dependencies = new LinkedList<Dependency>();
        Artifact eArtifact = wrapper.unwrap(artifact);
        Revision eRevision = getRevision(eArtifact, revision);
        for (Dependency dependency : eRevision.getDependencies()) {
            dependencies.add(dependency);
            dependencies.addAll(getAllFileDependencies(dependency));
        }
        return dependencies;
    }

    private List<Dependency> getAllFileDependencies(Dependency dependency) {
        List<Dependency> dependencies = new LinkedList<Dependency>();
        for (Dependency childDep : dependency.getDependencies()) {
            dependencies.add(childDep);
            dependencies.addAll(getAllFileDependencies(childDep));
        }
        return dependencies;
    }
}
