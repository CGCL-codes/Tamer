package net.sf.openforge.app;

import java.io.*;
import java.util.*;
import net.sf.openforge.app.project.*;
import net.sf.openforge.lim.CodeLabel;

/**
 * The ForgeFileHandler is the central authority for all files
 * generated by the compiler.  This class operates by allowing classes
 * to register a particular File and associate it with a unique handle
 * of type {@link ForgeFileKey}.  Any class which needs to refer to or
 * use one of the generated files, can obtain the File object for that
 * output file via the specified handle.
 *
 * <p>TBD: It would be beneficial to further isolate the classes which
 * are generating output by creating a list of 'services' that the
 * different outputs of the compiler satisfy.  In this way, a class
 * could query the file handler for the File (or set of files) which
 * satisfy a particular service type (eg HDL output, report output,
 * sim output, etc) and base it's behavior off of that returned file.
 * Currently classes which all need to refer to (for example) the
 * Verilog HDL must refer to the static field member of the
 * VerilogTranslateEngine.
 * 
 * @author imiller
 * Created on 03.17.2006
 */
public class ForgeFileHandler {

    /** A handle to the job, needed for accessing option values to
     * generate names and locations */
    private GenericJob job;

    /** The Map of the key to the File object.  */
    private Map<ForgeFileKey, File> fileMap = new HashMap();

    public ForgeFileHandler(GenericJob job) {
        this.job = job;
    }

    /**
     * registerFile permanently associates a given File with the
     * specified key.  A key may only be registered one time.  The
     * target File for the key is the file in the directory specified
     * by 'base' and with the specified name.
     */
    public File registerFile(ForgeFileKey key, File base, String name) {
        assert key != null : "Cannot use null as a file key";
        assert base != null : "Base dir cannot be null";
        assert name != null : "File name cannot be null";
        File newFile = new File(base, name);
        if (fileMap.containsKey(key) && !fileMap.get(key).equals(newFile)) throw new IllegalArgumentException("Cannot re-register the same file " + key);
        fileMap.put(key, newFile);
        return newFile;
    }

    /**
     * registers a file with the specified name located in the
     * destination directory. 
     */
    public File registerFile(ForgeFileKey key, String name) {
        return registerFile(key, getDestinationDir(), name);
    }

    /**
     * Returns the file associated with the key.  This method will
     * throw an exception if the key has not been registered.
     */
    public File getFile(ForgeFileKey key) {
        if (!fileMap.containsKey(key)) throw new IllegalArgumentException("Unknown file key " + key);
        return fileMap.get(key);
    }

    /**
     * Allows the handler to be queried as to whether a particular key
     * has been registered.
     */
    public boolean isRegistered(ForgeFileKey key) {
        return this.fileMap.containsKey(key);
    }

    /**
     * Returns a string of the form <i>baseName</i>postFix.suffix
     */
    public String buildName(String postFix, String suffix) {
        assert postFix != null;
        String baseName = this.job.getOutputBaseName();
        return baseName + postFix + (suffix != null ? ("." + suffix) : "");
    }

    /**
     * This is a convenience method to get the destination 
     * directory for the files produced by forge. It checks 
     * for the -dfs (destination follows target) switch and 
     * if that is not set, it gets the value from the destination 
     * directory specified by the user.  
     * 
     * @return Destination directory for files produced by forge.
     */
    private File getDestinationDir() {
        if (this.job.getUnscopedBooleanOptionValue(OptionRegistry.DESTINATION_FOLLOWS_TARGET)) {
            File f = this.job.getTargetFiles()[0];
            return f.getParentFile();
        } else {
            Option op = this.job.getOption(OptionRegistry.DESTINATION_DIR);
            File f = new File(op.getValue(CodeLabel.UNSCOPED).toString());
            if (!f.isAbsolute()) {
                op = this.job.getOption(OptionRegistry.CWD);
                final String cwd = op.getValue(CodeLabel.UNSCOPED).toString();
                f = new File(cwd, f.getPath());
            }
            return f;
        }
    }
}
