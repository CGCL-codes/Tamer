package org.authorsite.domain.bib;

import java.util.Set;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.ManyToOne;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.OneToOne;
import javax.persistence.Transient;
import org.apache.commons.lang.builder.CompareToBuilder;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.authorsite.domain.AbstractHuman;
import org.authorsite.domain.Collective;
import org.authorsite.domain.Individual;

/**
 * Class describing a thesis or dissertation or equivalent piece
 * of written work submitted for the award of a university (or equivalent)
 * degree.
 * 
 * <p>The class defines the following additional properties:</p>
 * <ul>
 * <li><code>author</code>: the single individual {@link Individual} (student) author of the thesis.</li>
 * <li><code>awardingBody</code>: the single {@link Collective} (university) awarding the degree.</li>
 * <li><code>degree</code>: the degree for which the degree was awarded (PhD, D.Phil, M.A., etc)</li>
 * </ul>
 * 
 * @author jejking
 *
 */
@Entity
@NamedQueries({ @NamedQuery(name = "ThesisCount", query = "select count(t) from Thesis t"), @NamedQuery(name = "ThesesByTitle", query = "select t from Thesis t where t.title = :title"), @NamedQuery(name = "ThesesByTitleWildcard", query = "select t from Thesis t where t.title like :title"), @NamedQuery(name = "ThesesWithAwardingBody", query = "select t from Thesis t, " + "IN (t.workProducers) wp " + "WHERE " + "wp.abstractHuman = :awardingBody " + "AND " + "wp.workProducerType = org.authorsite.domain.bib.WorkProducerType.AWARDING_BODY "), @NamedQuery(name = "ThesesWithAuthor", query = "select t from Thesis t, " + "IN (t.workProducers) wp " + "WHERE " + "wp.abstractHuman = :author " + "AND " + "wp.workProducerType = org.authorsite.domain.bib.WorkProducerType.AUTHOR "), @NamedQuery(name = "AllTheses", query = "select t from Thesis t order by t.id asc"), @NamedQuery(name = "ThesesBeforeDate", query = "select t from Thesis t where t.workDates.date < :date"), @NamedQuery(name = "ThesesAfterDate", query = "select t from Thesis t " + "where " + "t.workDates.date > :date or t.workDates.toDate > :date"), @NamedQuery(name = "ThesesBetweenDates", query = "select t from Thesis t " + "where " + "(t.workDates.date >= :startDate OR t.workDates.toDate >= :startDate) " + "AND " + "(t.workDates.date <= :endDate OR t.workDates.toDate <= :endDate)") })
public class Thesis extends AbstractWork implements Comparable<Thesis> {

    /**
     * Generated by Eclipse.
     */
    private static final long serialVersionUID = -6310817720547175025L;

    private Individual author;

    private Collective awardingBody;

    private String degree;

    /**
     * Default constructor.
     */
    public Thesis() {
        super();
    }

    /**
     * @param title
     * @param author
     * @param awardingBody
     */
    public Thesis(String title, Individual author, Collective awardingBody) {
        super.setTitle(title);
        this.setAuthor(author);
        this.setAwardingBody(awardingBody);
    }

    /**
     * @param title
     * @param author
     * @param awardingBody
     * @param year
     */
    public Thesis(String title, Individual author, Collective awardingBody, int year) {
        this(title, author, awardingBody);
        WorkDates workDates = new WorkDates(year);
        this.setWorkDates(workDates);
    }

    /**
     * Gets author.
     * 
     * @return author
     */
    @Transient
    public Individual getAuthor() {
        if (this.author == null) {
            Set<AbstractHuman> authors = super.getWorkProducersOfType(WorkProducerType.AUTHOR);
            if (!authors.isEmpty()) {
                this.author = (Individual) authors.iterator().next();
            }
        }
        return this.author;
    }

    /**
     * Sets author.
     * 
     * @param author should not be <code>null</code>
     */
    public void setAuthor(Individual author) {
        if (!super.getWorkProducersOfType(WorkProducerType.AUTHOR).isEmpty()) {
            super.removeAllWorkProducersOfType(WorkProducerType.AUTHOR);
        }
        super.addWorkProducer(WorkProducerType.AUTHOR, author);
        this.author = author;
    }

    /**
     * Get awarding body.
     * 
     * @return awardingBody
     */
    @Transient
    public Collective getAwardingBody() {
        if (this.awardingBody == null) {
            Set<AbstractHuman> awardingBodies = super.getWorkProducersOfType(WorkProducerType.AWARDING_BODY);
            if (!awardingBodies.isEmpty()) {
                this.awardingBody = (Collective) awardingBodies.iterator().next();
            }
        }
        return this.awardingBody;
    }

    /**
     * Sets awarding body.
     * 
     * @param awardingBody should not be <code>null</code>
     */
    public void setAwardingBody(Collective awardingBody) {
        if (!super.getWorkProducersOfType(WorkProducerType.AWARDING_BODY).isEmpty()) {
            super.removeAllWorkProducersOfType(WorkProducerType.AWARDING_BODY);
        }
        super.addWorkProducer(WorkProducerType.AWARDING_BODY, awardingBody);
        this.awardingBody = awardingBody;
    }

    /**
     * Gets degree.
     * 
     * @return degree
     */
    @Column(nullable = false)
    public String getDegree() {
        return this.degree;
    }

    /**
     * Sets degree.
     * 
     * @param degree should not be <code>null</code>
     */
    public void setDegree(String degree) {
        this.degree = degree;
    }

    @Override
    public String toString() {
        return (this.degree + " thesis by: " + this.getAuthor() + " awarded by " + this.awardingBody + " in " + this.getWorkDates());
    }

    public int compareTo(Thesis thesis) {
        return new CompareToBuilder().append(this.getTitle(), thesis.getTitle()).append(this.author, thesis.author).append(this.getWorkDates(), thesis.getWorkDates()).append(this.degree, thesis.degree).append(this.awardingBody, thesis.awardingBody).toComparison();
    }

    @Override
    protected boolean areProducersOk() {
        if (this.typeHumansMap.size() != 2) {
            return false;
        }
        Set<AbstractHuman> authors = this.getWorkProducersOfType(WorkProducerType.AUTHOR);
        if (authors.size() != 1) {
            return false;
        }
        AbstractHuman author = authors.iterator().next();
        if (!(author instanceof Individual)) {
            return false;
        }
        Set<AbstractHuman> awardingBodies = this.getWorkProducersOfType(WorkProducerType.AWARDING_BODY);
        if (awardingBodies.size() != 1) {
            return false;
        }
        AbstractHuman awardingBody = awardingBodies.iterator().next();
        if (!(awardingBody instanceof Collective)) {
            return false;
        }
        return true;
    }
}
