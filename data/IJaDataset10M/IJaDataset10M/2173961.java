package net.sf.jalita.io;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import net.sf.jalita.util.Configuration;
import org.apache.log4j.Logger;

/**
 * VT100-compatible stream reader, almost.
 * 
 * @author Daniel Gal�n y Martins
 * @version $Revision: 1.4 $
 */
public class VT100Reader extends Reader implements VT100Constants {

    private static final int STATE_INIT = 0;

    private static final int STATE_ESC = 1;

    private static final int STATE_BARCODE = 2;

    private static final int STATE_FUNCTION_KEY = 3;

    private static final int STATE_FUNCTION_KEY_EXT = 4;

    private static final int STATE_CURSOR = 5;

    private static final int STATE_FINISHED = 6;

    /** log4j reference */
    public static final Logger log = Logger.getLogger(Configuration.class);

    /** Jalita configuration-properties */
    private static Configuration config = Configuration.getConfiguration();

    /** Tells us if the stream is closed */
    private boolean closed = false;

    /**
	 * reads CRLF and CR, and if only CR and not CRLF was read the following
	 * character will be pushed back
	 */
    private final InputStreamReader in;

    /** the current state of the finite automaton, read from readNextKey() */
    private int state;

    /** saves incoming barcodes recived by readNextKey() */
    private final StringBuffer barcodeBuffer = new StringBuffer();

    /** state of CR keys */
    private boolean carriageReturnRecived = false;

    /** barcode received and terminated by CR, to intercept following LF */
    private boolean barcodeTerminated = false;

    /** IAC control command handler */
    private IACHandler m_IACHandler;

    /** Creates a new VT100Reader */
    public VT100Reader(InputStream in) {
        log.debug("Creating instance of VT100Reader");
        this.in = new InputStreamReader(in);
        try {
            Thread.sleep(config.getTimeBeforeClearBuffer());
            in.skip(in.available());
        } catch (Exception ex) {
        }
    }

    public void setIACHandler(IACHandler handler) {
        m_IACHandler = handler;
    }

    public IACHandler getIACHandler() {
        return m_IACHandler;
    }

    /** checks if the reader is usable, throws elswise an IOException */
    protected void checkReaderState() throws IOException {
        if (closed) {
            throw new IOException("reader closed");
        }
    }

    /**
	 * creates an event from the incoming terminaldata generated by
	 * userinteraction.
	 * this is a finite automaton, which evaluates key and barcodes recived by
	 * the terminal
	 */
    public TerminalEvent readNextEvent() throws IOException {
        TerminalEvent te = null;
        state = STATE_INIT;
        while (state != STATE_FINISHED) {
            int key = m_IACHandler.read();
            if (state == STATE_INIT) {
                if (key == ASCII_ESC) {
                    log.debug("Key is escape sequenz: [" + key + "]");
                    state = STATE_ESC;
                } else if (key == BARCODE_START) {
                    log.debug("Key is barcode start: [" + key + "]");
                    state = STATE_BARCODE;
                } else if (key == CR) {
                    carriageReturnRecived = true;
                    te = new TerminalEvent(this, TerminalEvent.KEY_ENTER);
                    state = STATE_FINISHED;
                    log.debug("Key is return (CR): [" + key + "]");
                } else if (key == LF) {
                    if (carriageReturnRecived) {
                        log.debug("Key is return (CRLF): [" + key + "] -> read over");
                    } else if (barcodeTerminated) {
                        barcodeTerminated = false;
                        log.debug("barcode completed with LF: [" + key + "] -> read over");
                    } else {
                        te = new TerminalEvent(this, TerminalEvent.KEY_ENTER);
                        state = STATE_FINISHED;
                        log.debug("Key is return (LF): [" + key + "]");
                    }
                    carriageReturnRecived = false;
                } else {
                    log.debug("Key is common key: [" + key + "]");
                    switch(key) {
                        case SPECIAL_AE_BIG:
                            te = new TerminalEvent(this, '�');
                            break;
                        case SPECIAL_AE_SMALL:
                            te = new TerminalEvent(this, '�');
                            break;
                        case SPECIAL_OE_BIG:
                            te = new TerminalEvent(this, '�');
                            break;
                        case SPECIAL_OE_SMALL:
                            te = new TerminalEvent(this, '�');
                            break;
                        case SPECIAL_UE_BIG:
                            te = new TerminalEvent(this, '�');
                            break;
                        case SPECIAL_UE_SMALL:
                            te = new TerminalEvent(this, '�');
                            break;
                        case SPECIAL_SZ:
                            te = new TerminalEvent(this, '�');
                            break;
                        case SPECIAL_GRAD:
                            te = new TerminalEvent(this, '�');
                            break;
                        case SPECIAL_TAB:
                            te = new TerminalEvent(this, TerminalEvent.KEY_TAB);
                            break;
                        case SPECIAL_PAUSE:
                            te = new TerminalEvent(this, TerminalEvent.KEY_PAUSE);
                            break;
                        case SPECIAL_BACKSPACE:
                            te = new TerminalEvent(this, TerminalEvent.KEY_BACKSPACE);
                            break;
                        case SPECIAL_DEL:
                            te = new TerminalEvent(this, TerminalEvent.KEY_DEL);
                            break;
                        case SPECIAL_ROOF:
                            te = new TerminalEvent(this, '^');
                            read();
                            break;
                        default:
                            te = new TerminalEvent(this, (char) key);
                    }
                    state = STATE_FINISHED;
                }
            } else if (state == STATE_ESC) {
                if (key == ESC_PARAM_F_KEY) {
                    log.debug("Key is function key: [" + key + "]");
                    state = STATE_FUNCTION_KEY;
                } else if (key == ESC_PARAM_CURSOR) {
                    log.debug("Key is cursor key: [" + key + "]");
                    state = STATE_CURSOR;
                } else if (key == ESC_PARAM_PIPE) {
                    log.debug("Key is pipe key: [" + key + "]");
                    te = new TerminalEvent(this, '|');
                    state = STATE_FINISHED;
                } else {
                    log.warn("esc unknown: [" + key + "]");
                    te = new TerminalEvent(this, TerminalEvent.KEY_UNDEFINED);
                    state = STATE_FINISHED;
                }
            } else if (state == STATE_FUNCTION_KEY) {
                int fKey = TerminalEvent.KEY_F01;
                log.debug("Key is function key: [" + key + "]");
                switch(key) {
                    case ESC_F_01:
                        fKey = TerminalEvent.KEY_F01;
                        break;
                    case ESC_F_02:
                        fKey = TerminalEvent.KEY_F02;
                        break;
                    case ESC_F_03:
                        fKey = TerminalEvent.KEY_F03;
                        break;
                    case ESC_F_04:
                        fKey = TerminalEvent.KEY_F04;
                        break;
                    case ESC_F_05_ALT:
                        fKey = TerminalEvent.KEY_F05;
                        break;
                    case ESC_F_06_ALT:
                        fKey = TerminalEvent.KEY_F06;
                        break;
                    case ESC_F_07_ALT:
                        fKey = TerminalEvent.KEY_F07;
                        break;
                    case ESC_F_08_ALT:
                        fKey = TerminalEvent.KEY_F08;
                        break;
                    case ESC_F_09_ALT:
                        fKey = TerminalEvent.KEY_F09;
                        break;
                    case ESC_F_10_ALT:
                        fKey = TerminalEvent.KEY_F10;
                        break;
                    case ESC_F_11_ALT:
                        fKey = TerminalEvent.KEY_F11;
                        break;
                    case ESC_F_12_ALT:
                        fKey = TerminalEvent.KEY_F12;
                        break;
                    default:
                        fKey = TerminalEvent.KEY_F01;
                }
                te = new TerminalEvent(this, fKey);
                state = STATE_FINISHED;
            } else if (state == STATE_FUNCTION_KEY_EXT) {
                int fKey = TerminalEvent.KEY_F01;
                log.debug("Key is extended function key: [" + key + "]");
                switch(key) {
                    case ESC_F_05:
                        fKey = TerminalEvent.KEY_F05;
                        break;
                    case ESC_F_06:
                        fKey = TerminalEvent.KEY_F06;
                        break;
                    case ESC_F_07:
                        fKey = TerminalEvent.KEY_F07;
                        break;
                    case ESC_F_08:
                        fKey = TerminalEvent.KEY_F08;
                        break;
                    case ESC_F_09:
                        fKey = TerminalEvent.KEY_F09;
                        break;
                    case ESC_F_10:
                        fKey = TerminalEvent.KEY_F10;
                        break;
                    case ESC_F_11:
                        fKey = TerminalEvent.KEY_F11;
                        break;
                    case ESC_F_12:
                        fKey = TerminalEvent.KEY_F12;
                        break;
                    default:
                        fKey = TerminalEvent.KEY_F01;
                }
                read();
                te = new TerminalEvent(this, fKey);
                state = STATE_FINISHED;
            } else if (state == STATE_CURSOR) {
                if ((key == ESC_PARAM_F_KEY_1) || (key == ESC_PARAM_F_KEY_2)) {
                    state = STATE_FUNCTION_KEY_EXT;
                } else {
                    int cKey = TerminalEvent.KEY_F01;
                    log.debug("Key is cursor key: [" + key + "]");
                    switch(key) {
                        case ESC_CURSOR_UP:
                            cKey = TerminalEvent.KEY_UP;
                            break;
                        case ESC_CURSOR_DOWN:
                            cKey = TerminalEvent.KEY_DOWN;
                            break;
                        case ESC_CURSOR_RIGHT:
                            cKey = TerminalEvent.KEY_RIGHT;
                            break;
                        case ESC_CURSOR_LEFT:
                            cKey = TerminalEvent.KEY_LEFT;
                            break;
                        case ESC_CURSOR_TAB_BACK:
                            cKey = TerminalEvent.KEY_TAB_BACK;
                            break;
                        case ESC_CURSOR_EXT_PASTE:
                            read();
                            cKey = TerminalEvent.KEY_PASTE;
                            break;
                        case ESC_CURSOR_EXT_DEL:
                            read();
                            cKey = TerminalEvent.KEY_DEL;
                            break;
                        case ESC_CURSOR_EXT_HOME:
                            read();
                            cKey = TerminalEvent.KEY_HOME;
                            break;
                        case ESC_CURSOR_EXT_END:
                            read();
                            cKey = TerminalEvent.KEY_END;
                            break;
                        case ESC_CURSOR_EXT_PAGE_UP:
                            read();
                            cKey = TerminalEvent.KEY_PAGE_UP;
                            break;
                        case ESC_CURSOR_EXT_PAGE_DOWN:
                            read();
                            cKey = TerminalEvent.KEY_PAGE_DOWN;
                            break;
                        default:
                            cKey = TerminalEvent.KEY_F01;
                    }
                    te = new TerminalEvent(this, cKey);
                    state = STATE_FINISHED;
                }
            } else if (state == STATE_BARCODE) {
                log.debug("Key ist BarcodeKey mit KeyCode: [" + key + "]");
                while (key != BARCODE_END) {
                    barcodeBuffer.append((char) key);
                    key = read();
                }
                barcodeTerminated = true;
                te = new TerminalEvent(this, barcodeBuffer.toString());
                barcodeBuffer.setLength(0);
                state = STATE_FINISHED;
            }
        }
        return te;
    }

    @Override
    public int read(char[] cbuf, int off, int len) throws IOException {
        synchronized (lock) {
            checkReaderState();
            return in.read(cbuf, off, len);
        }
    }

    @Override
    public long skip(long n) throws IOException {
        checkReaderState();
        return super.skip(n);
    }

    @Override
    public void reset() throws IOException {
        checkReaderState();
        super.reset();
    }

    @Override
    public void mark(int readAheadLimit) throws IOException {
        checkReaderState();
        super.mark(readAheadLimit);
    }

    @Override
    public void close() throws IOException {
        closed = true;
    }

    @Override
    public int read(char[] cbuf) throws IOException {
        checkReaderState();
        return super.read(cbuf);
    }

    @Override
    public boolean markSupported() {
        return false;
    }

    @Override
    public int read() throws IOException {
        checkReaderState();
        int result = super.read();
        if (result == -1) {
            throw new IOException();
        }
        return result;
    }

    @Override
    public boolean ready() throws IOException {
        synchronized (lock) {
            checkReaderState();
            return super.ready();
        }
    }
}
