package de.mguennewig.pobjects.metadata;

import java.sql.*;
import java.util.List;
import de.mguennewig.pobjects.*;

/**
 * All types that can be used for a field of a persistent object must
 * implement this interface.
 *
 * <p>Every type maps to exactly one data type in the database schema. The
 * names of the types are chosen to represent their storage characteristics
 * and may differ from the names of SQL data types.</p>
 *
 * @author Michael Gï¿½nnewig
 */
public interface Type {

    /** Name of the Java type used to store values of this <code>Type</code>. */
    int TYPE_NAME = 0;

    /** Return the name of the Java class that holds the type information of this
   * <code>Type</code> in the Java application.
   */
    int CLASS_NAME = 1;

    /** Adds a mapping to this type.
   *
   * @throws NullPointerException if <code>item</code> is <code>null</code>.
   * @throws IllegalArgumentException if already a mapping for the specified
   *   value or label exists.
   */
    void addMap(MapItem item);

    /** Returns the list of mappings.
   *
   * @see #addMap(MapItem)
   * @see #labelToValue(String,ObjectRef)
   * @see #valueToLabel(Object,ObjectRef)
   */
    List<MapItem> getMap();

    Description getDescription();

    void setDescription(Description description);

    /** Checks all constraints imposed on values of this type.
   *
   * @param rec The record which contains <code>column</code>.
   * @param column The column of <code>rec</code> which has this type.
   * @throws PObjConstraintException when any constraint imposed on values of
   *   this type is not fulfilled.
   */
    void checkConstraints(Record rec, Column column) throws PObjConstraintException;

    /** Expands this type to an extra table.
   *
   * <p>Non-scalar types can not be saved directly in a field, so they will be
   * expanded to another table whose {@link ClassDecl declaration} will be
   * generated by this method.</p>
   *
   * @return For a non-scalar type the table declaration, which will be used to
   *   save the data into.  For scalar types <code>null</code>.
   * @see #isScalar
   */
    ClassDecl expand(ClassDecl classDecl, Field field);

    /** Tests whether this type is scalar.
   *
   * @see #expand
   */
    boolean isScalar();

    /**
   * Returns the Java class instance that is being used for the values of this
   * type.
   */
    Class<?> getJavaClass();

    /** Returns the maximum field size required to enter a value of this type.
   *
   * <p>This is the <em>maximum</em> number of characters required to enter a
   * string representation of all valid values of this type.  The typical size
   * of an input field may be much smaller.</p>
   */
    int getMaxFieldSize();

    /** Maps <code>label</code> to its value if defined.
   *
   * @param label The label for which the corresponding value should be
   *   returned.
   * @param valueRef An optional reference which will be used to return the
   *   corresponding value if it exists.
   * @return <code>true</code> if the label could mapped, otherwise
   *   <code>false</code>.
   * @see #valueToLabel(Object,ObjectRef)
   * @see #addMap(MapItem)
   */
    boolean labelToValue(String label, ObjectRef valueRef);

    /** Maps <code>value</code> to its label if defined.
   *
   * @param value The internal object in the type's set for which the
   *   corresponding label should be returned.
   * @param labelRef An optional reference which will be used to return the
   *   corresponding label if it exists.
   * @return <code>true</code> if the value could mapped, otherwise
   *   <code>false</code>.
   * @see #labelToValue(String,ObjectRef)
   * @see #addMap(MapItem)
   */
    boolean valueToLabel(Object value, ObjectRef labelRef);

    /**
   * Map <code>value</code> from its `native' string representation to its
   * internal representation based on the type.
   *
   * <p>This mapping is a one-to-one mapping of string values to the type's
   * value set, without any translation based on {@link MapItem}s associated
   * with the type.</p>
   *
   * <p>For example, an integer type's implementation would accept a value like
   * `<samp>1</samp>' and translate it to the string
   * `<samp>&dblquote;1&dblquote;</samp>', independent of any label associated
   * with the value `<samp>1</samp>'.</p>
   *
   * <p>The value <code>null</code> is always mapped to the empty string.</p>
   *
   * @throws IllegalArgumentException if <code>value</code> is not in this
   *   type's value set. For example a {@link String} when we expect an
   *   {@link Integer}.
   */
    String formatNative(Object value);

    /** Map <code>value</code> to its string representation.
   *
   * <p>If <code>value</code> matches one of the {@link MapItem#getValue()}s
   * associated with this type, then it return its associated label.
   * Otherwise, delegate the job to {@link #formatNative}.</p>
   *
   * @throws IllegalArgumentException if <code>value</code> is not in this
   *   type's value set. For example a {@link String} when we expect an
   *   {@link Integer}.
   * @see #addMap(MapItem)
   * @see #formatNative(Object)
   * @see #valueToLabel(Object,ObjectRef)
   */
    String format(Object value);

    /**
   * Parse <code>value</code> according to the `native' string representation
   * of this type.
   *
   * <p>This representation is a one-to-one mapping of the type's value set to
   * strings, without any translation based on {@link MapItem}s associated with
   * the type.</p>
   *
   * <p>For example, an integer type's implementation would accept a value like
   * `<samp>"1"</samp>' and translate it to an integer object, but would reject
   * a label like `<samp>"Yes"</samp>' that may be associated with the
   * value `<samp>1</samp>'.</p>
   *
   * @throws PObjSyntaxException if <code>value</code> couldn't be parsed as a
   *   string representation of this type.
   * @see #addMap(MapItem)
   * @see #parse(String)
   */
    Object parseNative(String value) throws PObjSyntaxException;

    /** Reads the value for this type from the result set.
   *
   * @throws PObjReadError if any database error occurs.
   * @see #getResultInc()
   */
    Object getResult(Container db, ResultSet rs, int column);

    /** Returns the number of columns read from the <code>ResultSet</code>.
   *
   * @see #getResult(Container,ResultSet,int)
   */
    int getResultInc();

    /** Sets the parameter(s) starting at <code>startPos</code>.
   *
   * <p>This method is the counterpart to
   * {@link #getResult(Container,ResultSet,int)} and
   * {@link #getResultInc()}.</p>
   *
   * @throws SQLException if any database error occurs.
   */
    void setParam(Container db, PreparedStatement statm, int pos, Object value) throws SQLException;

    void checkSyntax(String value) throws PObjSyntaxException;

    /** Map <code>value</code> to its internal representation.
   *
   * <p>If <code>value</code> matches one of the labels associated with this
   * type, then it returns its associated value.  Otherwise, delegates the job
   * to {@link #parseNative}.</p>
   *
   * <p>Furthermore the syntax of the <code>value</code> is checked.</p>
   *
   * @throws PObjSyntaxException if <code>value</code> couldn't be parsed as a
   *   string representation of this type.
   * @see #addMap(MapItem)
   * @see #labelToValue(String,ObjectRef)
   * @see #checkSyntax(String)
   * @see #parseNative(String)
   */
    Object parse(String value) throws PObjSyntaxException;

    /**
   * Returns the fully qualified class name of the type class that is used
   * instead of this one.
   *
   * @return <code>null</code> if this type class is used, otherwise the
   *   fully qualified class name that should be used.
   */
    String getTypeClass();

    /**
   * Sets the fully qualified class name of the type class that should be
   * used instead of this one.
   */
    void setTypeClass(String typeClass);

    /**
   * Returns different names depending on <code>variant</code> for the code
   * generator.
   *
   * <p><b>NOTE:</b> The variant {@link #TYPE_NAME} must be returned by the
   * sub-class.</p>
   *
   * @throws IllegalArgumentException if <code>variant</code> is unknown.
   */
    String name(int variant);
}
