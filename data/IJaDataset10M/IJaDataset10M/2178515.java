package takatuka.vm.autoGenerated.vmSwitch;

import java.io.*;
import java.util.*;
import takatuka.classreader.dataObjs.*;
import takatuka.classreader.dataObjs.attribute.*;
import takatuka.classreader.logic.file.*;
import takatuka.classreader.logic.logAndStats.*;
import takatuka.optimizer.cpGlobalization.logic.util.*;
import takatuka.vm.autoGenerated.*;
import takatuka.classreader.logic.util.*;
import takatuka.optimizer.bytecode.changer.logic.InputOptionsController;

/**
 * 
 * Description:
 * <p>
 *
 * </p> 
 * @author Faisal Aslam
 * @version 1.0
 */
public class GenerateSwitch {

    private static final String SWITCH_HEADER = "switch(instruction) {\n";

    private static final String SWITCH_TRAIL = "\n    default: die(ERROR_INVALID_BYTECODE);\n}\n";

    private static final String JVM_SWITCH_FILE = "JVM_SWITCH_FILE";

    public static final String CODE_START = "\n    ";

    private static final String DEFINE = "#define ";

    private static final String JVM_OPCODE_DEFINATIONS = "JVM_OPCODE_DEFINATIONS";

    private Map<Integer, OpCodeAndCode> bytecodeDefMapFromFile = BytecodeDefinationsReader.getInstanceOf().readFromFile();

    private HashMap<Integer, OpCodeAndCode> newInstbytecodeDefMap = new HashMap();

    private static final GenerateSwitch switchGen = new GenerateSwitch();

    private static final String bytecodeDefinationFile = ConfigPropertyReader.getInstanceOf().getConfigProperty(JVM_OPCODE_DEFINATIONS);

    private String switchOutPutFile = ConfigPropertyReader.getInstanceOf().getConfigProperty(JVM_SWITCH_FILE);

    private HashSet<OpcodeMnemonicInUse> mnemonicSet = null;

    private HashSet<OpcodeMnemonicInUse> mnemonicNotGenerated = null;

    private int usedOpcodesCount = 0;

    private String opcodeDefinationLines = "";

    private TreeSet<Integer> alreadyGeneratedCases = new TreeSet();

    private TreeSet allCases = new TreeSet();

    private static final String OPNEM = "opcode-mnemonic.properties";

    private static final Properties opcodeMnemoicProperties = PropertyReader.getInstanceOf().loadProperties(OPNEM);

    private GenerateSwitch() {
    }

    public static GenerateSwitch getInstanceOf() {
        return switchGen;
    }

    public HashSet<OpcodeMnemonicInUse> getAllOpcodeMnemonicsUseInCode() {
        Oracle oracle = Oracle.getInstanceOf();
        mnemonicSet = oracle.getAllOpcodeMnemonicsUseInCode();
        if (InputOptionsController.isGPJVMWanted()) {
            Set keyset = HeaderFileForWantedopCodes.generalPurposeJVMOpcodes();
            Iterator<String> keysIt = keyset.iterator();
            while (keysIt.hasNext()) {
                String key = keysIt.next().trim();
                if (key.length() != 0) {
                    int opcode = new Integer(key);
                    String mnemonic = Instruction.getMnemonic(opcode);
                    mnemonicSet.add(new OpcodeMnemonicInUse(mnemonic, opcode));
                }
            }
        }
        return mnemonicSet;
    }

    public void generate() {
        Oracle oracle = Oracle.getInstanceOf();
        try {
            mnemonicSet = getAllOpcodeMnemonicsUseInCode();
            mnemonicNotGenerated = (HashSet) mnemonicSet.clone();
            generateCasesForSingleInst();
            generateCasesForMultInst();
            generateCasesForNonCustomizeInst();
            String switchStr = HeaderFileConstants.AUTO_GENERATED_MSG + SWITCH_HEADER;
            Iterator<SwitchCase> cases = allCases.iterator();
            SwitchCase sCase = null;
            int caseOpcode = -1;
            while (cases.hasNext()) {
                sCase = cases.next();
                switchStr += sCase;
                caseOpcode = sCase.opCode;
            }
            switchStr = switchStr + SWITCH_TRAIL;
            String bytecodeDefinationData = createBytecodeDefinationFile();
            ClassFileWriter.writeFile(new File(switchOutPutFile), switchStr);
            ClassFileWriter.writeFile(new File(bytecodeDefinationFile), bytecodeDefinationData);
            if (getAllOpcodeMnemonicsUseInCode().size() != usedOpcodesCount) {
                Miscellaneous.printlnErr("Error #144 ");
                Miscellaneous.exit();
            }
            LogHolder.getInstanceOf().addLog("Total used opcodes (original and generated) by the program= " + usedOpcodesCount + "...");
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
    }

    private void generateCasesForNonCustomizeInst() {
        String mnemonic = null;
        Iterator<OpcodeMnemonicInUse> it = ((HashSet) mnemonicNotGenerated.clone()).iterator();
        int opCode = -1;
        OpCodeAndCode opcodeAndCode = null;
        while (it.hasNext()) {
            mnemonic = it.next().mnemonic;
            opCode = Instruction.getOpcode(mnemonic);
            if (opCode == -1) {
                Miscellaneous.printlnErr("Error # 101: Cannot find opcode for " + mnemonic);
                Instruction.getOpcode(mnemonic);
                Miscellaneous.exit();
            }
            opcodeAndCode = bytecodeDefMapFromFile.get(opCode);
            createCase(opCode, opcodeAndCode.codeWithDefaultAgument, BytecodeProcessor.getTotalParameterSize(opCode) + 1, mnemonic);
        }
    }

    private void generateCasesForSingleInst() {
        RegisterCustomInstruction regCustomInst = RegisterCustomInstruction.getInstanceOf();
        HashMap<Integer, SingleInstrOptimRecord> newInstrToSingleOldInstMap = regCustomInst.newInstrToSingleOldInstMap;
        Set keys = newInstrToSingleOldInstMap.keySet();
        SingleInstrOptimRecord singInstRec = null;
        Iterator<Integer> it = keys.iterator();
        int opcode = -1;
        OpCodeAndCode opcodeAndcode = null;
        while (it.hasNext()) {
            opcode = it.next();
            singInstRec = newInstrToSingleOldInstMap.get(opcode);
            opcodeAndcode = bytecodeDefMapFromFile.get(singInstRec.oldOpCode);
            if (opcodeAndcode == null) {
            }
            OpCodeAndCode newOcAc = new OpCodeAndCode();
            newOcAc.code = opcodeAndcode.code;
            newOcAc.argumentFunction = opcodeAndcode.argumentFunction;
            newOcAc.argumentType = opcodeAndcode.argumentType;
            newOcAc.opCode = singInstRec.newInstruction.getOpCode();
            updateMap(newInstbytecodeDefMap, newOcAc, singInstRec.operandSize, singInstRec.fixOperand, BytecodeProcessor.getAllParameterSizes(singInstRec.oldOpCode));
            createCase(singInstRec.newInstruction.getOpCode(), newOcAc.code, singInstRec.operandSize + 1, singInstRec.newInstruction.getMnemonic());
        }
    }

    static void updateMap(HashMap<Integer, OpCodeAndCode> opcodeAndcodeMap, OpCodeAndCode opcodeAndCode, int size, Un fixedArg, Vector<Integer> parameterSizes) {
        try {
            if (size == 0 && fixedArg != null) {
                if (parameterSizes.size() <= 1) {
                    opcodeAndCode.code = CODE_START + opcodeAndCode.getCodeWithArguments(fixedArg);
                } else {
                    opcodeAndCode.code = CODE_START + opcodeAndCode.getCodeWithArguments(fixedArg, parameterSizes);
                }
            } else {
                if (parameterSizes.size() <= 1) {
                    opcodeAndCode.code = CODE_START + opcodeAndCode.getCodeWithArguments(size);
                } else {
                    opcodeAndCode.code = CODE_START + opcodeAndCode.getCodeWithArguments(parameterSizes, size);
                }
            }
            opcodeAndcodeMap.put(opcodeAndCode.opCode, opcodeAndCode);
        } catch (Exception d) {
            d.printStackTrace();
            Miscellaneous.exit();
        }
    }

    private void generateCasesForMultInst() {
        RegisterCustomInstruction regCustomInst = RegisterCustomInstruction.getInstanceOf();
        HashMap<Integer, MultiInstrOptimRecord> newInstrToOldInstsMap = regCustomInst.newInstrToOldInstsMap;
        Set keys = newInstrToOldInstsMap.keySet();
        Iterator it = keys.iterator();
        Integer opcodeKey = null;
        MultiInstrOptimRecord mInstRec = null;
        int oldOpCode = -1;
        int length = 0;
        String code = null;
        String aggregatedCode = "";
        String mnemonic = "";
        while (it.hasNext()) {
            opcodeKey = (Integer) it.next();
            mInstRec = newInstrToOldInstsMap.get(opcodeKey);
            aggregatedCode = CODE_START;
            int size = mInstRec.oldOpCodes.size();
            length = mInstRec.newInstruction.length();
            mnemonic = mInstRec.newInstruction.getMnemonic();
            for (int loop = 0; loop < size; loop++) {
                oldOpCode = mInstRec.oldOpCodes.elementAt(loop);
                code = newInstbytecodeDefMap.get(oldOpCode) != null ? newInstbytecodeDefMap.get(oldOpCode).code : "";
                if (code.length() == 0) {
                    code = bytecodeDefMapFromFile.get(oldOpCode).codeWithDefaultAgument;
                }
                if (code.length() == 0) {
                    Miscellaneous.printlnErr(" Cannot find instruction" + " for generating VM switch");
                }
                aggregatedCode = aggregatedCode + code + CODE_START;
            }
            createCase(opcodeKey, aggregatedCode, length, mnemonic);
        }
    }

    private void createCase(int opCode, String aggregatedCode, int instLength, String newMnemonic) {
        OpcodeMnemonicInUse temp = new OpcodeMnemonicInUse(newMnemonic, opCode);
        if (!mnemonicSet.contains(temp)) {
            return;
        }
        mnemonicNotGenerated.remove(temp);
        usedOpcodesCount++;
        SwitchCase switchCase = new SwitchCase(opCode, newMnemonic, instLength, aggregatedCode);
        allCases.add(switchCase);
        if (alreadyGeneratedCases.contains(opCode)) {
            new Exception(opCode + "").printStackTrace();
            Miscellaneous.exit();
        }
        alreadyGeneratedCases.add(opCode);
        createBytecodeDefinationLine(newMnemonic, opCode);
    }

    private void createBytecodeDefinationLine(String mnemonic, int opcode) {
        opcodeDefinationLines += "\n" + DEFINE + " " + mnemonic + " " + opcode;
    }

    private String createBytecodeDefinationFile() {
        String ret = HeaderFileConstants.headerStart(bytecodeDefinationFile);
        ret = ret + opcodeDefinationLines;
        ret = ret + "\n\n" + HeaderFileConstants.headerEnd();
        return ret;
    }
}
