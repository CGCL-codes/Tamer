package com.sun.tools.example.debug.tty;

/**
 * <p> This class represents the <code>ResourceBundle</code>
 * for the following package(s):
 *
 * <ol>
 * <li> com.sun.tools.example.debug.tty
 * </ol>
 *
 */
public class TTYResources_zh_CN extends java.util.ListResourceBundle {

    /**
     * Returns the contents of this <code>ResourceBundle</code>.
     *
     * <p>
     *
     * @return the contents of this <code>ResourceBundle</code>.
     */
    public Object[][] getContents() {
        return new Object[][] { { "** classes list **", "** 类列表 **\n{0}" }, { "** fields list **", "** 字段列表 **\n{0}" }, { "** methods list **", "** 方法列表 **\n{0}" }, { "*** Reading commands from", "*** 正在从 {0} 中读取命令" }, { "All threads resumed.", "所有线程已恢复。" }, { "All threads suspended.", "所有线程已暂停。" }, { "Argument is not defined for connector:", "没有为连接器定义参数 {0}： {1}" }, { "Arguments match no method", "参数与方法不匹配" }, { "Array:", "数组：{0}" }, { "Array element is not a method", "数组元素不是方法" }, { "Array index must be a integer type", "数组索引必须为整数类型" }, { "base directory:", "基本目录：{0}" }, { "bootclasspath:", "引导类路径：{0}" }, { "Breakpoint hit:", "断点命中： " }, { "breakpoint", "断点 {0}" }, { "Breakpoints set:", "断点集：" }, { "Breakpoints can be located only in classes.", "断点只能位于类中。{0} 是接口或数组。" }, { "Can only trace", "只能跟踪 'methods'、'method exit' 或 'method exits'" }, { "cannot redefine existing connection", "{0} 无法重新定义现有连接" }, { "Cannot assign to a method invocation", "无法指定给方法调用" }, { "Cannot specify command line with connector:", "无法使用连接器 {0} 指定命令行" }, { "Cannot specify target vm arguments with connector:", "无法使用连接器 {0} 指定目标 VM 参数" }, { "Class containing field must be specified.", "必须指定包含字段的类。" }, { "Class:", "类：{0}" }, { "Classic VM no longer supported.", "不再支持 Classic VM。" }, { "classpath:", "类路径：{0}" }, { "colon mark", ":" }, { "colon space", ": " }, { "Command is not supported on the target VM", "目标 VM 不支持命令 \"{0}\"" }, { "Command is not supported on a read-only VM connection", "只读 VM 连接不支持命令 \"{0}\"" }, { "Command not valid until the VM is started with the run command", "使用 \"run\" 命令启动 VM 之后，命令 \"{0}\" 才有效" }, { "Condition must be boolean", "条件必须为布尔值" }, { "Connector and Transport name", "  连接器：{0}  传送器：{1}" }, { "Connector argument nodefault", "    参数：{0}（无默认值）" }, { "Connector argument default", "    参数：{0} 默认值：{1}" }, { "Connector description", "    描述：{0}" }, { "Connector required argument nodefault", "    必需参数：{0}（无默认值）" }, { "Connector required argument default", "    必需参数：{0} 默认值：{1}" }, { "Connectors available", "可用的连接器包括：" }, { "Constant is not a method", "常量不是方法" }, { "Could not open:", "无法打开：{0}" }, { "Current method is native", "当前方法是本机方法" }, { "Current thread died. Execution continuing...", "当前线程 {0} 已终止。正在继续执行..." }, { "Current thread isnt suspended.", "当前线程未暂停。" }, { "Current thread not set.", "当前线程未设置。" }, { "dbgtrace flag value must be an integer:", "dbgtrace 标志值必须为整数： {0}" }, { "Deferring.", "正在延迟 {0}。\n将在装入类之后对其进行设置。" }, { "End of stack.", "堆栈结尾。" }, { "Error popping frame", "弹出帧时出错 - {0}" }, { "Error reading file", "读取 \"{0}\" 时出错 - {1}" }, { "Error redefining class to file", "将 {0} 重新定义到 {1} 时出错 - {2}" }, { "exceptionSpec all", "所有 {0}" }, { "exceptionSpec caught", "捕捉到 {0}" }, { "exceptionSpec uncaught", "未捕捉到 {0}" }, { "Exception in expression:", "表达式中出现异常：{0}" }, { "Exception occurred caught", "出现异常：{0}（在 {1} 被捕捉）" }, { "Exception occurred uncaught", "出现异常：{0}（未捕捉）" }, { "Exceptions caught:", "出现这些异常时中断：" }, { "expr is null", "{0} = null" }, { "expr is value", "{0} = {1}" }, { "expr is value <collected>", "  {0} = {1} <已收集>" }, { "Expression cannot be void", "表达式不能没有返回值" }, { "Expression must evaluate to an object", "表达式的值必须为对象" }, { "extends:", "扩展： {0}" }, { "Failed reading output", "读取子 java 解释程序的输出失败。" }, { "Fatal error", "致命错误：" }, { "Field access encountered before after", "字段 ({0}) 为 {1}，将 {2}： " }, { "Field access encountered", "遇到字段 ({0}) 访问： " }, { "Field to unwatch not specified", "未指定要取消监视的字段。" }, { "Field to watch not specified", "未指定要监视的字段。" }, { "GC Disabled for", "已禁用 {0} 的 GC：" }, { "GC Enabled for", "已启用 {0} 的 GC：" }, { "grouping begin character", "{" }, { "grouping end character", "}" }, { "Illegal Argument Exception", "非法参数异常" }, { "Illegal connector argument", "非法连接器参数： {0}" }, { "implementor:", "实现者： {0}" }, { "implements:", "实现： {0}" }, { "Initializing progname", "正在初始化 {0}..." }, { "Input stream closed.", "输入流已结束。" }, { "Interface:", "接口： {0}" }, { "Internal debugger error.", "内部调试器错误。" }, { "Internal error: null ThreadInfo created", "内部错误：创建了空的 ThreadInfo" }, { "Internal error; unable to set", "内部错误；无法设置 {0}" }, { "Internal exception during operation:", "在操作过程中出现内部异常：\n    {0}" }, { "Internal exception:", "内部异常：" }, { "Invalid argument type name", "参数类型名称无效" }, { "Invalid assignment syntax", "指定语法无效" }, { "Invalid command syntax", "命令语法无效" }, { "Invalid connect type", "连接类型无效" }, { "Invalid consecutive invocations", "连续调用无效" }, { "Invalid exception object", "异常对象无效" }, { "Invalid method specification:", "无效的方法说明： {0}" }, { "Invalid option on class command", "类命令的选项无效" }, { "invalid option", "无效的选项： {0}" }, { "Invalid thread status.", "线程状态无效。" }, { "Invalid transport name:", "无效的传送器名称： {0}" }, { "I/O exception occurred:", "出现 I/O 异常： {0}" }, { "is an ambiguous method name in", "\"{0}\" 在 \"{1}\" 中是不明确的方法名称" }, { "is an invalid line number for", "对于 {1}，{0,number,integer} 是无效的行号" }, { "is not a valid class name", "\"{0}\" 是无效的类名。" }, { "is not a valid field name", "\"{0}\" 是无效的字段名。" }, { "is not a valid id or class name", "\"{0}\" 是无效的 ID 或类名。" }, { "is not a valid line number or method name for", "对于类 \"{1}\"，\"{0}\" 是无效的行号或方法名" }, { "is not a valid method name", "\"{0}\" 是无效的方法名。" }, { "is not a valid thread id", "\"{0}\" 是无效的线程 ID。" }, { "is not a valid threadgroup name", "\"{0}\" 是无效的线程组名称。" }, { "jdb prompt with no current thread", "> " }, { "jdb prompt thread name and current stack frame", "{0}[{1,number,integer}] " }, { "killed", "{0} 已中止" }, { "killing thread:", "正在中止线程： {0}" }, { "Line number information not available for", "此位置的源行号不可用。" }, { "line number", "：{0,number,integer}" }, { "list field typename and name", "{0} {1}\n" }, { "list field typename and name inherited", "{0} {1}（从 {2}继承）\n" }, { "list field typename and name hidden", "{0} {1} （隐藏）\n" }, { "Listening at address:", "正在以下地址侦听： {0}" }, { "Local variable information not available.", "局部变量信息不可用。使用 -g 编译以生成变量信息" }, { "Local variables:", "局部变量：" }, { "<location unavailable>", "<位置不可用>" }, { "location", "\"thread={0}\", {1}" }, { "locationString", "{0}.{1}(), line={2,number,integer} bci={3,number,integer}" }, { "Main class and arguments must be specified", "必须指定主类和参数" }, { "Method arguments:", "方法参数：" }, { "Method entered:", "方法已输入: " }, { "Method exited:", "方法已退出" }, { "Method exitedValue:", "方法已退出: 返回值 = {0}，" }, { "Method is overloaded; specify arguments", "方法 {0} 已过载；指定参数" }, { "minus version", "这是 {0} 版本 {1,number,integer}.{2,number,integer}（J2SE 版本 {3}）" }, { "Monitor information for thread", "线程 {0} 的监视器信息：" }, { "Monitor information for expr", "{0} ({1}) 的监视器信息：" }, { "More than one class named", "命名了多个类： ''{0}''" }, { "native method", "本机方法" }, { "nested:", "嵌套： {0}" }, { "No attach address specified.", "未指定连接地址。" }, { "No breakpoints set.", "未设置断点。" }, { "No class named", "没有名为 \"{0}\" 的类" }, { "No class specified.", "未指定类。" }, { "No classpath specified.", "未指定类路径。" }, { "No code at line", "{1} 中的第 {0,number,integer} 行没有代码" }, { "No connect specification.", "没有连接说明。" }, { "No connector named:", "没有名为 {0} 的连接器" }, { "No current thread", "没有当前线程" }, { "No default thread specified:", "未指定默认线程：请先使用 \"thread\" 命令。" }, { "No exception object specified.", "未指定异常对象。" }, { "No exceptions caught.", "未捕捉到异常。" }, { "No expression specified.", "未指定表达式。" }, { "No field in", "{1} 中没有字段 {0}" }, { "No frames on the current call stack", "当前调用堆栈中没有帧" }, { "No linenumber information for", "没有 {0} 的行号信息。尝试在启用调试时进行编译。" }, { "No local variables", "无局部变量" }, { "No method in", "{1} 中没有方法 {0}" }, { "No method specified.", "未指定方法。" }, { "No monitor numbered:", "没有编号的监视器： {0}" }, { "No monitors owned", "  没有拥有的监视器" }, { "No object specified.", "未指定对象。" }, { "No objects specified.", "未指定对象。" }, { "No save index specified.", "未指定保存索引。" }, { "No saved values", "没有保存的值" }, { "No source information available for:", "{0}没有可用的源信息" }, { "No sourcedebugextension specified", "未指定 SourceDebugExtension" }, { "No sourcepath specified.", "未指定源路径。" }, { "No thread specified.", "未指定线程。" }, { "No VM connected", "未连接 VM" }, { "No waiters", "  没有等待者" }, { "not a class", "{0} 不是类" }, { "Not a monitor number:", "不是监视器编号： ''{0}''" }, { "not found (try the full name)", "{0} 未找到（请尝试使用全名）" }, { "Not found:", "未找到： {0}" }, { "not found", "{0} 未找到" }, { "Not owned", "  不拥有" }, { "Not waiting for a monitor", "  不等待监视器" }, { "Nothing suspended.", "未暂停任何对象。" }, { "object description and hex id", "({0}){1}" }, { "Operation is not supported on the target VM", "目标 VM 不支持操作" }, { "operation not yet supported", "尚不支持操作" }, { "Owned by:", "  拥有者：{0}，条目计数：{1,number,integer}" }, { "Owned monitor:", "  拥有的监视器： {0}" }, { "Parse exception:", "解析异常： {0}" }, { "printbreakpointcommandusage", "用法：{0} <类>:<行号> 或\n       {1} <类>.<方法名>[(参数类型,...)]" }, { "Removed:", "已删除： {0}" }, { "Requested stack frame is no longer active:", "请求的堆栈帧不再处于活动状态：{0,number,integer}" }, { "run <args> command is valid only with launched VMs", "“run <参数>”命令仅对已启动的 VM 有效" }, { "run", "运行 {0}" }, { "saved", "{0} 已保存" }, { "Set deferred", "设置延迟的 {0}" }, { "Set", "设置 {0}" }, { "Source file not found:", "找不到源文件： {0}" }, { "source line number and line", "{0,number,integer}    {1}" }, { "source line number current line and line", "{0,number,integer} => {1}" }, { "sourcedebugextension", "SourceDebugExtension- {0}" }, { "Specify class and method", "指定类和方法" }, { "Specify classes to redefine", "指定要重新定义的类" }, { "Specify file name for class", "指定类 {0} 的文件名" }, { "stack frame dump with pc", "  [{0,number,integer}] {1}.{2} ({3}), pc = {4}" }, { "stack frame dump", "  [{0,number,integer}] {1}.{2} ({3})" }, { "Step completed:", "已完成步骤： " }, { "Stopping due to deferred breakpoint errors.", "由于延迟的断点错误而停止。\n" }, { "subclass:", "子类： {0}" }, { "subinterface:", "子接口： {0}" }, { "tab", "\t{0}" }, { "Target VM failed to initialize.", "目标 VM 无法初始化。" }, { "The application exited", "应用程序已退出" }, { "The application has been disconnected", "已断开应用程序的连接" }, { "The gc command is no longer necessary.", "不再需要 'gc' 命令。\n" + "如平常一样对所有对象进行垃圾收集。使用 'enablegc' 和 'disablegc' \n" + "命令来控制各个对象的垃圾收集。" }, { "The load command is no longer supported.", "不再支持 \"load\" 命令。" }, { "The memory command is no longer supported.", "不再支持 \"memory\" 命令。" }, { "The VM does not use paths", "VM 不使用路径" }, { "Thread is not running (no stack).", "线程未运行（无堆栈）。" }, { "Thread number not specified.", "未指定线程号。" }, { "Thread:", "{0}:" }, { "Thread Group:", "组 {0}：" }, { "Thread description name unknownStatus BP", "  {0} {1} 未知（在断点处）" }, { "Thread description name unknownStatus", "  {0} {1} 未知" }, { "Thread description name zombieStatus BP", "  {0} {1} 处于僵状态（在断点处）" }, { "Thread description name zombieStatus", "  {0} {1} 处于僵状态" }, { "Thread description name runningStatus BP", "  {0} {1} 正在运行（在断点处）" }, { "Thread description name runningStatus", "  {0} {1} 正在运行" }, { "Thread description name sleepingStatus BP", "  {0} {1} 正在休眠（在断点处）" }, { "Thread description name sleepingStatus", "  {0} {1} 正在休眠" }, { "Thread description name waitingStatus BP", "  {0} {1} 正在监视器中等待（在断点处）" }, { "Thread description name waitingStatus", "  {0} {1} 正在监视器中等待" }, { "Thread description name condWaitstatus BP", "  {0} {1} 条件正在等待（在断点处）" }, { "Thread description name condWaitstatus", "  {0} {1} 条件正在等待" }, { "Thread has been resumed", "线程已恢复" }, { "Thread not suspended", "线程未暂停" }, { "thread group number description name", "{0,number,integer}。 {1} {2}" }, { "Threadgroup name not specified.", "未指定线程组名称。" }, { "Threads must be suspended", "必须暂停线程" }, { "trace method exit in effect for", "对 {0} 有效跟踪方法退出" }, { "trace method exits in effect", "有效跟踪方法退出" }, { "trace methods in effect", "有效跟踪方法" }, { "trace go method exit in effect for", "对 {0} 有效跟踪 go 方法退出" }, { "trace go method exits in effect", "有效跟踪 go 方法退出" }, { "trace go methods in effect", "有效跟踪 go 方法" }, { "trace not in effect", "无效跟踪" }, { "Unable to attach to target VM.", "无法连接到目标 VM。" }, { "Unable to display process output:", "无法显示进程输出： {0}" }, { "Unable to launch target VM.", "无法启动目标 VM。" }, { "Unable to set deferred", "无法设置延迟的 {0}： {1}" }, { "Unable to set main class and arguments", "无法设置主类和参数" }, { "Unable to set", "无法设置 {0}： {1}" }, { "Unexpected event type", "意外的事件类型: {0}" }, { "unknown", "未知" }, { "Unmonitoring", "未监视 {0} " }, { "Unrecognized command.  Try help...", "无法识别的命令： \"{0}\" 。  请尝试使用 help..." }, { "Usage: catch exception", "用法：catch [uncaught|caught|all] <类 ID>|<类模式>" }, { "Usage: ignore exception", "用法：ignore [uncaught|caught|all] <类 ID>|<类模式>" }, { "Usage: down [n frames]", "用法：down [n 帧]" }, { "Usage: kill <thread id> <throwable>", "用法：kill <线程ID> <throwable>" }, { "Usage: read <command-filename>", "用法：read <命令文件名>" }, { "Usage: unmonitor <monitor#>", "用法：unmonitor <监视器号>" }, { "Usage: up [n frames]", "用法：up [n 帧]" }, { "Use java minus X to see", "使用 \"java -X\" 可以查看可用的非标准选项" }, { "Use stop at to set a breakpoint at a line number", "使用 \"stop at\" 可以在某个行号处设置断点" }, { "VM already running. use cont to continue after events.", "VM 已运行。使用 \"cont\" 可以在事件后继续。" }, { "VM Started:", "VM 已启动： " }, { "vmstartexception", "VM 启动异常： {0}" }, { "Waiting for monitor:", "   正在等待监视器： {0}" }, { "Waiting thread:", " 正在等待线程： {0}" }, { "watch accesses of", "监视 {0}.{1} 的访问" }, { "watch modification of", "监视 {0}.{1} 的修改" }, { "zz help text", "** 命令列表 **\n" + "connectors                -- 列出此 VM 中可用的连接器和传输器\n" + "\n" + "run [类 [参数]]        -- 开始执行应用程序的主类\n" + "\n" + "threads [线程组]     -- 列出线程\n" + "thread <线程 ID>        -- 设置默认线程\n" + "suspend [线程 ID]    -- 暂停线程（默认值为 all）\n" + "resume [线程 ID]     -- 恢复线程（默认值为 all）\n" + "where [<线程 ID> | all] -- 转储线程的堆栈\n" + "wherei [<线程 ID> | all] -- 转储线程的堆栈以及 pc 信息\n" + "up [n 帧]             -- 向上移动线程的堆栈\n" + "down [n 帧]           -- 向下移动线程的堆栈\n" + "kill <线程 ID> <表达式>   -- 中止具有给定的异常对象的线程\n" + "interrupt <线程 ID>     -- 中断线程\n" + "\n" + "print <表达式>              -- 输出表达式的值\n" + "dump <表达式>               -- 输出所有对象信息\n" + "eval <表达式>               -- 计算表达式的值（与 print 作用相同）\n" + "set <lvalue> = <表达式>     -- 为字段/变量/数组元素指定新值\n" + "locals                    -- 输出当前堆栈帧中的所有本地变量\n" + "\n" + "classes                   -- 列出当前已知的类\n" + "class <类 ID>          -- 显示已命名类的详细信息\n" + "methods <类 ID>        -- 列出类的方法\n" + "fields <类 ID>         -- 列出类的字段\n" + "\n" + "threadgroups              -- 列出线程组\n" + "threadgroup <名称>        -- 设置当前线程组\n" + "\n" + "stop in <类 ID>.<方法>[(参数类型,...)]\n" + "                          -- 在方法中设置断点\n" + "stop at <类 ID>:<行> -- 在行中设置断点\n" + "clear <类 ID>.<方法>[(参数类型,...)]\n" + "                          -- 清除方法中的断点\n" + "clear <类 ID>:<行>   -- 清除行中的断点\n" + "clear                     -- 列出断点\n" + "catch [uncaught|caught|all] <类 ID>|<类模式>\n" + "                          -- 出现指定的异常时中断\n" + "ignore [uncaught|caught|all] <类 ID>|<类模式>\n" + "                          -- 对于指定的异常，取消 'catch'\n" + "watch [access|all] <类 ID>.<字段名>\n" + "                          -- 监视对字段的访问/修改\n" + "unwatch [access|all] <类 ID>.<字段名>\n" + "                          -- 停止监视对字段的访问/修改\n" + "trace [go] methods [thread]\n" + "                          -- 跟踪方法的进入和退出。\n" + "                          -- 除非指定 'go'，否则所有线程都将暂停\n" + "trace [go] method exit | exits [thread]\n" + "                          -- 跟踪当前方法的退出或所有方法的退出\n" + "                          -- 除非指定 'go'，否则所有线程都将暂停\n" + "untrace [方法]         -- 停止跟踪方法的进入和/或退出\n" + "step                      -- 执行当前行\n" + "step up                   -- 执行到当前方法返回其调用方\n" + "stepi                     -- 执行当前指令\n" + "next                      -- 跳过一行（跨过调用）\n" + "cont                      -- 从断点处继续执行\n" + "\n" + "list [line number|method] -- 输出源代码\n" + "use（或 sourcepath）[源文件路径]\n" + "                          -- 显示或更改源路径\n" + "exclude [<类模式>, ...|“无”]\n" + "                          -- 不报告指定类的步骤或方法事件\n" + "classpath                 -- 从目标 VM 输出类路径信息\n" + "\n" + "monitor <命令>         -- 每次程序停止时执行命令\n" + "monitor                   -- 列出监视器\n" + "unmonitor <监视器号>      -- 删除某个监视器\n" + "read <文件名>           -- 读取并执行某个命令文件\n" + "\n" + "lock <表达式>               -- 输出对象的锁信息\n" + "threadlocks [线程 ID]   -- 输出线程的锁信息\n" + "\n" + "pop                       -- 弹出整个堆栈，且包含当前帧\n" + "reenter                   -- 与 pop 作用相同，但重新进入当前帧\n" + "redefine <类 ID> <类文件名>\n" + "                          -- 重新定义类代码\n" + "\n" + "disablegc <表达式>          -- 禁止对象的垃圾回收\n" + "enablegc <表达式>           -- 允许对象的垃圾回收\n" + "\n" + "!!                        -- 重复执行最后一个命令\n" + "<n> <命令>             -- 将命令重复执行 n 次\n" + "# <命令>               -- 放弃（不执行）\n" + "help（或 ?）               -- 列出命令\n" + "version                   -- 输出版本信息\n" + "exit（或 quit）            -- 退出调试器\n" + "\n" + "<类 ID>: 带有软件包限定符的完整类名\n" + "<类模式>: 带有前导或后缀通配符 (*) 的类名\n" + "<线程 ID>: 'threads' 命令中所报告的线程号\n" + "<表达式>: Java(TM) 编程语言表达式。\n" + "支持大多数常见语法。\n" + "\n" + "可以将启动命令置于 \"jdb.ini\" 或 \".jdbrc\" 之中\n" + "（两者位于 user.home 或 user.dir 中）" }, { "zz usage text", "用法:{0} <选项> <类> <参数>\n" + "\n" + "其中选项包括:\n" + "    -help             输出此消息并退出\n" + "    -sourcepath <以 \"{1}\" 分隔的目录>\n" + "                      在其中查找源文件的目录\n" + "    -attach <地址>\n" + "                      使用标准连接器连接到正在指定地址运行的 VM\n" + "    -listen <地址>\n" + "                      等待正在指定地址运行的 VM 使用标准连接器进行连接\n" + "    -listenany\n" + "                      等待正在任意可用地址运行的 VM 使用标准连接器进行连接\n" + "    -launch\n" + "                      立即启动 VM，而不等待 ''run'' 命令\n" + "    -listconnectors   列出此 VM 中可用的连接器\n" + "    -connect <连接器名称>:<名称 1>=<值 1>,...\n" + "                      使用命名的连接器和列出的参数值连接到目标 VM\n" + "    -dbgtrace [标志] 输出用于调试 {0} 的信息\n" + "    -tclient          在 Hotspot(TM) Performance Engine（客户机）中运行应用程序\n" + "    -tserver          在 Hotspot(TM) Performance Engine（服务器）中运行应用程序\n" + "\n" + "转发给被调试进程的选项:\n" + "    -v -verbose[:class|gc|jni]\n" + "                      启用详细模式\n" + "    -D<名称>=<值>  设置系统属性\n" + "    -classpath <以 \"{1}\" 分隔的目录>\n" + "                      列出要在其中查找类的目录\n" + "    -X<选项>        非标准目标 VM 选项\n" + "\n" + "<类> 是要开始调试的类的名称\n" + "<参数> 是传递给 <类> 的 main() 方法的参数\n" + "\n" + "要获得命令帮助，请在 {0} 提示符下键入 ''help''" } };
    }
}
