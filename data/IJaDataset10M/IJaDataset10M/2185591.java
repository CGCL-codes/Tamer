package supersync.sync.prefs;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.jdesktop.application.ResourceMap;
import org.jdom.Document;
import org.jdom.Element;
import supersync.file.AbstractFile;
import supersync.file.filesystems.historical.SyncFile;
import supersync.sync.FileFilter;
import supersync.sync.prefs.server.Server;

/** Saves settings related to the sync operation.
 *
 * @author Brandon Drake
 */
public class SyncSettings {

    protected static final ResourceMap RESMAP = org.jdesktop.application.Application.getInstance(supersync.SynchronizerApp.class).getContext().getResourceMap(SyncSettings.class);

    protected boolean allow1HourDifference = false;

    protected int allowedTimeDifference = 59;

    protected ArrayList<FileFilter> fileFilters = new ArrayList<FileFilter>();

    protected boolean firstSyncRun = false;

    protected FolderSettings folder1 = null;

    protected Date folder1Date = null;

    protected AbstractFile folder1File = null;

    protected AbstractFile folder1TrashFolder = null;

    protected FolderSettings folder2 = null;

    protected Date folder2Date = null;

    protected AbstractFile folder2File = null;

    protected AbstractFile folder2TrashFolder = null;

    protected GlobalPreferences globalPreferences = new GlobalPreferences();

    protected boolean moveDeletedItemsToTrashFolder = false;

    protected int multipleOperationsCount = 1;

    protected RetrySettings retrySettings = new RetrySettings();

    protected ScheduleOptions scheduleOptions = null;

    protected File syncFile = null;

    protected SystemSetup system1Setup = null;

    protected SystemSetup system2Setup = null;

    public static final String TRASH_FOLDER_NAME = "Trash";

    /** Adds a file filter to the list of file filters.
     */
    public synchronized void addFileFilter(FileFilter l_filter) {
        this.fileFilters.add(l_filter);
    }

    /** Gets a sync settings instance from the saved sync settings in the specified file.
     */
    public static SyncSettings fromFile(File l_file, GlobalPreferences l_globalPreferences) throws IOException, java.text.ParseException {
        org.jdom.input.SAXBuilder builder = new org.jdom.input.SAXBuilder();
        Document doc = null;
        try {
            doc = builder.build(l_file);
        } catch (org.jdom.JDOMException ex) {
            throw new IOException(RESMAP.getString("message.couldNotLoadPreferences.text"));
        }
        return fromXML(doc, l_globalPreferences, l_file);
    }

    /** Gets the sync settings from the xml document generated by the toXML function.
     */
    public static SyncSettings fromXML(org.jdom.Document l_document, GlobalPreferences l_globalPreferences, File l_syncFile) throws java.text.ParseException {
        SyncSettings result = new SyncSettings();
        org.jdom.Element rootElt = l_document.getRootElement();
        if (null == rootElt.getChild("System1Setup") || null == rootElt.getChild("System2Setup") || null == rootElt.getChild("Retry") || null == rootElt.getChild("FileFilters") || null == rootElt.getChild("Folder1") || null == rootElt.getChild("Folder2")) {
            throw new ParseException(RESMAP.getString("message.syncFileCorrupt.text"), 0);
        }
        result.allow1HourDifference = rootElt.getAttributeValue("Allow1HourDifference", "N").equals("Y");
        result.allowedTimeDifference = Integer.valueOf(rootElt.getAttributeValue("AllowedTimeDifference", "59"));
        result.globalPreferences = l_globalPreferences;
        result.syncFile = l_syncFile;
        result.moveDeletedItemsToTrashFolder = rootElt.getAttributeValue("MoveDeletedItemsToTrashFolder", "N").equals("Y");
        result.multipleOperationsCount = Integer.valueOf(rootElt.getAttributeValue("MultipleOperationsCount", "1"));
        result.firstSyncRun = rootElt.getAttributeValue("FirstSyncRun", "N").equals("Y");
        result.retrySettings = RetrySettings.fromXML(rootElt.getChild("Retry"));
        Element currentElt = rootElt.getChild("FileFilters");
        List<Element> allElts = currentElt.getChildren("FileFilter");
        for (Element fileFilterElt : allElts) {
            result.fileFilters.add(FileFilter.fromXML(fileFilterElt));
        }
        currentElt = rootElt.getChild("Folder1");
        result.folder1 = FolderSettings.fromXML(currentElt);
        currentElt = rootElt.getChild("Folder2");
        result.folder2 = FolderSettings.fromXML(currentElt);
        result.setSystem1Setup(SystemSetup.fromXML(rootElt.getChild("System1Setup"), result.folder1.location));
        result.setSystem2Setup(SystemSetup.fromXML(rootElt.getChild("System2Setup"), result.folder2.location));
        return result;
    }

    /** Gets whether or not to allow a 1 hour difference between files in addition to the other allowed time difference.
     *
     * For example if this is on and the allowed time difference is 59 seconds, allowed time differences might be 20 seconds, an hour and 20 seconds, but not 30 minutes or 1 hour and 30 minutes.
     */
    public boolean getAllow1HourDifference() {
        return allow1HourDifference;
    }

    /** Gets the amount of time difference between two files (in seconds), in which the two files will still be considered the same.
     */
    public int getAllowedTimeDifference() {
        return allowedTimeDifference;
    }

    /** Gets a basic instance of the sync settings with properties set to the programmed default values.
     */
    public static SyncSettings getBasicInstance() {
        SyncSettings result = new SyncSettings();
        result.folder1 = new FolderSettings();
        result.folder2 = new FolderSettings();
        result.retrySettings = new RetrySettings();
        result.setSystem1Setup(new SystemSetup());
        result.setSystem2Setup(new SystemSetup());
        return result;
    }

    /** Gets the default settings from the default settings file.
     */
    public static SyncSettings getDefaultSettings(GlobalPreferences l_globalPreferences) throws IOException {
        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(supersync.SynchronizerApp.class).getContext().getResourceMap(SyncSettings.class);
        String resourcesPath = resourceMap.getResourcesDir();
        File tempSettingsFile = null;
        try {
            InputStream inStream = resourceMap.getClassLoader().getResourceAsStream(resourcesPath + "DefaultSyncSettings.xml");
            if (null != inStream) {
                tempSettingsFile = File.createTempFile("TempSettings", ".xml");
                OutputStream outStream = new FileOutputStream(tempSettingsFile);
                AbstractFile.copyStream(inStream, outStream);
            }
        } catch (IOException ex) {
            return getBasicInstance();
        }
        if (null == tempSettingsFile || false == tempSettingsFile.exists()) {
            return getBasicInstance();
        }
        try {
            SyncSettings syncSettings = SyncSettings.fromFile(tempSettingsFile, l_globalPreferences);
            syncSettings.folder1 = new FolderSettings();
            syncSettings.folder2 = new FolderSettings();
            return syncSettings;
        } catch (ParseException ex) {
            throw new IOException(RESMAP.getString("message.defaultFileCorrupt.text"));
        }
    }

    /** Gets the list of file filters.
     */
    public synchronized ArrayList<FileFilter> getFileFilters() {
        return this.fileFilters;
    }

    /** Gets whether or not the first sync has been run.
     */
    public final synchronized boolean getFirstSyncRun() {
        return this.firstSyncRun;
    }

    /** Gets the folder 1 settings.
     */
    public final synchronized FolderSettings getFolder1() {
        return this.folder1;
    }

    /** Gets the sync date to use if folder 1 is a historical file system.  This setting is not saved, but can be set at run time.
     */
    public Date getFolder1Date() {
        return folder1Date;
    }

    /** Gets the folder 1 file.
     */
    public final synchronized AbstractFile getFolder1File() {
        if (null == folder1File) {
            Server server = this.globalPreferences.getServer(this.folder1.serverName);
            supersync.file.filesystems.FileSystemServer fileSystemServer = supersync.file.filesystems.FileSystemServer.getInstance(this.folder1.getType());
            supersync.file.AbstractFileSystem fileSystem = fileSystemServer.getFileSystem(server, this.getSystem1Setup());
            if (fileSystem.isRelativePath(this.folder1.location)) {
                folder1File = fileSystem.getFile(this.folder1.location, this.syncFile.getParent());
            } else {
                folder1File = fileSystem.getFile(this.folder1.location);
            }
        }
        if (folder1File instanceof SyncFile) {
            folder1File = ((SyncFile) folder1File).getHistoricalVersion(this.folder1Date);
        }
        return folder1File;
    }

    /** Gets the folder 1 trash folder.
     */
    public synchronized AbstractFile getFolder1Trash() throws IOException {
        if (null == folder1TrashFolder) {
            AbstractFile folder = this.getFolder1File();
            folder1TrashFolder = supersync.sync.Synchronizer.getSyncFolder(folder).child(TRASH_FOLDER_NAME);
        }
        return folder1TrashFolder;
    }

    /** Gets the folder 2 settings.
     */
    public final synchronized FolderSettings getFolder2() {
        return this.folder2;
    }

    /** Gets the sync date to use if folder 2 is a historical file system.  This setting is not saved, but can be set at run time.
     */
    public Date getFolder2Date() {
        return folder2Date;
    }

    /** Gets the folder 2 file.
     */
    public final synchronized AbstractFile getFolder2File() {
        if (null == folder2File) {
            Server server = this.globalPreferences.getServer(this.folder2.serverName);
            supersync.file.filesystems.FileSystemServer fileSystemServer = supersync.file.filesystems.FileSystemServer.getInstance(this.folder2.getType());
            supersync.file.AbstractFileSystem fileSystem = fileSystemServer.getFileSystem(server, this.getSystem2Setup());
            if (fileSystem.isRelativePath(this.folder2.location)) {
                folder2File = fileSystem.getFile(this.folder2.location, this.syncFile.getParent());
            } else {
                folder2File = fileSystem.getFile(this.folder2.location);
            }
        }
        if (folder2File instanceof SyncFile) {
            folder2File = ((SyncFile) folder2File).getHistoricalVersion(this.folder2Date);
        }
        return folder2File;
    }

    /** Gets the folder 2 trash folder.
     */
    public synchronized AbstractFile getFolder2Trash() throws IOException {
        if (null == folder2TrashFolder) {
            AbstractFile folder = this.getFolder2File();
            folder2TrashFolder = supersync.sync.Synchronizer.getSyncFolder(folder).child(TRASH_FOLDER_NAME);
        }
        return folder2TrashFolder;
    }

    /** Gets the global preferences currently attached to this instance.
     */
    public synchronized GlobalPreferences getGlobalPreferences() {
        return this.globalPreferences;
    }

    /** Gets whether or not deleted items should be moved to the trash folder.
     */
    public synchronized boolean getMoveDeletedItemsToTrashFolder() {
        return this.moveDeletedItemsToTrashFolder;
    }

    /** Gets the number of multiple operations allowed.
     */
    public synchronized int getMultipleOperationsCount() {
        return this.multipleOperationsCount;
    }

    /** Gets the retry settings.
     */
    public synchronized RetrySettings getRetrySettings() {
        return this.retrySettings;
    }

    /** Gets the scheduling options.
     */
    public ScheduleOptions getScheduleOptions() {
        return scheduleOptions;
    }

    /** Gets the file that these sync settings were opened from or saved to.
     */
    public synchronized File getSyncFile() {
        return this.syncFile;
    }

    /** Gets the system 1 setup.
     */
    public final synchronized SystemSetup getSystem1Setup() {
        return this.system1Setup;
    }

    /** Gets the system 1 setup.
     */
    public final synchronized SystemSetup getSystem2Setup() {
        return this.system2Setup;
    }

    /** Saves the global preferences to the default file.
     */
    public synchronized void save() throws IOException {
        org.jdom.Document document = this.toXML();
        FileOutputStream outputStream = new FileOutputStream(this.syncFile);
        org.jdom.output.XMLOutputter outputer = new org.jdom.output.XMLOutputter();
        outputer.output(document, outputStream);
        outputStream.close();
    }

    /** Saves the sync settings to the specified file.  Does not change the location where the save() function will save to.
     */
    public synchronized void saveTo(AbstractFile l_file) throws IOException {
        org.jdom.Document document = this.toXML();
        OutputStream outputStream = l_file.getOutputStream();
        org.jdom.output.XMLOutputter outputer = new org.jdom.output.XMLOutputter();
        outputer.output(document, outputStream);
        outputStream.close();
    }

    /** Sets whether or not to allow a 1 hour difference between files in addition to the other allowed time difference.
     */
    public void setAllow1HourDifference(boolean l_value) {
        this.allow1HourDifference = l_value;
    }

    /** Sets the amount of time difference between two files (in seconds), in which the two files will still be considered the same.
     */
    public void setAllowedTimeDifference(int l_value) {
        this.allowedTimeDifference = l_value;
    }

    /** Sets the list of file filters.
     */
    public synchronized void setFileFilters(ArrayList<FileFilter> l_value) {
        this.fileFilters = l_value;
    }

    /** Sets whether or not the first sync has been run.
     */
    public synchronized void setFirstSyncRun(boolean l_value) {
        this.firstSyncRun = l_value;
    }

    /** Sets the folder 1 settings.
     */
    public synchronized void setFolder1(FolderSettings l_value) {
        this.folder1File = null;
        this.folder1TrashFolder = null;
        this.folder1 = l_value;
        if (null != this.system1Setup) {
            this.system1Setup.setRelativePathBase(this.folder1.location);
        }
    }

    /** Sets the sync date to use if folder 1 is a historical file system.  This setting is not saved, but can be set at run time.
     */
    public void setFolder1Date(Date l_value) {
        this.folder1Date = l_value;
    }

    /** Sets the folder 2 settings.
     */
    public synchronized void setFolder2(FolderSettings l_value) {
        this.folder2File = null;
        this.folder2TrashFolder = null;
        this.folder2 = l_value;
        if (null != this.system2Setup) {
            this.system2Setup.setRelativePathBase(this.folder2.location);
        }
    }

    /** Sets the sync date to use if folder 2 is a historical file system.  This setting is not saved, but can be set at run time.
     */
    public void setFolder2Date(Date l_value) {
        this.folder2Date = l_value;
    }

    /** Sets the global preferences currently attached to this instance.
     */
    public synchronized void setGlobalSettings(GlobalPreferences l_value) {
        this.globalPreferences = l_value;
    }

    /** Gets whether or not deleted items should be moved to the trash folder.
     */
    public synchronized void setMoveDeletedItemsToTrashFolder(boolean l_value) {
        this.moveDeletedItemsToTrashFolder = l_value;
    }

    /** Gets the number of multiple operations allowed.
     */
    public synchronized void setMultipleOperationsCount(int l_value) {
        this.multipleOperationsCount = l_value;
    }

    /** Gets the retry settings.
     */
    public synchronized void setRetrySettings(RetrySettings l_value) {
        this.retrySettings = l_value;
    }

    /** Gets the scheduling options.
     */
    public void setScheduleOptions(ScheduleOptions scheduleOptions) {
        this.scheduleOptions = scheduleOptions;
    }

    /** Sets the file that these sync settings were opened from or saved to.
     */
    public synchronized void setSyncFile(File l_value) {
        this.syncFile = l_value;
    }

    /** Sets the system 2 setup.
     */
    public synchronized void setSystem2Setup(SystemSetup l_value) {
        this.system2Setup = l_value;
        this.system2Setup.name = "Right System";
        if (null != this.folder2) {
            this.system2Setup.setRelativePathBase(this.folder2.location);
        }
    }

    /** Sets the system 1 setup.
     */
    public synchronized void setSystem1Setup(SystemSetup l_value) {
        this.system1Setup = l_value;
        this.system1Setup.name = "Left System";
        if (null != this.folder1) {
            this.system1Setup.setRelativePathBase(this.folder1.location);
        }
    }

    /** Converts the sync settings to XML.
     */
    public synchronized org.jdom.Document toXML() {
        Element rootElt = new org.jdom.Element("SyncSettings");
        if (this.allow1HourDifference) {
            rootElt.setAttribute("Allow1HourDifference", "Y");
        }
        rootElt.setAttribute("AllowedTimeDifference", String.valueOf(this.allowedTimeDifference));
        rootElt.setAttribute("MultipleOperationsCount", String.valueOf(this.multipleOperationsCount));
        if (this.moveDeletedItemsToTrashFolder) {
            rootElt.setAttribute("MoveDeletedItemsToTrashFolder", "Y");
        }
        if (this.firstSyncRun) {
            rootElt.setAttribute("FirstSyncRun", "Y");
        }
        Element elt = this.system1Setup.toXML();
        elt.setName("System1Setup");
        rootElt.addContent(elt);
        elt = this.system2Setup.toXML();
        elt.setName("System2Setup");
        rootElt.addContent(elt);
        rootElt.addContent(this.retrySettings.toXML());
        Element fileFiltersElt = new Element("FileFilters");
        for (FileFilter fileFilter : this.fileFilters) {
            fileFiltersElt.addContent(fileFilter.toXML());
        }
        rootElt.addContent(fileFiltersElt);
        rootElt.addContent(this.folder1.toXML(1));
        rootElt.addContent(this.folder2.toXML(2));
        org.jdom.Document result = new org.jdom.Document();
        result.setRootElement(rootElt);
        return result;
    }
}
