package org.jato;

import java.io.PrintStream;
import java.io.Serializable;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Properties;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.JDOMFactory;
import org.jato.debug.Debugger;

/**
 * The Jato interpreter.  The Jato interpreter executes a Jato script
 * and transforms input XML document and Java objects (obtained from
 * an application-provided {@link org.jato.JatoIntegrator integrator}
 * object) into output XML document and Java objects (published to
 * the same integrator object).
 * <p>
 * Although Jato aims at performing XML transformations with Java
 * interactions, all inputs and outputs are optional.  That is Jato
 * can be used to generate XML from Java objects (no XML input or
 * Java output) or to instanciate Java object from an XML document
 * (no XML ouptut or input Java objects).</p>
 * <p>
 * An interpreter may perform a single transformation at one
 * time.  If an application needs to run multiple concurrent
 * transformations based on the same script, each thread will
 * require its own interpreter instance, all instances sharing
 * the same compiled script object.</p>
 * <p>
 * Interpreters are typically allocated from compiled Jato script
 * and used as follows:
 * <blockquote><pre>
 *   Interpreter jato = new Interpreter(aScript);
 *   ...
 *   jato.setJatoIntegrator(myIntegrator);
 *   ...
 *   jato.transform(inRootElt, outRootElt);
 * </pre></blockquote></p>
 *
 * @see    org.jato.JatoScript
 * @see    org.jato.JatoIntegrator
 *
 * @author Andy Krumel
 */
public class Interpreter implements Serializable {

    /**
    * The interface point between the Java application and this
    * interpreter.
    */
    private transient JatoIntegrator fIntegrator;

    /**
    * The script to be executed by the interpreter.
    */
    private final JatoScript fScript;

    /**
    * List of documents generated by script during execution
    */
    private transient List fDocList = new ArrayList();

    /**
    * The script variables.
    */
    private transient Map fVariables = new HashMap();

    /**
    * Stream to which all debug information is to be written.
    */
    private transient PrintStream fDebugStream = System.out;

    /**
    * Flag specifies if debug output should be generated.
    */
    private boolean fDebugOutputEnabled = true;

    /**
    * The debug session attached to this tag.
    */
    private transient Debugger fDebugger;

    /**
    * The JDOM factory to use when allocating XML nodes.
    */
    private transient JDOMFactory fJdomFactory;

    /**
    * Creates an interpreter with no integration object.
    * <p>
    * The integration object could be later specified by invoking the
    * {@link #setJatoIntegrator} method.</p>
    *
    * @param  script   The Jato script this interpreter is to run.
    */
    public Interpreter(JatoScript script) {
        fScript = script;
        setJdomFactory(script.getJdomFactory());
    }

    /**
    * Creates an interpreter, specifiying the integration object.
    *
    * @param  script       The Jato script this interpreter is to run.
    * @param  integrator   The object to interface with the Java
    *                      application
    */
    public Interpreter(JatoScript script, JatoIntegrator integrator) {
        fScript = script;
        fIntegrator = integrator;
        setJdomFactory(script.getJdomFactory());
    }

    /**
    * Gets the script this interpreter is to execute.
    *
    * @return the script this interpreter is to execute.
    */
    public JatoScript getJatoScript() {
        return fScript;
    }

    /**
    * Sets or changes the integration object that interfaces the
    * Java application with this interpreter.
    * <p>
    * <strong>Note</strong>: In order not to force all
    * implementations of the JatoIntegrator interface to be
    * serializable, the integration object is <strong>NOT</strong>
    * saved when serializing Jato interpreter objects.</p>
    *
    * @param  integrator   The object to interface with the Java
    *                      application.
    */
    public void setJatoIntegrator(JatoIntegrator i) {
        fIntegrator = i;
    }

    /**
    * Gets the integration object that interfaces the Java
    * application with this interpreter.
    *
    * @return The object to interface with the Java application.
    */
    public JatoIntegrator getJatoIntegrator() {
        return fIntegrator;
    }

    /**
    * Sets or changes the JDOM factory object used for creating
    * XML nodes.
    * <p>
    * <strong>Note</strong>: In order not to force all
    * implementations of the JDOMFactory interface to be
    * serializable, the factory object is <strong>NOT</strong>
    * saved when serializing Jato interpreter objects.  Upon
    * deserialization, the default JDOM factory is automatically
    * reinstalled.</p>
    *
    * @param  factory   The JDOM factory object to use.  if
    *                   <code>null</code>, the factory defined for
    *                   the Jato script will be used.
    */
    public void setJdomFactory(JDOMFactory factory) {
        fJdomFactory = (factory != null) ? factory : this.getJatoScript().getJdomFactory();
    }

    /**
    * Returns the JDOM factory object used for creating
    * XML nodes.
    *
    * @return The JDOM factory object currently in use.
    */
    public JDOMFactory getJdomFactory() {
        return fJdomFactory;
    }

    /**
    * Gets the value of a script variable.
    *
    * @param  name   The variable name.
    *
    * @return The variable value or <code>null</code> if the
    *         variable has not been defined.
    *
    * @see #setVariable
    */
    public Object getVariable(String name) {
        return fVariables.get(name);
    }

    /**
    * Sets or replaces a script variable.
    * <p>
    * <strong>Note</strong>: In order not to force all variables
    * values to be serializable, scripts variables are
    * <strong>NOT</strong> saved when serializing Jato interpreter
    * objects.</p>
    *
    * @param  name   The variable name.
    * @param  val    The new variable value.
    *
    * @see #getVariable
    */
    public void setVariable(String name, Object val) {
        fVariables.put(name, val);
    }

    /**
    * Clears the list of script variables maintained by this
    * interpreter.
    * <p>
    * This method is useful when reusing an interpreter instance
    * to reset the script variables before running a new
    * transformation.</p>
    */
    public void clearVariables() {
        fVariables.clear();
    }

    /**
    * Instructs the interpreter to execute the Jato script.
    * <p>
    * An interpreter may perform a single transformation at one
    * time.  If an application needs to run multiple concurrent
    * transformations based on the same script, each thread will
    * require its own interpreter instance, all instances sharing
    * the same compiled script object.</p>
    * <p>
    * Please note that the Jato Interpreter object does not control
    * thread accesses.  Hence, it is the application responsiblity
    * to ensure that Interpreters are not shared among threads.</p>
    *
    * @param  xmlIn   The input XML document fragment to process.
    *                 This is usually the document root element.
    * @param  xmlOut  The element on which the script should operate.
    *                 This is usually the output document's root
    *                 element.
    *
    * @return The documents generated by the script.  In most cases,
    *         this will contain at most a single entry, the document
    *         for the output document.  Additional documents will be
    *         added if they are created by the script.  An empty
    *         array is returned if the script does not produce any
    *         output.
    *
    * @throws JatoException   if any error occurred during script
    *                         execution.
    */
    public Document[] transform(Element xmlIn, Element xmlOut) throws JatoException {
        fDocList.clear();
        if (xmlOut != null) {
            fDocList.add(xmlOut.getDocument());
        }
        fScript.transform(this, xmlIn, xmlOut);
        Document docs[] = new Document[fDocList.size()];
        fDocList.toArray(docs);
        return docs;
    }

    /**
    * Appends a document to the list of output documents created by
    * this Interpreter during a run.
    *
    * @param  doc   The document to add to the output document list.
    */
    public void addOutputDocument(Document doc) {
        fDocList.add(doc);
    }

    /**
    * Gets a specific document from the output document list.
    *
    * @param  idx   The index of the requested document in the ouput
    *               document list.
    *
    * @return The document located at the specified index.
    *
    * @throws IndexOutOfBoundsException   if no document exists at
    *                                     the specified index.
    */
    public Document getDocument(int idx) {
        return (Document) fDocList.get(idx);
    }

    /**
    * Executes the specified macro using the passed-in state objects.
    *
    * @param  name        The name of the script macro to execute.
    * @param  thisClass   The class of the current Java object or
    *                     the class on which invoke static methods.
    * @param  thisObj     The current Java object or
    *                     <code>null</code>.
    * @param  xmlIn       The current input XML element.
    * @param  xmlOut      The current output XML element.
    *
    * @throws JatoException   If no macro has been registered with
    *                         the specified name or if the macro
    *                         processing failed.
    */
    public void processMacro(String name, Class thisClass, Object thisObj, Element xmlIn, Element xmlOut) throws JatoException {
        fScript.processMacro(name, this, thisClass, thisObj, xmlIn, xmlOut);
    }

    /**
    * Convenience method to {@link JatoScript#getMacro retrieve} a
    * Jato macro from the underlying compiled script.<br>
    * This method is invoked by Jato tags linking to macros.
    *
    * @param  name   The name of the macro to retrieve.
    *
    * @return The requested macro (as a script fragment) or
    *         <code>null</code> if no macro has been registered with
    *         the specified name.
    */
    public ScriptTag getMacro(String name) {
        return fScript.getMacro(name);
    }

    /**
    * Convenience method to invoke the {@link JatoIntegrator#publish}
    * method on the current JatoIntegrator object.
    *
    * @param  key     The key that identifies the object.
    * @param  obj     The object being published.
    * @param  state   One of {@link JatoIntegrator#CREATED_STATE} or
    *                 {@link JatoIntegrator#INITIALIZED_STATE}.
    *
    * @throws JatoException   If thrown the JatoIntegrator object.
    *
    * @see    JatoIntegrator
    */
    public void publish(String key, Object obj, int state) throws JatoException {
        if (fIntegrator == null) {
            throw new JatoException("No JatoIntegrator registered with the interpreter.");
        }
        fIntegrator.publish(key, obj, state);
    }

    /**
    * Convenience method to invoke the {@link JatoIntegrator#getObject}
    * method on the current JatoIntegrator object.
    *
    * @param  key     The key that identifies the object.
    * @param  parms   The parameters for accessing/creating the object.
    *
    * @return The object associated to <code>key</code>.
    *
    * @throws JatoException   If thrown the JatoIntegrator object.
    *
    * @see    JatoIntegrator
    */
    public Object getObject(String key, Properties parms) throws JatoException {
        if (fIntegrator == null) {
            throw new JatoException("No JatoIntegrator registered with the interpreter.");
        }
        return fIntegrator.getObject(key, parms);
    }

    /**
    * Convenience method to request the underlying Jato script to
    * {@link JatoScript#loadClass(java.lang.String) load} a Java
    * class.
    *
    * @param  clName   The name of the Java class to load.
    *
    * @return The loaded class.
    *
    * @throws JatoException   If the class could not be found.
    *
    * @see    JatoScript
    */
    public Class loadClass(String clName) throws JatoException {
        return fScript.loadClass(clName);
    }

    /**
    * Returns whether debug tags were used to compile script.
    * <p>
    * The {@link org.jato.debug.JatoDebugger Jato Debugger} can only
    * debug scripts with debug tags, i.e. scripts that were compiled
    * in debug mode.  Applications can use this method to determine
    * whether the Jato Debugger can be used with this interpreter or
    * not.</p>
    *
    * @return <code>true</code> if the underlying Jato script is
    *         debug-enabled; <code>false</code> otherwise.
    *
    * @see    org.jato.JatoScript#isDebugEnabled
    */
    public boolean isDebugEnabled() {
        return fScript.isDebugEnabled();
    }

    /**
    * Attaches a debug session to the interpreter.
    * <p>
    * This method is automatically called by the debugger
    * when starting a new debug session.
    *
    * @param  d   The debugger.
    *
    * @throws JatoException   <i>Never</i>.
    */
    public void attachDebugger(Debugger d) throws JatoException {
        fDebugger = d;
    }

    /**
    * Detaches a debug session from the interpreter.
    * <p>
    * This method is automatically called by the debugger
    * when terminating a debug session.
    */
    public void detachDebugger() {
        fDebugger = null;
    }

    /**
    * Returns the debugger currently attached to this interpreter.
    *
    * @return the debugger, if set; <code>null</code> otherwise.
    *
    * @see    #attachDebugger
    * @see    #detachDebugger
    */
    public Debugger getDebugger() {
        return fDebugger;
    }

    /**
    * Returns the output stream where all script debug messages are
    * written.  The default debug stream is <code>System.out</code>.
    *
    * @return The current output stream for script debug messages.
    *
    * @see    #setDebugStream
    */
    public PrintStream getDebugStream() {
        return fDebugStream;
    }

    /**
    * Sets the output stream where all script debug messages should
    * be written.
    *
    * @param  ps   The new output stream for script debug messages.
    *
    * @see    #getDebugStream
    * @see    #setDebugOutputEnabled
    */
    public void setDebugStream(PrintStream ps) {
        fDebugStream = ps;
    }

    /**
    * Returns whether debug output is enabled.
    *
    * @return <code>true</code> if debug output is enabled;
    *         <code>false</code> otherwise.
    *
    * @see #setDebugOutputEnabled
    */
    public boolean isDebugOutputEnabled() {
        return fDebugOutputEnabled;
    }

    /**
    * Sets whether debug output should be genereated.
    *
    * @param  enable   <code>true</code> to enable debug output;
    *                  <code>false</code> to disable it.
    *
    * @see #isDebugOutputEnabled
    * @see #setDebugStream
    */
    public void setDebugOutputEnabled(boolean enable) {
        fDebugOutputEnabled = enable;
    }

    /**
    * <i>[Serialization support]</i> Read the saved object state from
    * the stream and initializes the transient fields.
    *
    * @param  in   the stream to read the object from.
    *
    * @throws IOException              if any I/O error occurred
    *                                  while reading from the stream.
    * @throws ClassNotFoundException   if the class of one of the
    *                                  objects in the serialized
    *                                  graph could not be found.
    */
    private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        fVariables = new HashMap();
        fDocList = new ArrayList();
        setJdomFactory(fScript.getJdomFactory());
    }
}
