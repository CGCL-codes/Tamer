package org.dmd.dmg.util;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.TreeMap;
import org.dmd.dmc.DmcAttribute;
import org.dmd.dmc.DmcObject;
import org.dmd.dmc.types.StringName;
import org.dmd.dms.ActionDefinition;
import org.dmd.dms.AttributeDefinition;
import org.dmd.dms.ClassDefinition;
import org.dmd.dms.DmsDefinition;
import org.dmd.dms.EnumDefinition;
import org.dmd.dms.SchemaDefinition;
import org.dmd.dms.SchemaManager;
import org.dmd.dms.TypeDefinition;
import org.dmd.dms.generated.dmo.MetaDMSAG;
import org.dmd.dms.generated.enums.ClassTypeEnum;
import org.dmd.util.FileUpdateManager;
import org.dmd.util.exceptions.DebugInfo;
import org.dmd.util.formatting.CodeFormatter;

/**
 * The SchemaFormatter dumps a SchemaDefinition as a class so that its definitions
 * can be used without having to read the schema from file.
 */
public class SchemaFormatter {

    static final int BREAKOUT_SIZE = 100;

    String fileHeader;

    PrintStream progress;

    ArrayList<VarToObject> allVars;

    ArrayList<VarToObject> classVars;

    ArrayList<VarToObject> attributeVars;

    ArrayList<VarToObject> typeVars;

    ArrayList<VarToObject> actionVars;

    ArrayList<VarToObject> enumVars;

    SchemaManager schemaManager;

    TreeMap<StringName, String> auxImports;

    TreeMap<String, String> skip;

    public SchemaFormatter() {
        fileHeader = "";
        progress = null;
        allVars = new ArrayList<VarToObject>();
        classVars = new ArrayList<VarToObject>();
        attributeVars = new ArrayList<VarToObject>();
        typeVars = new ArrayList<VarToObject>();
        actionVars = new ArrayList<VarToObject>();
        enumVars = new ArrayList<VarToObject>();
        skip = new TreeMap<String, String>();
        skip.put(DmcObject.__objectClass.name, DmcObject.__objectClass.name);
        skip.put(MetaDMSAG.__derivedClasses.name, MetaDMSAG.__derivedClasses.name);
        skip.put(MetaDMSAG.__dmeClass.name, MetaDMSAG.__dmeClass.name);
        skip.put(MetaDMSAG.__dmeImport.name, MetaDMSAG.__dmeImport.name);
        skip.put(MetaDMSAG.__dmoClass.name, MetaDMSAG.__dmoClass.name);
        skip.put(MetaDMSAG.__dmoImport.name, MetaDMSAG.__dmoImport.name);
        skip.put(MetaDMSAG.__dmtClass.name, MetaDMSAG.__dmtClass.name);
        skip.put(MetaDMSAG.__dmtImport.name, MetaDMSAG.__dmtImport.name);
        skip.put(MetaDMSAG.__dmwClass.name, MetaDMSAG.__dmwClass.name);
        skip.put(MetaDMSAG.__dmwImport.name, MetaDMSAG.__dmwImport.name);
        skip.put(MetaDMSAG.__internalTypeRef.name, MetaDMSAG.__internalTypeRef.name);
        skip.put(MetaDMSAG.__javaClass.name, MetaDMSAG.__javaClass.name);
        skip.put(MetaDMSAG.__nameAttributeDef.name, MetaDMSAG.__nameAttributeDef.name);
    }

    public void setProgressStream(PrintStream ps) {
        progress = ps;
    }

    public void setFileHeader(String fh) {
        fileHeader = fh;
    }

    public void dumpSchema(String genDir, String genPackage, SchemaDefinition schema, SchemaManager sm) throws IOException {
        boolean hasDependency = false;
        auxImports = new TreeMap<StringName, String>();
        if (schema.getDependsOn() != null) hasDependency = true;
        schemaManager = sm;
        String schemaName = GeneratorUtils.dotNameToCamelCase(schema.getName().getNameString()) + "SchemaAG";
        String asagName = GeneratorUtils.dotNameToCamelCase(schema.getName().getNameString()) + "DMSAG";
        BufferedWriter out = FileUpdateManager.instance().getWriter(genDir, schemaName + ".java");
        if (fileHeader != null) out.write(fileHeader);
        out.write("package " + genPackage + ".generated;\n\n");
        String staticRefs = getStaticRefs(schema);
        getInstantiations();
        out.write("import org.dmd.dmc.DmcOmni;\n");
        out.write("import org.dmd.dmc.DmcValueException;\n");
        out.write("import org.dmd.dms.*;\n");
        out.write("import org.dmd.dms.generated.dmo.*;\n");
        out.write("import " + schema.getSchemaPackage() + ".generated.dmo." + asagName + ";\n\n");
        for (StringName key : auxImports.keySet()) {
            out.write("import " + auxImports.get(key) + ";\n");
        }
        out.write("\n");
        out.write("/**\n");
        CodeFormatter.dumpCodeComment(schema.getDescription(), out, " * ");
        out.write(" * <P>\n");
        out.write(" * Generated from the " + schema.getName() + " schema at version " + schema.getVersion() + "\n");
        out.write(" * <P>\n");
        out.write(" * This code was auto-generated by the dmggenerator utility and shouldn't be alterred manually!\n");
        out.write(" * Generated from: " + DebugInfo.getWhereWeAreNow() + "\n");
        out.write(" */\n");
        out.write("public class " + schemaName + " extends SchemaDefinition {\n\n");
        out.write(staticRefs);
        out.write("    static " + schemaName + " instance;\n\n");
        out.write("    public " + schemaName + "() throws DmcValueException {\n");
        out.write("        generatedSchema = true;\n");
        out.write("        staticRefName   = \"" + genPackage + ".generated." + schemaName + "\";\n\n");
        if (hasDependency) {
            Iterator<String> dependsOn = schema.getDependsOn();
            while (dependsOn.hasNext()) {
                String dep = dependsOn.next();
                SchemaDefinition ds = sm.isSchema(dep);
                String sclass = ds.getDmwPackage() + ".generated." + GeneratorUtils.dotNameToCamelCase(dep) + "SchemaAG";
                out.write("        dependsOnSchemaClasses.put(\"" + dep + "\"," + "\"" + sclass + "\");\n");
            }
            out.write("\n");
        }
        out.write("    }\n\n");
        out.write("    private void initialize() throws DmcValueException {\n");
        out.write("        if (instance == null){\n");
        out.write("            instance        = this;\n");
        out.write("            SchemaDefinitionDMO me = (SchemaDefinitionDMO) this.getDmcObject();\n");
        out.write("            me.setName(\"" + schema.getName() + "\");\n");
        out.write("            me.setSchemaPackage(\"" + schema.getSchemaPackage() + "\");\n");
        out.write("            me.setDmwPackage(\"" + schema.getDmwPackage() + "\");\n");
        out.write("            me.setFile(\"" + schema.getFile() + "\");\n\n");
        if (hasDependency) {
            Iterator<String> dependsOn = schema.getDependsOn();
            out.write("\n");
            while (dependsOn.hasNext()) {
                String dep = dependsOn.next();
                out.write("            me.addDependsOn(\"" + dep + "\");\n");
                SchemaDefinition ds = sm.isSchema(dep);
                String sclass = ds.getDmwPackage() + ".generated." + GeneratorUtils.dotNameToCamelCase(dep) + "SchemaAG";
                out.write("            dependsOnSchemaClasses.put(\"" + dep + "\"," + "\"" + sclass + "\");\n\n");
            }
            out.write("\n");
        }
        out.write("            initClasses();\n");
        out.write(getSplitFunctionNames("initAttributes", attributeVars));
        out.write("            initTypes();\n");
        out.write("            initActions();\n");
        out.write("            initEnums();\n");
        out.write("            DmcOmni.instance().addCompactSchema(" + asagName + ".instance());\n");
        out.write("        }\n");
        out.write("    }\n\n");
        dumpInitFunction(out, "initClasses", classVars);
        dumpSplitInitFunctions(out, "initAttributes", attributeVars);
        dumpInitFunction(out, "initTypes", typeVars);
        dumpInitFunction(out, "initActions", actionVars);
        dumpInitFunction(out, "initEnums", enumVars);
        out.write("\n");
        out.write("    @Override\n");
        out.write("    public synchronized " + schemaName + " getInstance() throws DmcValueException{\n");
        out.write("    	   if (instance == null)\n");
        out.write("    		   initialize();\n");
        out.write("    	   return(instance);\n");
        out.write("    }\n");
        out.write("}\n\n");
        out.close();
    }

    /**
	 * Generates the name of a set of functions that will initialize a set of definitions.
	 * @param funcName the base name of the function.
	 * @param vars the definitions
	 * @return a string with funcName1, funcName2, funcName3 etc.
	 */
    String getSplitFunctionNames(String funcName, ArrayList<VarToObject> vars) {
        StringBuffer sb = new StringBuffer();
        int breakout = vars.size() / BREAKOUT_SIZE;
        int remainder = vars.size() % BREAKOUT_SIZE;
        if (remainder > 0) breakout++;
        DebugInfo.debug("*** total: " + vars.size() + "  breakout: " + breakout + "  remainder: " + remainder);
        for (int i = 0, x = 1; i < breakout; i++, x++) {
            sb.append("            " + funcName + x + "();\n");
        }
        DebugInfo.debug("Function names\n\n" + sb.toString());
        return (sb.toString());
    }

    void dumpInitFunction(BufferedWriter out, String funcName, ArrayList<VarToObject> vars) throws IOException {
        out.write("    private void " + funcName + "() throws DmcValueException {\n");
        out.write(getInstantiations(vars));
        out.write("    }\n\n");
    }

    void dumpSplitInitFunctions(BufferedWriter out, String funcName, ArrayList<VarToObject> vars) throws IOException {
        int breakout = vars.size() / BREAKOUT_SIZE;
        int remainder = vars.size() % BREAKOUT_SIZE;
        if (remainder > 0) breakout++;
        for (int i = 0, func = 1; i < breakout; i++, func++) {
            out.write("    private void " + funcName + func + "() throws DmcValueException {\n");
            int start = i * BREAKOUT_SIZE;
            int end = start + BREAKOUT_SIZE;
            if (end > vars.size()) end = vars.size();
            for (int j = start; j < end; j++) {
                out.write(getInstantiation(vars.get(j)));
            }
            out.write("    }\n\n");
        }
    }

    String getInstantiations() {
        StringBuffer sb = new StringBuffer();
        for (VarToObject var : allVars) {
            if (var.name.length() == 0) {
                sb.append("\n");
            } else {
                getObjectAsCode(var, "            ", sb);
                if (var.type.equals("ClassDefinition")) {
                    sb.append("            addClassDefList(" + var.name + ");\n");
                } else if (var.type.equals("AttributeDefinition")) {
                    sb.append("            addAttributeDefList(" + var.name + ");\n");
                } else if (var.type.equals("EnumDefinition")) {
                    sb.append("            addEnumDefList(" + var.name + ");\n");
                } else if (var.type.equals("TypeDefinition")) {
                    sb.append("            addTypeDefList(" + var.name + ");\n");
                } else if (var.type.equals("ActionDefinition")) {
                    sb.append("            addActionDefList(" + var.name + ");\n");
                }
                sb.append("\n");
            }
        }
        return (sb.toString());
    }

    /**
	 * This method takes each VarToObject on the specified array and generates the code to
	 * instantiate the definition, set its attributes and add it to the class, attribute,
	 * enum, type of action list of the schema.
	 * @param vars
	 * @return
	 */
    String getInstantiations(ArrayList<VarToObject> vars) {
        StringBuffer sb = new StringBuffer();
        for (VarToObject var : vars) {
            if (var.name.length() == 0) {
                sb.append("\n");
            } else {
                getObjectAsCode(var, "            ", sb);
                if (var.type.equals("ClassDefinition")) {
                    sb.append("            addClassDefList(" + var.name + ");\n");
                } else if (var.type.equals("AttributeDefinition")) {
                    sb.append("            addAttributeDefList(" + var.name + ");\n");
                } else if (var.type.equals("EnumDefinition")) {
                    sb.append("            addEnumDefList(" + var.name + ");\n");
                } else if (var.type.equals("TypeDefinition")) {
                    sb.append("            addTypeDefList(" + var.name + ");\n");
                } else if (var.type.equals("ActionDefinition")) {
                    sb.append("            addActionDefList(" + var.name + ");\n");
                }
                sb.append("\n");
            }
        }
        return (sb.toString());
    }

    /**
	 * This method generates the code to instantiate the specified definition, set its attributes
	 * and add it to the class, attribute, enum, type of action list of the schema.
	 * @param var
	 * @return
	 */
    String getInstantiation(VarToObject var) {
        StringBuffer sb = new StringBuffer();
        if (var.name.length() == 0) {
            sb.append("\n");
        } else {
            getObjectAsCode(var, "            ", sb);
            if (var.type.equals("ClassDefinition")) {
                sb.append("            addClassDefList(" + var.name + ");\n");
            } else if (var.type.equals("AttributeDefinition")) {
                sb.append("            addAttributeDefList(" + var.name + ");\n");
            } else if (var.type.equals("EnumDefinition")) {
                sb.append("            addEnumDefList(" + var.name + ");\n");
            } else if (var.type.equals("TypeDefinition")) {
                sb.append("            addTypeDefList(" + var.name + ");\n");
            } else if (var.type.equals("ActionDefinition")) {
                sb.append("            addActionDefList(" + var.name + ");\n");
            }
            sb.append("\n");
        }
        return (sb.toString());
    }

    String getStaticRefs(SchemaDefinition schema) {
        StringBuffer sb = new StringBuffer();
        Iterator<ClassDefinition> classes = schema.getClassDefList();
        if (classes != null) {
            while (classes.hasNext()) {
                ClassDefinition cd = classes.next();
                sb.append("    public static ClassDefinition _" + cd.getName() + ";\n");
                allVars.add(new VarToObject("_" + cd.getName(), cd, "ClassDefinition"));
                classVars.add(new VarToObject("_" + cd.getName(), cd, "ClassDefinition"));
            }
            sb.append("\n");
            allVars.add(new VarToObject("", null, null));
        }
        Iterator<AttributeDefinition> attributes = schema.getAttributeDefList();
        if (attributes != null) {
            while (attributes.hasNext()) {
                AttributeDefinition ad = attributes.next();
                sb.append("    public static AttributeDefinition _" + ad.getName() + ";\n");
                allVars.add(new VarToObject("_" + ad.getName(), ad, "AttributeDefinition"));
                attributeVars.add(new VarToObject("_" + ad.getName(), ad, "AttributeDefinition"));
            }
            sb.append("\n");
            allVars.add(new VarToObject("", null, null));
        }
        Iterator<TypeDefinition> types = schema.getTypeDefList();
        if (types != null) {
            while (types.hasNext()) {
                TypeDefinition td = types.next();
                sb.append("    public static TypeDefinition _" + td.getName() + ";\n");
                allVars.add(new VarToObject("_" + td.getName(), td, "TypeDefinition"));
                typeVars.add(new VarToObject("_" + td.getName(), td, "TypeDefinition"));
            }
            sb.append("\n");
            allVars.add(new VarToObject("", null, null));
        }
        Iterator<ActionDefinition> actions = schema.getActionDefList();
        if (actions != null) {
            while (actions.hasNext()) {
                ActionDefinition ad = actions.next();
                sb.append("    public static ActionDefinition _" + ad.getName() + ";\n");
                allVars.add(new VarToObject("_" + ad.getName(), ad, "ActionDefinition"));
                actionVars.add(new VarToObject("_" + ad.getName(), ad, "ActionDefinition"));
            }
            sb.append("\n");
            allVars.add(new VarToObject("", null, null));
        }
        Iterator<EnumDefinition> enums = schema.getEnumDefList();
        if (enums != null) {
            while (enums.hasNext()) {
                EnumDefinition ed = enums.next();
                sb.append("    public static EnumDefinition _" + ed.getName() + ";\n");
                allVars.add(new VarToObject("_" + ed.getName(), ed, "EnumDefinition"));
                enumVars.add(new VarToObject("_" + ed.getName(), ed, "EnumDefinition"));
            }
            sb.append("\n");
            allVars.add(new VarToObject("", null, null));
        }
        return (sb.toString());
    }

    void getObjectAsCode(VarToObject var, String indent, StringBuffer sb) {
        String obj = var.name + "OBJ";
        sb.append(indent + var.type + "DMO " + var.name + "OBJ = new " + var.type + "DMO();\n");
        sb.append(indent + var.name + " = new " + var.type + "(" + var.name + "OBJ);\n");
        for (DmcAttribute<?> attr : var.def.getDmcObject().getAttributes().values()) {
            String an = GeneratorUtils.dotNameToCamelCase(attr.getName());
            if (skip.get(attr.getName()) != null) continue;
            AttributeDefinition ad = schemaManager.isAttribute(attr.getName());
            ClassDefinition aux = isAuxAttribute(var.def, ad);
            if (aux == null) {
                if (attr.getMVSize() > 0) {
                    Iterator vals = attr.getMV();
                    while (vals.hasNext()) {
                        sb.append(indent + obj + ".add" + an + "(\"" + vals.next().toString() + "\");\n");
                    }
                } else {
                    boolean doubleQuotes = false;
                    if (attr.getName().equals("nullReturnValue")) {
                        if (attr.getSV().toString().startsWith("\"")) {
                            doubleQuotes = true;
                        }
                    }
                    if (attr.getName().equals(MetaDMSAG.__definedIn.name)) {
                        sb.append(indent + var.name + ".set" + an + "(this);\n");
                    } else {
                        if (doubleQuotes) sb.append(indent + obj + ".set" + an + "(" + attr.getSV().toString() + ");\n"); else sb.append(indent + obj + ".set" + an + "(\"" + attr.getSV().toString() + "\");\n");
                    }
                }
            } else {
                if (attr.getSV() == null) {
                    Iterator vals = attr.getMV();
                    while (vals.hasNext()) {
                        sb.append(indent + aux.getDmwAuxClass() + ".add" + an + "(" + var.name + ", \"" + vals.next().toString() + "\");\n");
                    }
                } else {
                    boolean doubleQuotes = false;
                    if (attr.getName().equals("nullReturnValue")) {
                        if (attr.getSV().toString().startsWith("\"")) {
                            doubleQuotes = true;
                        }
                    }
                    if (doubleQuotes) sb.append(indent + aux.getDmwAuxClass() + ".set" + an + "(" + var.name + ", " + attr.getSV().toString() + ");\n"); else sb.append(indent + aux.getDmwAuxClass() + ".set" + an + "(" + var.name + ", \"" + attr.getSV().toString() + "\");\n");
                }
            }
        }
    }

    /**
	 * This method determines if the attribute specified is part of the definition class
	 * or if it's an auxiliary attribute.
	 * @param def The definition.
	 * @param ad  The attribute.
	 * @return null if the attribute is standard member of the definition or the AUX class it's part of.
	 */
    ClassDefinition isAuxAttribute(DmsDefinition def, AttributeDefinition ad) {
        ClassDefinition rc = null;
        Iterator<ClassDefinition> oc = def.getObjectClass();
        if (oc == null) {
            DebugInfo.debug("No class info for " + def.getName());
            DebugInfo.debug(def.toOIF(15));
        }
        while (oc.hasNext()) {
            ClassDefinition cd = oc.next();
            if (cd.hasAttribute(ad.getName()) != null) {
                rc = cd;
                break;
            }
        }
        if ((rc != null) && (rc.getClassType() == ClassTypeEnum.AUXILIARY)) {
            auxImports.put(rc.getName(), rc.getDmwAuxClassImport());
        } else {
            rc = null;
        }
        return (rc);
    }

    class VarToObject {

        String name;

        DmsDefinition def;

        String type;

        VarToObject(String vn, DmsDefinition d, String vt) {
            name = vn;
            def = d;
            type = vt;
        }
    }
}
