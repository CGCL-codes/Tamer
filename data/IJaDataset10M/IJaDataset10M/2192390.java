package polimi.multiCommodity;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.HashSet;
import java.util.Iterator;

/**
 * This simple Java class generates a CPLEX model to find the optimal solution
 * to multiple sources to multiple sinks routing problem. The model generated is
 * a simple variation of the MultiCommodity network flow problem. Instead of
 * minimizing the number of used links, we minimize the number of broadcast
 * messages. To that end, we minimize the number of nodes involved in routing,
 * as each node sends a single broadcast message along a specific route. The
 * model obtained has been tested using the GLPK solver.
 * 
 * As for the command-line parameters governing the model generation, see the
 * printUsage() method body.
 * 
 * @author Luca Mottola <a
 *         href="mailto:mottola@elet.polimi.it">mottola@elet.polimi.it</a>
 * 
 */
public class MultiCommodityGen {

    public static void main(String[] args) {
        int nodes = 0;
        boolean[][] topology = null;
        String topologyFile = null;
        String outputFile = null;
        boolean nodesParam = false;
        boolean sourcesParam = false;
        boolean sinksParam = false;
        boolean topologyParam = false;
        boolean outputParam = false;
        HashSet<String> sources = new HashSet<String>();
        HashSet<String> sinks = new HashSet<String>();
        for (int i = 0; i < args.length; i++) {
            if (args[i].startsWith("nodes=")) {
                nodes = Integer.parseInt(args[i].substring(args[i].indexOf("=") + 1));
                nodesParam = true;
            } else if (args[i].startsWith("sources=")) {
                String[] sourceStrs = args[i].substring(args[i].indexOf("=") + 1).split(",");
                for (int j = 0; j < sourceStrs.length; j++) {
                    sources.add(sourceStrs[j]);
                }
                sourcesParam = true;
            } else if (args[i].startsWith("sinks=")) {
                String[] sinkStrs = args[i].substring(args[i].indexOf("=") + 1).split(",");
                for (int j = 0; j < sinkStrs.length; j++) {
                    sinks.add(sinkStrs[j]);
                }
                sinksParam = true;
            } else if (args[i].startsWith("topology=")) {
                topologyFile = args[i].substring(args[i].indexOf("=") + 1);
                topologyParam = true;
            } else if (args[i].startsWith("output=")) {
                outputFile = args[i].substring(args[i].indexOf("=") + 1);
                outputParam = true;
            } else {
                printUsage();
                System.exit(-1);
            }
        }
        if (nodesParam && sourcesParam && sinksParam && topologyParam && outputParam) {
            topology = new boolean[nodes][nodes];
            for (int i = 0; i < nodes; i++) {
                for (int j = 0; j < nodes; j++) {
                    topology[i][j] = false;
                }
            }
            BufferedReader input = null;
            try {
                input = new BufferedReader(new FileReader(topologyFile));
                String line = null;
                while ((line = input.readLine()) != null) {
                    String row[] = line.split(":");
                    int nodeA = Integer.parseInt(row[0]);
                    int nodeB = Integer.parseInt(row[1]);
                    topology[nodeA][nodeB] = true;
                }
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            printUsage();
            System.exit(-1);
        }
        BufferedWriter output = null;
        try {
            output = new BufferedWriter(new FileWriter(outputFile));
            output.write("\\* " + outputFile + ": automatically generated by MultiCommodityGen *\\\n\n");
            String minimizeStr = "Minimize\n\tvalue: ";
            for (int i = 0; i < nodes; i++) {
                minimizeStr = minimizeStr.concat("u" + i + " ");
                if (i < nodes - 1) {
                    minimizeStr = minimizeStr.concat("+ ");
                } else {
                    minimizeStr = minimizeStr.concat("\n\n");
                }
            }
            output.write(minimizeStr);
            int constraintNum = 0;
            String constraintStr = "Subject To\n";
            int commodities = sources.size() * sinks.size();
            for (int i = 0; i < commodities; i++) {
                for (int j = 0; j < nodes; j++) {
                    for (int z = 0; z < nodes; z++) {
                        if (topology[j][z] && j != z) {
                            constraintStr = constraintStr.concat("\tc" + constraintNum + ": r" + i + "_" + j + z + " - u" + j + " <= 0\n");
                            constraintNum++;
                        }
                    }
                }
            }
            output.write(constraintStr);
            String flowStr = new String();
            Iterator<String> sourceIt = sources.iterator();
            Iterator<String> sinkIt = sinks.iterator();
            String sinkId = null;
            for (int i = 0; i < commodities; i++) {
                if (i % sources.size() == 0) {
                    sinkId = sinkIt.next();
                    sourceIt = sources.iterator();
                }
                String sourceId = sourceIt.next();
                for (int j = 0; j < nodes; j++) {
                    flowStr = flowStr.concat("\tn" + j + "_" + i + ":");
                    for (int z = 0; z < nodes; z++) {
                        if (topology[j][z] && j != z) {
                            flowStr = flowStr.concat(" + r" + i + "_" + j + z);
                        }
                    }
                    for (int z = 0; z < nodes; z++) {
                        if (topology[z][j] && j != z) {
                            flowStr = flowStr.concat(" - r" + i + "_" + z + j);
                        }
                    }
                    if (sourceId.equals(String.valueOf(j))) {
                        flowStr = flowStr.concat(" = 1\n");
                    } else if (sinkId.equals(String.valueOf(j))) {
                        flowStr = flowStr.concat(" = -1\n");
                    } else {
                        flowStr = flowStr.concat(" = 0\n");
                    }
                }
            }
            output.write(flowStr + "\n");
            String boundStr = "Bounds\n";
            for (int i = 0; i < commodities; i++) {
                for (int j = 0; j < nodes; j++) {
                    for (int z = 0; z < nodes; z++) {
                        if (topology[j][z] && j != z) {
                            boundStr = boundStr.concat("\tr" + i + "_" + j + z + " <= 1\n");
                            boundStr = boundStr.concat("\tr" + i + "_" + j + z + " >= 0\n");
                        }
                    }
                }
            }
            for (int i = 0; i < nodes; i++) {
                boundStr = boundStr.concat("\tu" + i + " <=1\n");
                boundStr = boundStr.concat("\tu" + i + " >=0\n");
            }
            output.write(boundStr + "\n");
            String binaryStr = "Binary\n";
            for (int i = 0; i < nodes; i++) {
                binaryStr = binaryStr.concat("\tu" + i + "\n");
            }
            for (int i = 0; i < commodities; i++) {
                for (int j = 0; j < nodes; j++) {
                    for (int z = 0; z < nodes; z++) {
                        if (topology[j][z] && j != z) {
                            binaryStr = binaryStr.concat("\tr" + i + "_" + j + z + "\n");
                        }
                    }
                }
            }
            output.write(binaryStr + "\n");
            output.write("End\n\n");
            output.write("\\* eof *\\\n\n");
            output.flush();
            output.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void printUsage() {
        System.err.println("Command line error!\n");
        System.err.println("usage: java -cp . polimi.multiCommodity.MultiCommodityGen nodes=<number_of_nodes> sources=<source_ids (comma separated)> sinks=<sink_ids (comma separated)> topology=<topology_file (as generated by LossyBuilder)> output=<output_filename>");
        System.err.println("\nNote the links are considered as totally reliable, despite the packet loss probabilities set by TinyOS's LossyBuilder.");
    }
}
