package org.easyway.effects.translator;

import org.easyway.annotations.Optimized;
import org.easyway.interfaces.extended.IDrawing;
import org.easyway.interfaces.extended.ILayerID;
import org.easyway.objects.BaseObject;
import org.easyway.objects.texture.TextureCompact;
import org.easyway.system.StaticRef;
import org.easyway.system.state.OpenGLState;
import org.easyway.utils.ImageUtils;
import org.easyway.utils.MathUtils;
import org.lwjgl.opengl.GL11;

@Optimized
public class ScrollOut extends BaseObject implements IDrawing, ILayerID {

    /**
	 * autogenerated serial version of class
	 */
    private static final long serialVersionUID = -6531518032090295951L;

    private int layer;

    /**
	 * the drawing sheet
	 */
    private int idLayer = -1;

    protected long time;

    protected float incx, incy;

    protected float x, y;

    protected TextureCompact texture;

    protected float width = StaticRef.getCamera().getWidth();

    protected float height = StaticRef.getCamera().getHeight();

    protected float alpha;

    protected boolean changeAlpha;

    public ScrollOut(long time, float angle) {
        angle = MathUtils.degToRad(angle);
        incx = (float) Math.cos(angle) * width;
        incy = (float) Math.sin(angle) * height;
        if (time < 200) time = 200;
        this.time = time * 1000000;
        alpha = 1.0f;
        texture = ImageUtils.getScreenShot();
        changeAlpha = true;
    }

    public void render() {
        float step = (float) StaticRef.core.getElaspedTime() / (float) time;
        if (changeAlpha) {
            alpha = alpha - step;
            if (alpha <= 0) {
                destroy();
                return;
            }
        }
        x += step * incx;
        y += step * incy;
        if (x > width || x < -width) {
            if (y > height || y < -height) {
                destroy();
                return;
            }
        }
        texture.bind();
        OpenGLState.enableBlending();
        GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
        GL11.glColor4f(1, 1, 1, alpha);
        GL11.glBegin(GL11.GL_QUADS);
        {
            GL11.glTexCoord2f(0, texture.yEnd);
            GL11.glVertex2f(x, y);
            GL11.glTexCoord2f(texture.xEnd, texture.yEnd);
            GL11.glVertex2f(x + width, y);
            GL11.glTexCoord2f(texture.xEnd, 0);
            GL11.glVertex2f(x + width, y + height);
            GL11.glTexCoord2f(0, 0);
            GL11.glVertex2f(x, y + height);
        }
        GL11.glEnd();
    }

    public int getLayer() {
        return layer;
    }

    public void setLayer(int layer) {
        this.layer = layer;
        readdToDrawingLists();
    }

    /**
	 * indicates if the effect should change the alpha component in the time or
	 * not.
	 * 
	 * @param chage
	 *            indicates if the effect should change the alpha component in
	 *            the time or not.
	 */
    public void changeAlpha(boolean change) {
        changeAlpha = change;
    }

    public void onDestroy() {
        texture.destroy();
    }

    public int getIdLayer() {
        return idLayer;
    }

    public void setIdLayer(int id) {
        if (idLayer != -1) {
            StaticRef.layers[idLayer].remove(this);
        }
        if (id < 0) {
            id = 0;
        } else if (id > StaticRef.layers.length) {
            id = StaticRef.layers.length;
        }
        idLayer = id;
        StaticRef.layers[idLayer].add(this);
    }
}
