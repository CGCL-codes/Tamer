package com.neurogrid.om;

import java.util.*;
import java.math.*;
import org.apache.torque.Torque;
import org.apache.torque.TorqueException;
import org.apache.torque.om.*;
import org.apache.torque.util.BasePeer;
import org.apache.torque.util.Criteria;
import org.apache.torque.pool.DBConnection;
import org.apache.commons.lang.Objects;

/**
 * This class was autogenerated by Torque on:
 *
 * [Wed Mar 12 10:15:42 JST 2003]
 *
 * You should not use this class directly.  It should not even be
 * extended all references should be to Uri
 */
public abstract class BaseUri extends BaseObject {

    /** The Peer class */
    private static final UriPeer peer = new UriPeer();

    /**
         * The value for the uri_id field
         */
    private NumberKey uri_id;

    /**
         * The value for the uri field
         */
    private String uri;

    /**
         * The value for the last_modified field
         */
    private long last_modified;

    /**
         * The value for the created field
         */
    private long created;

    /**
         * The value for the local_copy field
         */
    private String local_copy;

    /**
         * The value for the key_id field
         */
    private String key_id;

    /**
         * Get the UriId
         * @return NumberKey
         */
    public NumberKey getUriId() {
        return uri_id;
    }

    /**
         * Set the value of UriId
         */
    public void setUriId(NumberKey v) throws TorqueException {
        if (v != null && v.getValue() == null) {
            v = null;
        }
        if (!Objects.equals(this.uri_id, v)) {
            this.uri_id = v;
            setModified(true);
        }
        if (collUriDescs != null) {
            for (int i = 0; i < collUriDescs.size(); i++) {
                ((UriDesc) collUriDescs.get(i)).setUriId(v);
            }
        }
        if (collNodeDescs != null) {
            for (int i = 0; i < collNodeDescs.size(); i++) {
                ((NodeDesc) collNodeDescs.get(i)).setUriId(v);
            }
        }
        if (collUriTriples != null) {
            for (int i = 0; i < collUriTriples.size(); i++) {
                ((UriTriple) collUriTriples.get(i)).setUriId(v);
            }
        }
    }

    /**
    * Set the value of UriId as a string.
    */
    public void setUriId(String v) throws TorqueException {
        setUriId(new NumberKey(v));
    }

    /**
         * Get the Uri
         * @return String
         */
    public String getUri() {
        return uri;
    }

    /**
         * Set the value of Uri
         */
    public void setUri(String v) {
        if (!Objects.equals(this.uri, v)) {
            this.uri = v;
            setModified(true);
        }
    }

    /**
         * Get the LastModified
         * @return long
         */
    public long getLastModified() {
        return last_modified;
    }

    /**
         * Set the value of LastModified
         */
    public void setLastModified(long v) {
        if (this.last_modified != v) {
            this.last_modified = v;
            setModified(true);
        }
    }

    /**
         * Get the Created
         * @return long
         */
    public long getCreated() {
        return created;
    }

    /**
         * Set the value of Created
         */
    public void setCreated(long v) {
        if (this.created != v) {
            this.created = v;
            setModified(true);
        }
    }

    /**
         * Get the LocalCopy
         * @return String
         */
    public String getLocalCopy() {
        return local_copy;
    }

    /**
         * Set the value of LocalCopy
         */
    public void setLocalCopy(String v) {
        if (!Objects.equals(this.local_copy, v)) {
            this.local_copy = v;
            setModified(true);
        }
    }

    /**
         * Get the KeyId
         * @return String
         */
    public String getKeyId() {
        return key_id;
    }

    /**
         * Set the value of KeyId
         */
    public void setKeyId(String v) {
        if (!Objects.equals(this.key_id, v)) {
            this.key_id = v;
            setModified(true);
        }
    }

    /**
     * Collection to store aggregation of collUriDescs
     */
    protected List collUriDescs;

    /**
     * Temporary storage of collUriDescs to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initUriDescs() {
        if (collUriDescs == null) {
            collUriDescs = new ArrayList();
        }
    }

    /**
     * Method called to associate a UriDesc object to this object
     * through the UriDesc foreign key attribute
     *
     * @param l UriDesc
     */
    public void addUriDesc(UriDesc l) throws TorqueException {
        getUriDescs().add(l);
        l.setUri((Uri) this);
    }

    /**
     * The criteria used to select the current contents of collUriDescs
     */
    private Criteria lastUriDescsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getUriDescs(new Criteria())
     */
    public List getUriDescs() throws TorqueException {
        if (collUriDescs == null) {
            collUriDescs = getUriDescs(new Criteria(10));
        }
        return collUriDescs;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Uri has previously
     * been saved, it will retrieve related UriDescs from storage.
     * If this Uri is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     */
    public List getUriDescs(Criteria criteria) throws TorqueException {
        if (collUriDescs == null) {
            if (isNew()) {
                collUriDescs = new ArrayList();
            } else {
                criteria.add(UriDescPeer.URI_ID, getUriId());
                collUriDescs = UriDescPeer.doSelect(criteria);
            }
        } else {
            if (!isNew()) {
                criteria.add(UriDescPeer.URI_ID, getUriId());
                if (!lastUriDescsCriteria.equals(criteria)) {
                    collUriDescs = UriDescPeer.doSelect(criteria);
                }
            }
        }
        lastUriDescsCriteria = criteria;
        return collUriDescs;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Uri is new, it will return
     * an empty collection; or if this Uri has previously
     * been saved, it will retrieve related UriDescs from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Uri.
     */
    protected List getUriDescsJoinNgUser(Criteria criteria) throws TorqueException {
        if (collUriDescs == null) {
            if (isNew()) {
                collUriDescs = new ArrayList();
            } else {
                criteria.add(UriDescPeer.URI_ID, getUriId());
                collUriDescs = UriDescPeer.doSelectJoinNgUser(criteria);
            }
        } else {
            boolean newCriteria = true;
            criteria.add(UriDescPeer.URI_ID, getUriId());
            if (!lastUriDescsCriteria.equals(criteria)) {
                collUriDescs = UriDescPeer.doSelectJoinNgUser(criteria);
            }
        }
        lastUriDescsCriteria = criteria;
        return collUriDescs;
    }

    /**
     * Collection to store aggregation of collNodeDescs
     */
    protected List collNodeDescs;

    /**
     * Temporary storage of collNodeDescs to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initNodeDescs() {
        if (collNodeDescs == null) {
            collNodeDescs = new ArrayList();
        }
    }

    /**
     * Method called to associate a NodeDesc object to this object
     * through the NodeDesc foreign key attribute
     *
     * @param l NodeDesc
     */
    public void addNodeDesc(NodeDesc l) throws TorqueException {
        getNodeDescs().add(l);
        l.setUri((Uri) this);
    }

    /**
     * The criteria used to select the current contents of collNodeDescs
     */
    private Criteria lastNodeDescsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getNodeDescs(new Criteria())
     */
    public List getNodeDescs() throws TorqueException {
        if (collNodeDescs == null) {
            collNodeDescs = getNodeDescs(new Criteria(10));
        }
        return collNodeDescs;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Uri has previously
     * been saved, it will retrieve related NodeDescs from storage.
     * If this Uri is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     */
    public List getNodeDescs(Criteria criteria) throws TorqueException {
        if (collNodeDescs == null) {
            if (isNew()) {
                collNodeDescs = new ArrayList();
            } else {
                criteria.add(NodeDescPeer.URI_ID, getUriId());
                collNodeDescs = NodeDescPeer.doSelect(criteria);
            }
        } else {
            if (!isNew()) {
                criteria.add(NodeDescPeer.URI_ID, getUriId());
                if (!lastNodeDescsCriteria.equals(criteria)) {
                    collNodeDescs = NodeDescPeer.doSelect(criteria);
                }
            }
        }
        lastNodeDescsCriteria = criteria;
        return collNodeDescs;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Uri is new, it will return
     * an empty collection; or if this Uri has previously
     * been saved, it will retrieve related NodeDescs from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Uri.
     */
    protected List getNodeDescsJoinNgUser(Criteria criteria) throws TorqueException {
        if (collNodeDescs == null) {
            if (isNew()) {
                collNodeDescs = new ArrayList();
            } else {
                criteria.add(NodeDescPeer.URI_ID, getUriId());
                collNodeDescs = NodeDescPeer.doSelectJoinNgUser(criteria);
            }
        } else {
            boolean newCriteria = true;
            criteria.add(NodeDescPeer.URI_ID, getUriId());
            if (!lastNodeDescsCriteria.equals(criteria)) {
                collNodeDescs = NodeDescPeer.doSelectJoinNgUser(criteria);
            }
        }
        lastNodeDescsCriteria = criteria;
        return collNodeDescs;
    }

    /**
     * Collection to store aggregation of collUriTriples
     */
    protected List collUriTriples;

    /**
     * Temporary storage of collUriTriples to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initUriTriples() {
        if (collUriTriples == null) {
            collUriTriples = new ArrayList();
        }
    }

    /**
     * Method called to associate a UriTriple object to this object
     * through the UriTriple foreign key attribute
     *
     * @param l UriTriple
     */
    public void addUriTriple(UriTriple l) throws TorqueException {
        getUriTriples().add(l);
        l.setUri((Uri) this);
    }

    /**
     * The criteria used to select the current contents of collUriTriples
     */
    private Criteria lastUriTriplesCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getUriTriples(new Criteria())
     */
    public List getUriTriples() throws TorqueException {
        if (collUriTriples == null) {
            collUriTriples = getUriTriples(new Criteria(10));
        }
        return collUriTriples;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Uri has previously
     * been saved, it will retrieve related UriTriples from storage.
     * If this Uri is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     */
    public List getUriTriples(Criteria criteria) throws TorqueException {
        if (collUriTriples == null) {
            if (isNew()) {
                collUriTriples = new ArrayList();
            } else {
                criteria.add(UriTriplePeer.URI_ID, getUriId());
                collUriTriples = UriTriplePeer.doSelect(criteria);
            }
        } else {
            if (!isNew()) {
                criteria.add(UriTriplePeer.URI_ID, getUriId());
                if (!lastUriTriplesCriteria.equals(criteria)) {
                    collUriTriples = UriTriplePeer.doSelect(criteria);
                }
            }
        }
        lastUriTriplesCriteria = criteria;
        return collUriTriples;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Uri is new, it will return
     * an empty collection; or if this Uri has previously
     * been saved, it will retrieve related UriTriples from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Uri.
     */
    protected List getUriTriplesJoinPredicate(Criteria criteria) throws TorqueException {
        if (collUriTriples == null) {
            if (isNew()) {
                collUriTriples = new ArrayList();
            } else {
                criteria.add(UriTriplePeer.URI_ID, getUriId());
                collUriTriples = UriTriplePeer.doSelectJoinPredicate(criteria);
            }
        } else {
            boolean newCriteria = true;
            criteria.add(UriTriplePeer.URI_ID, getUriId());
            if (!lastUriTriplesCriteria.equals(criteria)) {
                collUriTriples = UriTriplePeer.doSelectJoinPredicate(criteria);
            }
        }
        lastUriTriplesCriteria = criteria;
        return collUriTriples;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this Uri is new, it will return
     * an empty collection; or if this Uri has previously
     * been saved, it will retrieve related UriTriples from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in Uri.
     */
    protected List getUriTriplesJoinKeyword(Criteria criteria) throws TorqueException {
        if (collUriTriples == null) {
            if (isNew()) {
                collUriTriples = new ArrayList();
            } else {
                criteria.add(UriTriplePeer.URI_ID, getUriId());
                collUriTriples = UriTriplePeer.doSelectJoinKeyword(criteria);
            }
        } else {
            boolean newCriteria = true;
            criteria.add(UriTriplePeer.URI_ID, getUriId());
            if (!lastUriTriplesCriteria.equals(criteria)) {
                collUriTriples = UriTriplePeer.doSelectJoinKeyword(criteria);
            }
        }
        lastUriTriplesCriteria = criteria;
        return collUriTriples;
    }

    private static List fieldNames = null;

    /**
     * Generate a list of field names.
     */
    public static synchronized List getFieldNames() {
        if (fieldNames == null) {
            fieldNames = new ArrayList();
            fieldNames.add("UriId");
            fieldNames.add("Uri");
            fieldNames.add("LastModified");
            fieldNames.add("Created");
            fieldNames.add("LocalCopy");
            fieldNames.add("KeyId");
            fieldNames = Collections.unmodifiableList(fieldNames);
        }
        return fieldNames;
    }

    /**
     * Retrieves a field from the object by name passed in
     * as a String.
     */
    public Object getByName(String name) {
        if (name.equals("UriId")) {
            return getUriId();
        }
        if (name.equals("Uri")) {
            return getUri();
        }
        if (name.equals("LastModified")) {
            return new Long(getLastModified());
        }
        if (name.equals("Created")) {
            return new Long(getCreated());
        }
        if (name.equals("LocalCopy")) {
            return getLocalCopy();
        }
        if (name.equals("KeyId")) {
            return getKeyId();
        }
        return null;
    }

    /**
     * Retrieves a field from the object by name passed in
     * as a String.  The String must be one of the static
     * Strings defined in this Class' Peer.
     */
    public Object getByPeerName(String name) {
        if (name.equals(UriPeer.URI_ID)) {
            return getUriId();
        }
        if (name.equals(UriPeer.URI)) {
            return getUri();
        }
        if (name.equals(UriPeer.LAST_MODIFIED)) {
            return new Long(getLastModified());
        }
        if (name.equals(UriPeer.CREATED)) {
            return new Long(getCreated());
        }
        if (name.equals(UriPeer.LOCAL_COPY)) {
            return getLocalCopy();
        }
        if (name.equals(UriPeer.KEY_ID)) {
            return getKeyId();
        }
        return null;
    }

    /**
     * Retrieves a field from the object by Position as specified
     * in the xml schema.  Zero-based.
     */
    public Object getByPosition(int pos) {
        if (pos == 0) {
            return getUriId();
        }
        if (pos == 1) {
            return getUri();
        }
        if (pos == 2) {
            return new Long(getLastModified());
        }
        if (pos == 3) {
            return new Long(getCreated());
        }
        if (pos == 4) {
            return getLocalCopy();
        }
        if (pos == 5) {
            return getKeyId();
        }
        return null;
    }

    /**
     * Stores the object in the database.  If the object is new,
     * it inserts it; otherwise an update is performed.
     */
    public void save() throws Exception {
        save(UriPeer.getMapBuilder().getDatabaseMap().getName());
    }

    /**
     * Stores the object in the database.  If the object is new,
     * it inserts it; otherwise an update is performed.
     * Note: this code is here because the method body is
     * auto-generated conditionally and therefore needs to be
     * in this file instead of in the super class, BaseObject.
     */
    public void save(String dbName) throws TorqueException {
        DBConnection dbCon = null;
        try {
            dbCon = BasePeer.beginTransaction(dbName);
            save(dbCon);
        } catch (TorqueException e) {
            BasePeer.rollBackTransaction(dbCon);
            throw e;
        }
        BasePeer.commitTransaction(dbCon);
    }

    /** flag to prevent endless save loop, if this object is referenced
        by another object which falls in this transaction. */
    private boolean alreadyInSave = false;

    /**
     * Stores the object in the database.  If the object is new,
     * it inserts it; otherwise an update is performed.  This method
     * is meant to be used as part of a transaction, otherwise use
     * the save() method and the connection details will be handled
     * internally
     */
    public void save(DBConnection dbCon) throws TorqueException {
        if (!alreadyInSave) {
            alreadyInSave = true;
            if (isModified()) {
                if (isNew()) {
                    UriPeer.doInsert((Uri) this, dbCon);
                    setNew(false);
                } else {
                    UriPeer.doUpdate((Uri) this, dbCon);
                }
            }
            if (collUriDescs != null) {
                for (int i = 0; i < collUriDescs.size(); i++) {
                    ((UriDesc) collUriDescs.get(i)).save(dbCon);
                }
            }
            if (collNodeDescs != null) {
                for (int i = 0; i < collNodeDescs.size(); i++) {
                    ((NodeDesc) collNodeDescs.get(i)).save(dbCon);
                }
            }
            if (collUriTriples != null) {
                for (int i = 0; i < collUriTriples.size(); i++) {
                    ((UriTriple) collUriTriples.get(i)).save(dbCon);
                }
            }
            alreadyInSave = false;
        }
    }

    /**
     * Set the PrimaryKey using ObjectKey.
     *
     * @param  uri_id ObjectKey
     */
    public void setPrimaryKey(ObjectKey uri_id) throws TorqueException {
        setUriId((NumberKey) uri_id);
    }

    /**
     * Set the PrimaryKey using a String.
     */
    public void setPrimaryKey(String key) throws TorqueException {
        setUriId(new NumberKey(key));
    }

    /**
     * returns an id that differentiates this object from others
     * of its class.
     */
    public ObjectKey getPrimaryKey() {
        return getUriId();
    }

    /**
     * Makes a copy of this object.
     * It creates a new object filling in the simple attributes.
     * It then fills all the association collections and sets the
     * related objects to isNew=true.
     */
    public Uri copy() throws TorqueException {
        return copyInto(new Uri());
    }

    protected Uri copyInto(Uri copyObj) throws TorqueException {
        copyObj.setUriId(uri_id);
        copyObj.setUri(uri);
        copyObj.setLastModified(last_modified);
        copyObj.setCreated(created);
        copyObj.setLocalCopy(local_copy);
        copyObj.setKeyId(key_id);
        copyObj.setNew(false);
        List v = getUriDescs();
        for (int i = 0; i < v.size(); i++) {
            UriDesc obj = (UriDesc) v.get(i);
            copyObj.addUriDesc(obj.copy());
            ((Persistent) v.get(i)).setNew(true);
        }
        v = getNodeDescs();
        for (int i = 0; i < v.size(); i++) {
            NodeDesc obj = (NodeDesc) v.get(i);
            copyObj.addNodeDesc(obj.copy());
            ((Persistent) v.get(i)).setNew(true);
        }
        v = getUriTriples();
        for (int i = 0; i < v.size(); i++) {
            UriTriple obj = (UriTriple) v.get(i);
            copyObj.addUriTriple(obj.copy());
            ((Persistent) v.get(i)).setNew(true);
        }
        copyObj.setNew(true);
        copyObj.setUriId((NumberKey) null);
        return copyObj;
    }

    /**
     * returns a peer instance associated with this om.  Since Peer classes
     * are not to have any instance attributes, this method returns the
     * same instance for all member of this class. The method could therefore
     * be static, but this would prevent one from overriding the behavior.
     */
    public UriPeer getPeer() {
        return peer;
    }
}
