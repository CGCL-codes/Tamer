package org.fudaa.dodico.telemac.dico;

import org.fudaa.dodico.dico.*;

/**
 * @author deniger
 */
public class DicoStbtelv5p6 extends DicoModelAbstract {

    public DicoStbtelv5p6() {
        super();
    }

    public DicoStbtelv5p6(int _l) {
        super(_l);
    }

    public DicoStbtelv5p6(String _l) {
        super(_l);
    }

    public final String getCodeName() {
        return "stbtel";
    }

    public final String getVersion() {
        return "v5p6";
    }

    protected String[] createNoms() {
        String[] noms;
        if (languageIndex_ == 0) {
            noms = new String[] { "ABSCISSES DES SOMMETS DU POLYGONE D'EXTRACTION", "ABSCISSES DES SOMMETS DU POLYGONE DE RAFFINEMENT", "BATHYMETRIE DANS LE FICHIER UNIVERSEL", "BIBLIOTHEQUES", "CONDITIONS LIMITES DANS LE FICHIER ADDITIONNEL", "CORRECTION DES FONDS DE TRIGRID", "DECOUPAGE DES TRIANGLES EN QUATRE", "DECOUPAGE DES TRIANGLES SURCONTRAINTS", "DESCRIPTION DES LIBRAIRIES", "DICTIONNAIRE", "DISTANCE MINIMALE A LA FRONTIERE", "DISTANCE MINIMALE ENTRE DEUX POINTS", "ECRITURE DE LA COULEUR DES NOEUDS", "ELIMINATION DES DEPENDANCES ARRIERES", "ELIMINATION DES ELEMENTS PARTIELLEMENT SECS", "ELIMINATION DES ELEMENTS SECS", "EXECUTABLE PAR DEFAUT", "EXECUTABLE PARALLELE PAR DEFAUT", "FICHIER ADDITIONNEL DU MAILLEUR", "FICHIER DE GEOMETRIE POUR TELEMAC", "FICHIER DES CONDITIONS AUX LIMITES", "FICHIER DES PARAMETRES", "FICHIER FORTRAN", "FICHIER UNIVERSEL", "FICHIERS DES FONDS", "LISTE DES FICHIERS", "LONGUEUR DU VECTEUR", "MAILLEUR", "MOT DE PASSE", "NOMBRE DE SOMMETS DU POLYGONE D'EXTRACTION", "NOMBRE DE SOMMETS DU POLYGONE DE RAFFINEMENT", "NOMBRE MAXIMUM DE POINTS DE BATHYMETRIE", "NUMERO DE COMPTE", "NUMERO DE VERSION", "ORDONNEES DES SOMMETS DU POLYGONE D'EXTRACTION", "ORDONNEES DES SOMMETS DU POLYGONE DE RAFFINEMENT", "PLACE MEMOIRE", "PROJECTION APRES EXTRACTION", "RENUMEROTATION DES POINTS", "SEUIL DE SECHERESSE", "STANDARD DE BINAIRE", "STOCKAGE DE TOUS LES PAS DE TEMPS", "TEMPS MACHINE", "USER" };
        } else if (languageIndex_ == 1) {
            noms = new String[] { "ABSCISSAE OF THE VERTICES OF THE POLYGON TO EXTRACT THE MESH", "ABSCISSAE OF THE VERTICES OF THE POLYGON TO REFINE THE MESH", "ACCOUNT", "BATHYMETRY IN THE UNIVERSAL FILE", "BIBLIOTHEQUES", "BINARY STANDARD", "BOTTOM CORRECTION OF TRIGRID", "BOTTOM TOPOGRAPHY FILES", "BOUNDARY CONDITIONS FILE", "BOUNDARY CONDITIONS IN THE ADDITIONAL FILE", "CPU TIME", "CUTTING ELEMENTS IN FOUR", "DEFAULT EXECUTABLE", "DEFAULT PARALLEL EXECUTABLE", "DESCRIPTION OF LIBRARIES", "DICTIONARY", "DRY ELEMENTS ELIMINATION", "DRY LIMIT", "ELIMINATION OF BACKWARD DEPENDENCIES", "FORTRAN FILE", "GEOMETRY FILE FOR TELEMAC", "LIST OF FILES", "MAXIMUM NUMBER OF BATHYMETRIC POINTS", "MEMORY SPACE", "MESH ADDITIONAL DATA FILE", "MESH GENERATOR", "MINIMUM DISTANCE AT BOUNDARY", "MINIMUM DISTANCE BETWEEN TWO POINTS", "NODES RENUMBERING", "NUMBER OF VERTICES OF THE POLYGON TO EXTRACT THE MESH", "NUMBER OF VERTICES OF THE POLYGON TO REFINE THE MESH", "ORDINATES OF THE VERTICES OF THE POLYGON TO EXTRACT THE MESH", "ORDINATES OF THE VERTICES OF THE POLYGON TO REFINE THE MESH", "OVERSTRESSED TRIANGLES CUTTING", "PARTIALLY DRY ELEMENTS ELIMINATION", "PASSWORD", "PROJECTION AFTER EXTRACTION", "RELEASE", "STEERING FILE", "STORAGE OF ALL TIME STEPS", "UNIVERSAL FILE", "USER", "VECTOR LENGTH", "WRITING NODE COLOURS" };
        } else noms = null;
        return noms;
    }

    protected final DicoEntite[] createEntites() {
        DicoComportValues[] comportValues;
        DicoEntite.Simple entiteSimple;
        DicoEntite.Tableau entiteTableau;
        DicoEntite.Vecteur entiteVecteur;
        DicoDataType.Entier typeEntier;
        DicoDataType.Binaire typeBinaire;
        DicoDataType.Chaine typeChaine;
        DicoDataType.Reel typeReel;
        String[] choiceKeys;
        String[][] choiceValues;
        String[] valueByLanguage = new String[2];
        DicoEntite[] entites = new DicoEntite[44];
        typeEntier = new DicoDataType.Entier();
        typeEntier.setControle(0);
        valueByLanguage[0] = "NOMBRE MAXIMUM DE POINTS DE BATHYMETRIE";
        valueByLanguage[1] = "MAXIMUM NUMBER OF BATHYMETRIC POINTS";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeEntier);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Permet de dimensionner le tableau utilise pour la lecture, dans les" + "\nFICHIERS DES FONDS, des points releves a la table a digitaliser.";
        valueByLanguage[1] = "Designed for dimensioning the array that is used for reading, in the" + "\nBOTTOM TOPOGRAPHY FILES, the points recorded at the digitizing tablet.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "20000";
        valueByLanguage[1] = "20000";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[0] = entiteSimple.getImmutable();
        typeEntier = new DicoDataType.Entier();
        typeEntier.setControle(0);
        valueByLanguage[0] = "LONGUEUR DU VECTEUR";
        valueByLanguage[1] = "VECTOR LENGTH";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeEntier);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Permet de fixer, sur machine vectorielle, la longueur du vecteur.";
        valueByLanguage[1] = "Designed for dimensioning the vector length on vector machine.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "1";
        valueByLanguage[1] = "1";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[1] = entiteSimple.getImmutable();
        typeEntier = new DicoDataType.Entier();
        typeEntier.setControle(0);
        valueByLanguage[0] = "NOMBRE DE SOMMETS DU POLYGONE D'EXTRACTION";
        valueByLanguage[1] = "NUMBER OF VERTICES OF THE POLYGON TO EXTRACT THE MESH";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeEntier);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Lorsque l'on souhaite extraire une partie du maillage," + "\npermet de definir le nombre de sommets du polygone a l'interieur" + "\nduquel le maillage sera effectivement extrait." + "\nATTENTION: ce polygone doit etre convexe et les coordonnees des" + "\nsommets donnes dans l'ordre trigonometrique.";
        valueByLanguage[1] = "When you want to extract a piece of the mesh, this key-word fixes" + "\nthe number of vertices of a polygon inside of which the mesh will be" + "\nfinally extracted." + "\nATTENTION: this polygon should have a convex shape and the coordinates" + "\nof the vertices be given with an anti clock wise order.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "0";
        valueByLanguage[1] = "0";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[2] = entiteSimple.getImmutable();
        typeEntier = new DicoDataType.Entier();
        typeEntier.setControle(0);
        valueByLanguage[0] = "NOMBRE DE SOMMETS DU POLYGONE DE RAFFINEMENT";
        valueByLanguage[1] = "NUMBER OF VERTICES OF THE POLYGON TO REFINE THE MESH";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeEntier);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Lorsque l'on souhaite raffiner une partie du maillage," + "\npermet de definir le nombre de sommets du polygone a l'interieur" + "\nduquel le maillage sera effectivement raffine." + "\nATTENTION: ce polygone doit etre convexe et les coordonnees des" + "\nsommets donnes dans l'ordre trigonometrique.";
        valueByLanguage[1] = "When you want to refine a piece of the mesh, this key-word fixes" + "\nthe number of vertices of a polygon inside of which the mesh will be" + "\nfinally refined." + "\nATTENTION: this polygon should have a convex shape and the coordinates" + "\nof the vertices be given with an anti clock wise order.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "0";
        valueByLanguage[1] = "0";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[3] = entiteSimple.getImmutable();
        typeReel = new DicoDataType.Reel();
        typeReel.setControle(0.0);
        valueByLanguage[0] = "DISTANCE MINIMALE ENTRE DEUX POINTS";
        valueByLanguage[1] = "MINIMUM DISTANCE BETWEEN TWO POINTS";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeReel);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Distance (en metres)en dessous de laquelle deux noeuds sont consideres" + "\ncomme confondus par STBTEL, lors de la verification des resultats" + "\nfournis par le mailleur. Lorsque deux noeuds sont confondus, l'un" + "\nd'entre eux est elimine, et tous les noeuds du maillage sont" + "\nrenumerotes.";
        valueByLanguage[1] = "Distance (in meters) below which two nodes are considered as identical" + "\nby STBTEL when the results supplied by the mesh generator are being" + "\nchecked. When two nodes occur at the same place, one of them is" + "\neliminated and all the mesh nodes are renumbered.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "1.E-5";
        valueByLanguage[1] = "1.E-5";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[4] = entiteSimple.getImmutable();
        typeReel = new DicoDataType.Reel();
        typeReel.setControle(0.0);
        valueByLanguage[0] = "DISTANCE MINIMALE A LA FRONTIERE";
        valueByLanguage[1] = "MINIMUM DISTANCE AT BOUNDARY";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeReel);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "L'interpolation de la bathymetrie sur les noeuds du maillage est" + "\nrealisee de la facon suivante. Pour chaque noeud du maillage, on" + "\ndecoupe le plan en 4 quadrans. Dans chacun de ces quadrans, on cherche" + "\nle point releve a la table a digitaliser le plus proche. On affecte" + "\nalors au noeud considere une profondeur correspondant a la moyenne," + "\nponderee par la distance a ce noeud, des profondeurs en chacun des 4" + "\npoints precedemment trouves." + "\nOn verifie toutefois que, lors de la recherche des points, les" + "\nfrontieres du domaine ne sont pas franchies, de maniere a ne pas" + "\nintroduire d'aberration dans la bathymetrie." + "\nCe mot-cle permet alors de definir la distance minimale aux frontieres" + "\ndu domaine en dessous de laquelle on refuse de prendre en compte les" + "\npoints releves.";
        valueByLanguage[1] = "The bathymetric data at the mesh nodes are interpolated. At each mesh" + "\nnode, the plane is cut into 4 quadrants in each of which, among the" + "\npoints recorded at the digitizing tablet, the closest one to the node" + "\nbeing considered is searched for." + "\nThis node is thenn given a depth corresponding to the mean depth at" + "\neach of the 4 points previously found, these depths being weighted" + "\nby the distance to the node." + "\nWhen searching for the points in the quadrants, however, one shall" + "\nmake sure the boundaries aare not overstepped in order to prevent" + "\naberrations from being introduced into the bathymetric data." + "\nThe keyword can then be used for specifying the minimum distance to" + "\nthe boundaries below which the recorded points should be ignored.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "0.";
        valueByLanguage[1] = "0.";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[5] = entiteSimple.getImmutable();
        typeReel = new DicoDataType.Reel();
        typeReel.setControle(0.0);
        valueByLanguage[0] = "CORRECTION DES FONDS DE TRIGRID";
        valueByLanguage[1] = "BOTTOM CORRECTION OF TRIGRID";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeReel);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Fixe la valeur a ajouter a la bathymetrie lue dans le fichier" + "\ngemere par Trigrid.";
        valueByLanguage[1] = "Value to be added at the bottom value read in the Trigrid file";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "0.";
        valueByLanguage[1] = "0.";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[6] = entiteSimple.getImmutable();
        typeReel = new DicoDataType.Reel();
        typeReel.setControle(0.0);
        valueByLanguage[0] = "ABSCISSES DES SOMMETS DU POLYGONE D'EXTRACTION";
        valueByLanguage[1] = "ABSCISSAE OF THE VERTICES OF THE POLYGON TO EXTRACT THE MESH";
        entiteTableau = new DicoEntite.Tableau(valueByLanguage[languageIndex_], typeReel);
        entiteTableau.setTaille(9);
        entiteTableau.setNiveau(1);
        valueByLanguage[0] = "Lorsque l'on souhaite extraire une partie du maillage," + "\npermet de definir les abscisses des sommets du polygone a l'interieur" + "\nduquel le maillage sera effectivement extrait." + "\nATTENTION: ce polygone doit etre convexe et les coordonnees des" + "\nsommets donnes dans l'ordre trigonometrique.";
        valueByLanguage[1] = "When you want to extract a piece of the mesh, this key-word fixes" + "\nthe abscissae of the vertices of a polygon inside of which the mesh" + "\nwill be finally extracted." + "\nATTENTION: this polygon should have a convex shape and the coordinates" + "\nof the vertices be given with an anti clock wise order.";
        entiteTableau.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteTableau.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "0;0;0;0;0;0;0;0;0";
        valueByLanguage[1] = "0;0;0;0;0;0;0;0;0";
        entiteTableau.setDefautValue(valueByLanguage[languageIndex_]);
        entites[7] = entiteTableau.getImmutable();
        typeReel = new DicoDataType.Reel();
        typeReel.setControle(0.0);
        valueByLanguage[0] = "ORDONNEES DES SOMMETS DU POLYGONE D'EXTRACTION";
        valueByLanguage[1] = "ORDINATES OF THE VERTICES OF THE POLYGON TO EXTRACT THE MESH";
        entiteTableau = new DicoEntite.Tableau(valueByLanguage[languageIndex_], typeReel);
        entiteTableau.setTaille(9);
        entiteTableau.setNiveau(1);
        valueByLanguage[0] = "Lorsque l'on souhaite extraire une partie du maillage," + "\npermet de definir les ordonnees des sommets du polygone a l'interieur" + "\nduquel le maillage sera effectivement extrait." + "\nATTENTION: ce polygone doit etre convexe et les coordonnees des" + "\nsommets donnes dans l'ordre trigonometrique.";
        valueByLanguage[1] = "When you want to extract a piece of the mesh, this key-word fixes" + "\nthe ordinates of the vertices of a polygon inside of which the mesh" + "\nwill be finally extracted." + "\nATTENTION: this polygon should have a convex shape and the coordinates" + "\nof the vertices be given with an anti clock wise order.";
        entiteTableau.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteTableau.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "0;0;0;0;0;0;0;0;0";
        valueByLanguage[1] = "0;0;0;0;0;0;0;0;0";
        entiteTableau.setDefautValue(valueByLanguage[languageIndex_]);
        entites[8] = entiteTableau.getImmutable();
        typeReel = new DicoDataType.Reel();
        typeReel.setControle(0.0);
        valueByLanguage[0] = "ABSCISSES DES SOMMETS DU POLYGONE DE RAFFINEMENT";
        valueByLanguage[1] = "ABSCISSAE OF THE VERTICES OF THE POLYGON TO REFINE THE MESH";
        entiteTableau = new DicoEntite.Tableau(valueByLanguage[languageIndex_], typeReel);
        entiteTableau.setTaille(9);
        entiteTableau.setNiveau(1);
        valueByLanguage[0] = "Lorsque l'on souhaite raffiner une partie du maillage," + "\npermet de definir les abscisses des sommets du polygone a l'interieur" + "\nduquel le maillage sera effectivement raffine." + "\nATTENTION: ce polygone doit etre convexe et les coordonnees des" + "\nsommets donnes dans l'ordre trigonometrique.";
        valueByLanguage[1] = "When you want to refine a piece of the mesh, this key-word fixes" + "\nthe abscissae of the vertices of a polygon inside of which the mesh" + "\nwill be finally refined." + "\nATTENTION: this polygon should have a convex shape and the coordinates" + "\nof the vertices be given with an anti clock wise order.";
        entiteTableau.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteTableau.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "0;0;0;0;0;0;0;0;0";
        valueByLanguage[1] = "0;0;0;0;0;0;0;0;0";
        entiteTableau.setDefautValue(valueByLanguage[languageIndex_]);
        entites[9] = entiteTableau.getImmutable();
        typeReel = new DicoDataType.Reel();
        typeReel.setControle(0.0);
        valueByLanguage[0] = "ORDONNEES DES SOMMETS DU POLYGONE DE RAFFINEMENT";
        valueByLanguage[1] = "ORDINATES OF THE VERTICES OF THE POLYGON TO REFINE THE MESH";
        entiteTableau = new DicoEntite.Tableau(valueByLanguage[languageIndex_], typeReel);
        entiteTableau.setTaille(9);
        entiteTableau.setNiveau(1);
        valueByLanguage[0] = "Lorsque l'on souhaite raffiner une partie du maillage," + "\npermet de definir les ordonnees des sommets du polygone a l'interieur" + "\nduquel le maillage sera effectivement raffine." + "\nATTENTION: ce polygone doit etre convexe et les coordonnees des" + "\nsommets donnes dans l'ordre trigonometrique.";
        valueByLanguage[1] = "When you want to refine a piece of the mesh, this key-word fixes" + "\nthe ordinates of the vertices of a polygon inside of which the mesh" + "\nwill be finally refined." + "\nATTENTION: this polygon should have a convex shape and the coordinates" + "\nof the vertices be given with an anti clock wise order.";
        entiteTableau.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteTableau.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "0;0;0;0;0;0;0;0;0";
        valueByLanguage[1] = "0;0;0;0;0;0;0;0;0";
        entiteTableau.setDefautValue(valueByLanguage[languageIndex_]);
        entites[10] = entiteTableau.getImmutable();
        typeBinaire = DicoDataType.Binaire.EMPTY;
        valueByLanguage[0] = "DECOUPAGE DES TRIANGLES SURCONTRAINTS";
        valueByLanguage[1] = "OVERSTRESSED TRIANGLES CUTTING";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeBinaire);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Un triangle surcontraint est tel que ses trois noeuds soient situes" + "\nsur une frontiere du domaine de calcul. La presence de tels triangles" + "\npeut entrainer des instabilites lors des calculs realises par" + "\nTELEMAC 2D." + "\nCette option permet, en creant un noeud place au barycentre de des" + "\ntriangles surcontraints, d'eviter de tels problemes.";
        valueByLanguage[1] = "An overstressed triangle is one whose three nodes are located along a" + "\nboundary of the computational domain. The occurrence of such triangles" + "\nmay bring about instabilities in the computations made by TELEMAC 2D." + "\nSuch problems can be prevented by this option, through the creation of" + "\na node at the geometric centres of the overstressed triangles.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "false";
        valueByLanguage[1] = "false";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[11] = entiteSimple.getImmutable();
        typeBinaire = DicoDataType.Binaire.EMPTY;
        valueByLanguage[0] = "ECRITURE DE LA COULEUR DES NOEUDS";
        valueByLanguage[1] = "WRITING NODE COLOURS";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeBinaire);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Option non activee.";
        valueByLanguage[1] = "Option not activated";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "false";
        valueByLanguage[1] = "false";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[12] = entiteSimple.getImmutable();
        typeBinaire = DicoDataType.Binaire.EMPTY;
        valueByLanguage[0] = "ELIMINATION DES DEPENDANCES ARRIERES";
        valueByLanguage[1] = "ELIMINATION OF BACKWARD DEPENDENCIES";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeBinaire);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Permet de renumeroter les noeuds du maillage de maniere a eliminer les" + "\ndependances arrieres et autoriser ainsi le forcage de la vectorisation" + "\nlorsque les calculs TELEMAC 2D son effectues sur CRAY." + "\nAttention : un nombre minimum d'environ 500 noeuds est requis pour" + "\nl'activation de cette option.";
        valueByLanguage[1] = "Provides for renumbering of the mesh nodes in order to eliminate the" + "\nbackward dependencies, thereby enabling a forced vectorisation when" + "\nthe TELEMAC 2D computations are made on a CRAY." + "\nWarning: about 500 nodes is the least number required for activating" + "\nthis option.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "true";
        valueByLanguage[1] = "true";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[13] = entiteSimple.getImmutable();
        typeBinaire = DicoDataType.Binaire.EMPTY;
        valueByLanguage[0] = "DECOUPAGE DES TRIANGLES EN QUATRE";
        valueByLanguage[1] = "CUTTING ELEMENTS IN FOUR";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeBinaire);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Decoupe chaque element du mayage en quatre elements homothetiques" + "\nen joignant les milieux des aretes.";
        valueByLanguage[1] = "Cuts every element of the mesh in four homothetic elements" + "\nby joigning the middle points of each side.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "false";
        valueByLanguage[1] = "false";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[14] = entiteSimple.getImmutable();
        typeBinaire = DicoDataType.Binaire.EMPTY;
        valueByLanguage[0] = "BATHYMETRIE DANS LE FICHIER UNIVERSEL";
        valueByLanguage[1] = "BATHYMETRY IN THE UNIVERSAL FILE";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeBinaire);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Permet de relire la bathymetrie directement dans le fichier de " + "\nmaillage (Trigrid ou Fasttabs).";
        valueByLanguage[1] = "The bathymetry will be read in the mesh file (Trigrid or Fasttabs).";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "false";
        valueByLanguage[1] = "false";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[15] = entiteSimple.getImmutable();
        typeBinaire = DicoDataType.Binaire.EMPTY;
        valueByLanguage[0] = "RENUMEROTATION DES POINTS";
        valueByLanguage[1] = "NODES RENUMBERING";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeBinaire);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Permet d'utiliser le nouveau type de stockage des matrices.";
        valueByLanguage[1] = "Necessary to use the new storage scheme for the matrix.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "false";
        valueByLanguage[1] = "false";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[16] = entiteSimple.getImmutable();
        typeBinaire = DicoDataType.Binaire.EMPTY;
        valueByLanguage[0] = "CONDITIONS LIMITES DANS LE FICHIER ADDITIONNEL";
        valueByLanguage[1] = "BOUNDARY CONDITIONS IN THE ADDITIONAL FILE";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeBinaire);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Permet de relire les conditions limites dans le fichier  " + "\nadditionnel (Fasttabs).";
        valueByLanguage[1] = "The boundary condition will be read in the additional file" + "\n (Fasttabs).";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "false";
        valueByLanguage[1] = "false";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[17] = entiteSimple.getImmutable();
        typeBinaire = DicoDataType.Binaire.EMPTY;
        valueByLanguage[0] = "PROJECTION APRES EXTRACTION";
        valueByLanguage[1] = "PROJECTION AFTER EXTRACTION";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeBinaire);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Lors d'une extraction de maillage suivant un polygone, projette ou" + "\nnon le maillage extrait sur les aretes du polygone.";
        valueByLanguage[1] = "Went a mesh is extracted inside a polygon, indicates whether the mesh" + "\nshould be projected through the faces of the polygon or not.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "true";
        valueByLanguage[1] = "true";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[18] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        valueByLanguage[0] = "USER";
        valueByLanguage[1] = "USER";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(3);
        valueByLanguage[0] = "Userid de l'utilisateur." + "\nOption non activee sur une station de travail";
        valueByLanguage[1] = "User's Userid. Option not implemented on a workstation.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, GENERALITES";
        valueByLanguage[1] = "INPUT-OUTPUT, INFORMATION";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        entites[19] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        valueByLanguage[0] = "MOT DE PASSE";
        valueByLanguage[1] = "PASSWORD";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(3);
        valueByLanguage[0] = "Mot de passe associe. Option non activee sur une station de travail.";
        valueByLanguage[1] = "Password. Option not implemented on a workstation.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, GENERALITES";
        valueByLanguage[1] = "INPUT-OUTPUT, INFORMATION";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        entites[20] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        typeChaine.setFileType(true);
        valueByLanguage[0] = "FICHIER FORTRAN";
        valueByLanguage[1] = "FORTRAN FILE";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Nom du fichier FORTRAN a soumettre." + "\nIl ne sert a priori qu'a dimensionner les tableaux utilises par" + "\nSTBTEL, mais peut contenir des sous-programmes modifies ou propres a" + "\nl'utilisateur.";
        valueByLanguage[1] = "Name of FORTRAN file to be entered." + "\nIt is a priori only designed for dimensioning the arrays that are" + "\nused by STBTEL, but it may contain either modified or user-written" + "\nsubroutines.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, FICHIERS";
        valueByLanguage[1] = "INPUT-OUTPUT, FILES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "DEFAUT";
        valueByLanguage[1] = "DEFAUT";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[21] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        typeChaine.setFileType(true);
        valueByLanguage[0] = "FICHIER DES PARAMETRES";
        valueByLanguage[1] = "STEERING FILE";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Nom du fichier contenant les references des fichiers et les options" + "\ndu calcul a realiser.";
        valueByLanguage[1] = "Name of the file that contains the file references and of options for" + "\nthe computation to be made.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, FICHIERS";
        valueByLanguage[1] = "INPUT-OUTPUT, FILES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        entites[22] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        typeChaine.setFileType(true);
        valueByLanguage[0] = "FICHIER UNIVERSEL";
        valueByLanguage[1] = "UNIVERSAL FILE";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Nom du fichier construit par le mailleur, a partir duquel STBTEL va" + "\ntravailler.";
        valueByLanguage[1] = "Name of the file created by the mesh generator, and from which STBTEL" + "\nwill work.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, FICHIERS";
        valueByLanguage[1] = "INPUT-OUTPUT, FILES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        entites[23] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        choiceKeys = null;
        choiceValues = new String[][] { { "SUPERTAB4", "SUPERTAB6", "MASTER2", "SIMAIL", "SELAFIN", "TRIGRID", "FASTTABS" }, { "SUPERTAB4", "SUPERTAB6", "MASTER2", "SIMAIL", "SELAFIN", "TRIGRID", "FASTTABS" } };
        typeChaine.setChoice(choiceValues[languageIndex_], choiceKeys);
        valueByLanguage[0] = "MAILLEUR";
        valueByLanguage[1] = "MESH GENERATOR";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Nom du mailleur utilise pour la creation du FICHIER UNIVERSEL. Ce peut" + "\netre :" + "\n   - SUPERTAB6 (version 6 du mailleur SUPERTAB)," + "\n   - SUPERTAB4 (version 4 du mailleur SUPERTAB)," + "\n   - MASTER2 (version 2 du mailleur MASTER-SERIES)," + "\n   - SIMAIL," + "\n   - SELAFIN (afin de modifier un maillage deja utilise, comme pour :" + "\n              - interpoler de nouveau fonds" + "\n              - eliminer des dependances arrieres" + "\n              - coupe triangles surcontraints)," + "\n   - TRIGRID," + "\n   - FASTTABS.";
        valueByLanguage[1] = "Name of the mesh generator used for preparing the UNIVERSAL FILE. It" + "\nwill be selected among the following:" + "\n   - SUPERTAB6 (version 6 of SUPERTAB mesh generator)," + "\n   - SUPERTAB4 (version 4 of SUPERTAB mesh generator)," + "\n   - MASTER2 (version 2 of MASTER-SERIES mesh generator)," + "\n   - SIMAIL," + "\n   - SELAFIN (in order to modify a mesh already used, as for example :" + "\n              - to interpolate a new bathymetry" + "\n              - to eliminate backward dependencies" + "\n              - to cut overstressed triangles )," + "\n   - TRIGRID," + "\n   - FASTTABS.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "MAILLEUR";
        valueByLanguage[1] = "MESH GENERATOR";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "MASTER2";
        valueByLanguage[1] = "MASTER2";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[24] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        typeChaine.setFileType(true);
        valueByLanguage[0] = "FICHIER DE GEOMETRIE POUR TELEMAC";
        valueByLanguage[1] = "GEOMETRY FILE FOR TELEMAC";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Nom du fichier qui contiendra le maillage mis au format SELAFIN, et" + "\nqui servira pour les calculs TELEMAC 2D.";
        valueByLanguage[1] = "Name of the file that will contain the mesh data to SELAFIN format," + "\nand to be used in TELEMAC 2D computations.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, FICHIERS";
        valueByLanguage[1] = "INPUT-OUTPUT, FILES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        entites[25] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        choiceKeys = null;
        choiceValues = new String[][] { { "STD", "IBM", "I3E" }, { "STD", "IBM", "I3E" } };
        typeChaine.setChoice(choiceValues[languageIndex_], choiceKeys);
        valueByLanguage[0] = "STANDARD DE BINAIRE";
        valueByLanguage[1] = "BINARY STANDARD";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(2);
        valueByLanguage[0] = "Adapte l'ecriture du FICHIER DE GEOMETRIE POUR TELEMAC au standard" + "\nbinaire choisi pour celui-ci. Ce peut etre :" + "\n   - IBM : binaire IBM," + "\n   - I3E : binaire HP," + "\n   - STD : prend par defaut le binaire de la machine sur laquelle" + "\n           l'utilisateur travaille. Ce sont alors des ordres READ et" + "\n           WRITE normaux qui sont utilises.";
        valueByLanguage[1] = "Matches the writing of the .i.GEOMETRY FILE FOR TELEMAC; to the binary" + "\nstandard chosen for the latter. It will be selected among the" + "\nfollowing :" + "\n   - IBM   : IBM binary," + "\n   - I3E   : HP binary," + "\n   - STD   : takes by default the binary on the computer with which" + "\n             the user is working. The normal READ and WRITE commands" + "\n             are then used.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, FICHIERS";
        valueByLanguage[1] = "INPUT-OUTPUT, FILES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "STD";
        valueByLanguage[1] = "STD";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[26] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        typeChaine.setFileType(true);
        valueByLanguage[0] = "FICHIER DES CONDITIONS AUX LIMITES";
        valueByLanguage[1] = "BOUNDARY CONDITIONS FILE";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Nom du fichier qui contiendra les conditions aux limites lues dans le" + "\nFICHIER UNIVERSEL, et qui servira pour les calculs TELEMAC 2D." + "\n(les conditions aux limites sont definies lors de la realisation du" + "\nmaillage, au moyen de couleurs affectees aux noeuds des frontieres du" + "\ndomaine de calcul).";
        valueByLanguage[1] = "Name of the file that will contain the boundary conditions being read" + "\nfrom the UNIVERSAL FILE, and to be used in TELEMAC 2D computations." + "\n(The boundary conditions are defined when preparing the meshes," + "\nthrough colours that are allotted to the nodes of the computation" + "\ndomain boundaries).";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, FICHIERS";
        valueByLanguage[1] = "INPUT-OUTPUT, FILES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        entites[27] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        typeChaine.setFileType(true);
        valueByLanguage[0] = "FICHIERS DES FONDS";
        valueByLanguage[1] = "BOTTOM TOPOGRAPHY FILES";
        entiteTableau = new DicoEntite.Tableau(valueByLanguage[languageIndex_], typeChaine);
        entiteTableau.setTaille(5);
        entiteTableau.setNiveau(1);
        valueByLanguage[0] = "Nom du fichier contenant la bathymetrie (au standard SINUSX), qui" + "\nservira pour la definition, par interpolation, de la profondeur en" + "\nchaque point du maillage.";
        valueByLanguage[1] = "Name of the file containing the bathymetric points (to SINUSX" + "\nstandard), to be used, through interpolation, for defining the depth" + "\nat each point of the mesh.";
        entiteTableau.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, FICHIERS";
        valueByLanguage[1] = "INPUT-OUTPUT, FILES";
        entiteTableau.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = ";;";
        valueByLanguage[1] = ";;";
        entiteTableau.setDefautValue(valueByLanguage[languageIndex_]);
        entites[28] = entiteTableau.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        valueByLanguage[0] = "TEMPS MACHINE";
        valueByLanguage[1] = "CPU TIME";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(3);
        valueByLanguage[0] = "Temps CPU (en secondes) alloue pour la realisation du calcul." + "\nAttention, il s'agit bien d'une chaine de caracteres." + "\nOption non activee sur une station de travail.";
        valueByLanguage[1] = "CPU time (in seconds) allotted for making the computation. It should" + "\nbe noted it is a string of characters. Option not implemented on a" + "\nworkstation";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, GENERALITES";
        valueByLanguage[1] = "INPUT-OUTPUT, INFORMATION";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "10";
        valueByLanguage[1] = "10";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[29] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        valueByLanguage[0] = "PLACE MEMOIRE";
        valueByLanguage[1] = "MEMORY SPACE";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(3);
        valueByLanguage[0] = "Place memoire sur CRAY, en mots de 8 octets, reservee en machine pour" + "\nla realisation du calcul. Une estimation de cette valeur est donnee en" + "\ntete du listing.";
        valueByLanguage[1] = "Memory space on CRAY, in 8-byte words, reserved in computer for making" + "\nthe computation. An assessment of this value is provided at the head" + "\nof the listing. Option not implemented on a workstation.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, GENERALITES";
        valueByLanguage[1] = "INPUT-OUTPUT, INFORMATION";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "1500000W";
        valueByLanguage[1] = "1500000W";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[30] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        valueByLanguage[0] = "BIBLIOTHEQUES";
        valueByLanguage[1] = "BIBLIOTHEQUES";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(-3);
        valueByLanguage[0] = "";
        valueByLanguage[1] = "";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, GENERALITES";
        valueByLanguage[1] = "INPUT-OUTPUT, INFORMATION";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        entites[31] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        valueByLanguage[0] = "NUMERO DE VERSION";
        valueByLanguage[1] = "RELEASE";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(2);
        valueByLanguage[0] = "Numeros de version respectivement des bibliotheques" + "\n        stbtel,damo,util,hp";
        valueByLanguage[1] = "Version numbers of STBTEL, DAMO, UTIL, HP libraries, respectively.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, GENERALITES";
        valueByLanguage[1] = "INPUT-OUTPUT, INFORMATION";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "V5P6,V5P6,V5P6,V5P6,V5P6";
        valueByLanguage[1] = "V5P6,V5P6,V5P6,V5P6,V5P6";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[32] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        typeChaine.setFileType(true);
        valueByLanguage[0] = "FICHIER ADDITIONNEL DU MAILLEUR";
        valueByLanguage[1] = "MESH ADDITIONAL DATA FILE";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Nom du fichier additionnel. Ce fichier a une signification " + "\ndifferente en fonction du mailleur choisi." + "\nTrigrid : Fichier contenant la table de connectivites (obligatoire)." + "\nFasttabs : Fichier contenant les conditions limites (optionnel).";
        valueByLanguage[1] = "Name of the additionql file. The meaning of this file depend on the" + "\ntype of mesh generator." + "\nTrigrid : containing the connectivity table built (mandatory)." + "\nFasttabs  : boundary condition file built by Fasttabs (optional).";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, FICHIERS";
        valueByLanguage[1] = "INPUT-OUTPUT, FILES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        entites[33] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        valueByLanguage[0] = "DICTIONNAIRE";
        valueByLanguage[1] = "DICTIONARY";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(-3);
        valueByLanguage[0] = "Dictionnaire des mots cles.";
        valueByLanguage[1] = "Key word dictionary.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, GENERALITES";
        valueByLanguage[1] = "INPUT-OUTPUT, INFORMATION";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "stbtelv5p5.dico";
        valueByLanguage[1] = "stbtelv5p5.dico";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[34] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        valueByLanguage[0] = "NUMERO DE COMPTE";
        valueByLanguage[1] = "ACCOUNT";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeChaine);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Numero de compte d'imputation des calculs sur CRAY";
        valueByLanguage[1] = "accounting";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, GENERALITES";
        valueByLanguage[1] = "INPUT-OUTPUT, INFORMATION";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        entites[35] = entiteSimple.getImmutable();
        typeReel = new DicoDataType.Reel();
        typeReel.setControle(0.0);
        valueByLanguage[0] = "SEUIL DE SECHERESSE";
        valueByLanguage[1] = "DRY LIMIT";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeReel);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Fixe la valeur du seuil (en metre) de hauteur d'eau en dessous " + "\nduquel un noeud est considere comme sec.";
        valueByLanguage[1] = "Limit of water depth value (in meter) under which the node is " + "\nconsidered as dry node.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "0.1";
        valueByLanguage[1] = "0.1";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[36] = entiteSimple.getImmutable();
        typeBinaire = DicoDataType.Binaire.EMPTY;
        valueByLanguage[0] = "ELIMINATION DES ELEMENTS SECS";
        valueByLanguage[1] = "DRY ELEMENTS ELIMINATION";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeBinaire);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Lors du traitement d'un fichier de resultats issu de TELEMAC-2D," + "\npermet d'activer l'elimination des elements secs.";
        valueByLanguage[1] = "When using a TELEMAC-2D results file, this keyword activates the" + "\ndry elements elimination.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "false";
        valueByLanguage[1] = "false";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[37] = entiteSimple.getImmutable();
        typeBinaire = DicoDataType.Binaire.EMPTY;
        valueByLanguage[0] = "ELIMINATION DES ELEMENTS PARTIELLEMENT SECS";
        valueByLanguage[1] = "PARTIALLY DRY ELEMENTS ELIMINATION";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeBinaire);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Lors de l'elimination des elements secs, permet de specifier si" + "\non traite les elements parteillement secs (au moins un noeud sec).";
        valueByLanguage[1] = "When removing dry elements, specify if the partially dry elements are" + "\ntreated (at least one dry node).";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "false";
        valueByLanguage[1] = "false";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[38] = entiteSimple.getImmutable();
        typeBinaire = DicoDataType.Binaire.EMPTY;
        valueByLanguage[0] = "STOCKAGE DE TOUS LES PAS DE TEMPS";
        valueByLanguage[1] = "STORAGE OF ALL TIME STEPS";
        entiteSimple = new DicoEntite.Simple(valueByLanguage[languageIndex_], typeBinaire);
        entiteSimple.setNiveau(1);
        valueByLanguage[0] = "Lors du traitement d'elimination des elements secs, permet de " + "\nspecifier si on restocke tous les pas de temps dans le fichier" + "\nresultat";
        valueByLanguage[1] = "When treating dry elements elimination, specify that" + "\nall time steps are to be stored in the results file.";
        entiteSimple.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "GENERALITES";
        valueByLanguage[1] = "GENERALITIES";
        entiteSimple.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "false";
        valueByLanguage[1] = "false";
        entiteSimple.setDefautValue(valueByLanguage[languageIndex_]);
        entites[39] = entiteSimple.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        valueByLanguage[0] = "DESCRIPTION DES LIBRAIRIES";
        valueByLanguage[1] = "DESCRIPTION OF LIBRARIES";
        entiteTableau = new DicoEntite.Tableau(valueByLanguage[languageIndex_], typeChaine);
        entiteTableau.setTaille(5);
        entiteTableau.setNiveau(1);
        valueByLanguage[0] = "Description des librairies de STBTEL";
        valueByLanguage[1] = "Description of STBTEL LIBRARIES";
        entiteTableau.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, GENERALITES";
        valueByLanguage[1] = "INPUT-OUTPUT, INFORMATION";
        entiteTableau.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "stbtel|stbtel_VVV|PPP|stbtelMMMVVV.LLL;bief|bief_VVV|PPP|biefMMMVVV.LLL;damocles|damo_VVV|PPP|damoMMMVVV.LLL;paravoid|paravoid_VVV|PPP|paravoidMMMVVV.LLL;special|special_VVV|PPP|specialMMMVVV.LLL";
        valueByLanguage[1] = "stbtel|stbtel_VVV|PPP|stbtelMMMVVV.LLL;bief|bief_VVV|PPP|biefMMMVVV.LLL;damocles|damo_VVV|PPP|damoMMMVVV.LLL;paravoid|paravoid_VVV|PPP|paravoidMMMVVV.LLL;special|special_VVV|PPP|specialMMMVVV.LLL";
        entiteTableau.setDefautValue(valueByLanguage[languageIndex_]);
        entites[40] = entiteTableau.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        valueByLanguage[0] = "EXECUTABLE PAR DEFAUT";
        valueByLanguage[1] = "DEFAULT EXECUTABLE";
        entiteTableau = new DicoEntite.Tableau(valueByLanguage[languageIndex_], typeChaine);
        entiteTableau.setTaille(1);
        entiteTableau.setNiveau(1);
        valueByLanguage[0] = "Executable par defaut de STBTEL";
        valueByLanguage[1] = "Default executable for STBTEL";
        entiteTableau.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, GENERALITES";
        valueByLanguage[1] = "INPUT-OUTPUT, INFORMATION";
        entiteTableau.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "stbtel|stbtel_VVV|PPP|stbtelMMMVVV.exe";
        valueByLanguage[1] = "stbtel|stbtel_VVV|PPP|stbtelMMMVVV.exe";
        entiteTableau.setDefautValue(valueByLanguage[languageIndex_]);
        entites[41] = entiteTableau.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        valueByLanguage[0] = "EXECUTABLE PARALLELE PAR DEFAUT";
        valueByLanguage[1] = "DEFAULT PARALLEL EXECUTABLE";
        entiteTableau = new DicoEntite.Tableau(valueByLanguage[languageIndex_], typeChaine);
        entiteTableau.setTaille(1);
        entiteTableau.setNiveau(1);
        valueByLanguage[0] = "Executable parallele par defaut de Stbtel";
        valueByLanguage[1] = "Default parallel executable for Stbtel";
        entiteTableau.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "ENTREES-SORTIES, GENERALITES";
        valueByLanguage[1] = "INPUT-OUTPUT, INFORMATION";
        entiteTableau.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "stbtel|stbtel_VVV|PPP|stbtelMMMVVV_MP.exe";
        valueByLanguage[1] = "stbtel|stbtel_VVV|PPP|stbtelMMMVVV_MP.exe";
        entiteTableau.setDefautValue(valueByLanguage[languageIndex_]);
        entites[42] = entiteTableau.getImmutable();
        typeChaine = new DicoDataType.Chaine();
        valueByLanguage[0] = "LISTE DES FICHIERS";
        valueByLanguage[1] = "LIST OF FILES";
        entiteTableau = new DicoEntite.Tableau(valueByLanguage[languageIndex_], typeChaine);
        entiteTableau.setTaille(8);
        entiteTableau.setNiveau(1);
        valueByLanguage[0] = "Noms des fichiers exploites par le code";
        valueByLanguage[1] = "Noms des fichiers exploites par le code";
        entiteTableau.setAide(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "FICHIERS";
        valueByLanguage[1] = "FILES";
        entiteTableau.setRubrique(valueByLanguage[languageIndex_]);
        valueByLanguage[0] = "FICHIER UNIVERSEL;FICHIER DE GEOMETRIE POUR TELEMAC;FICHIER DES CONDITIONS AUX LIMITES;FICHIER ADDITIONNEL DU MAILLEUR;FICHIERS DES FONDS;FICHIER FORTRAN;FICHIER DES PARAMETRES;DICTIONNAIRE";
        valueByLanguage[1] = "UNIVERSAL FILE;GEOMETRY FILE FOR TELEMAC;BOUNDARY CONDITIONS FILE;MESH ADDITIONAL DATA FILE;BOTTOM TOPOGRAPHY FILES;FORTRAN FILE;STEERING FILE;DICTIONARY";
        entiteTableau.setDefautValue(valueByLanguage[languageIndex_]);
        entites[43] = entiteTableau.getImmutable();
        return entites;
    }
}
