package net.sourceforge.purrpackage.parsing;

import java.io.File;
import java.io.FilenameFilter;
import java.text.MessageFormat;
import java.text.ParseException;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import net.sourceforge.cobertura.coveragedata.CoverageDataFileHandler;
import net.sourceforge.cobertura.coveragedata.ProjectData;
import net.sourceforge.purrpackage.recording.PropDb;

/**
 * Reads the coverage files generated by the recording package into a array
 * of {@link PackageAndProjectData} containing successively more coverage 
 * data resulting from running test in the given package.
 * 
 * Filtering and interpreting file names and parsing the Cobertura data is in
 * this classes scope, as is loading the purrrpackage.db files. Understanding
 * the relationship between those files is out of scope, in particular the
 * conventions about the first and last files and the .db file.
 */
public class CoverageDirectoryReader {

    PropDb database = new PropDb();

    public PropDb getDatabase() {
        return database;
    }

    ProjectData globalCoverageData;

    SortedMap<Integer, PackageAndProjectData> indexedPackageData = new TreeMap<Integer, PackageAndProjectData>();

    public SortedMap<Integer, PackageAndProjectData> getIndexedPackageData() {
        return indexedPackageData;
    }

    public void loadDirectory(File directory) {
        for (File f : findMatchingFiles(directory)) {
            try {
                loadSpeciallyNamedCoverageFile(f);
                loadedFiles.add(f.getName());
            } catch (Exception e) {
                unloadableFiles.put(f.getName(), e);
            }
        }
        File cf = new File(directory, "cobertura.ser");
        try {
            globalCoverageData = readCoverageFile(cf);
            loadedFiles.add(cf.getName());
            try {
                database.read(directory);
                if (database.getPackageName() == null) {
                    throw new RuntimeException("No packageName in purrpackage.db");
                }
                PackageAndProjectData ppd = new PackageAndProjectData(globalCoverageData, database.getPackageName(), cf);
                int key = indexedPackageData.lastKey() + 1;
                indexedPackageData.put(key, ppd);
            } catch (Exception e) {
                unloadableFiles.put(PropDb.FILE_NAME, e);
            }
        } catch (Exception e) {
            unloadableFiles.put(cf.getName(), e);
        }
    }

    public Set<String> getLoadedFiles() {
        return loadedFiles;
    }

    public Map<String, Exception> getUnloadableFiles() {
        return unloadableFiles;
    }

    public static class FileNameFormatException extends RuntimeException {

        public FileNameFormatException(String message) {
            super(message);
        }

        private static final long serialVersionUID = 1L;
    }

    private static final String FILE_NAME_TAIL = "-cobertura.ser";

    static final String FILE_NAME_FORMAT = "{0}-{1}" + FILE_NAME_TAIL;

    MessageFormat makeFormat() {
        return new MessageFormat(FILE_NAME_FORMAT);
    }

    Set<String> loadedFiles = new LinkedHashSet<String>();

    Map<String, Exception> unloadableFiles = new LinkedHashMap<String, Exception>();

    Object[] parseNameAndIndexFromFileName(String specialFileName) {
        try {
            Object[] x = makeFormat().parse(specialFileName);
            return x;
        } catch (ParseException e) {
            throw new FileNameFormatException("Could not parse " + specialFileName + ": " + e.getMessage());
        }
    }

    void loadSpeciallyNamedCoverageFile(File x) {
        Object[] pair = parseNameAndIndexFromFileName(x.getName());
        Integer index = Integer.valueOf((String) pair[1]);
        ProjectData data = readCoverageFile(x);
        PackageAndProjectData ppd = new PackageAndProjectData(data, (String) pair[0], x);
        indexedPackageData.put(index, ppd);
    }

    public static ProjectData readCoberturaCoverageFile(File x) {
        ProjectData data = CoverageDataFileHandler.loadCoverageData(x);
        if (data == null) {
            throw new RuntimeException("File " + x.getName() + " is corrupt.");
        }
        return data;
    }

    ProjectData readCoverageFile(File x) {
        return readCoberturaCoverageFile(x);
    }

    class MyFileNameFilter implements FilenameFilter {

        MessageFormat format = makeFormat();

        @Override
        public boolean accept(File dir, String name) {
            boolean result = false;
            try {
                Object x = parseNameAndIndexFromFileName(name)[0];
                if (x instanceof String && ((String) x).length() > 0) {
                    result = true;
                }
            } catch (FileNameFormatException e) {
            }
            return result;
        }
    }

    List<File> findMatchingFiles(File directory) {
        return Arrays.asList(directory.listFiles(new MyFileNameFilter()));
    }

    public ProjectData getGlobalCoverageData() {
        return globalCoverageData;
    }
}
