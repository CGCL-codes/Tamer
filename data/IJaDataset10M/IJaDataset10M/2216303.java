package owltools.ontologyrelease;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Properties;
import java.util.Set;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.log4j.Logger;

/**
 * Provide a staging directory for the release runners. 
 */
abstract class ReleaseRunnerFileTools {

    private static final String EXTENSIONS_DIRECTORY_NAME = "extensions";

    private static final String SUBSETS_DIRECTORY_NAME = "subsets";

    private static final String RELEASE_DIRECTORY_NAME = "releases";

    private static final String STAGING_DIRECTORY_NAME = "staging";

    private static final String STAGING_DIRECTORY_LOCK_FILE_NAME = ".lock";

    private static final String VERSION_INFO_FILE_NAME = "VERSION-INFO";

    private final File base;

    private final File staging;

    private final File lockFile;

    private final Logger logger;

    private final boolean useReleasesFolder;

    /**
	 * @param base directory
	 * @param logger
	 * @param useReleasesFolder 
	 * @throws IOException
	 */
    ReleaseRunnerFileTools(File base, Logger logger, boolean useReleasesFolder) throws IOException {
        super();
        this.logger = logger;
        this.useReleasesFolder = useReleasesFolder;
        this.base = base;
        checkFolder(base);
        staging = new File(base, STAGING_DIRECTORY_NAME);
        checkFolder(staging);
        lockFile = new File(staging, STAGING_DIRECTORY_LOCK_FILE_NAME);
        boolean success = lockFile.createNewFile();
        if (!success) {
            if (!forceLock(lockFile)) {
                throw new IOException("Could not lock staging directory via lock file: " + lockFile.getAbsolutePath());
            }
            FileUtils.touch(lockFile);
        }
        logger.info("Using staging folder for release manager: " + staging.getAbsolutePath());
        cleanDirectory(staging, STAGING_DIRECTORY_LOCK_FILE_NAME);
        File subsets = new File(staging, SUBSETS_DIRECTORY_NAME);
        checkFolder(subsets);
        File extensions = new File(staging, EXTENSIONS_DIRECTORY_NAME);
        checkFolder(extensions);
    }

    boolean forceLock(File file) {
        return false;
    }

    BufferedWriter getWriter(String fileName) throws IOException {
        return new BufferedWriter(new OutputStreamWriter(getOutputSteam(fileName), "UTF-8"));
    }

    OutputStream getOutputSteam(String fileName) throws IOException {
        checkNew(new File(base, fileName));
        File stagingFile = new File(staging, fileName);
        stagingFile.getParentFile().mkdirs();
        logger.info("saving to " + stagingFile.getAbsolutePath());
        return new FileOutputStream(stagingFile);
    }

    /**
	 * Set the ontology version id for a particular release. 
	 * If null, the current date is used.
	 * 
	 * @param version version if available or null
	 * @return version
	 * @throws IOException
	 */
    String buildVersionInfo(String version) throws IOException {
        checkNew(new File(base, VERSION_INFO_FILE_NAME));
        File versionFile = checkNew(new File(staging, VERSION_INFO_FILE_NAME));
        logger.info("Creating version file: " + versionFile.getAbsolutePath());
        FileOutputStream outputStream = null;
        try {
            outputStream = new FileOutputStream(versionFile);
            String comments = null;
            if (version == null) {
                version = OntologyVersionTools.format(new Date());
                comments = "Auto Generated Version Number. Please do not edit this file.";
            }
            Properties prop = new Properties();
            prop.setProperty("version", version);
            prop.store(outputStream, comments);
            return version;
        } finally {
            IOUtils.closeQuietly(outputStream);
        }
    }

    private String readVersionInfo() {
        File versionFile = new File(base, VERSION_INFO_FILE_NAME);
        if (!versionFile.exists() || !versionFile.isFile() || !versionFile.canRead()) {
            return null;
        }
        FileInputStream inputStream = null;
        try {
            inputStream = new FileInputStream(versionFile);
            Properties prop = new Properties();
            prop.load(inputStream);
            return prop.getProperty("version");
        } catch (IOException e) {
            logger.info("Could not load old version info from file: " + versionFile.getAbsolutePath(), e);
        } finally {
            IOUtils.closeQuietly(inputStream);
        }
        return null;
    }

    /**
	 * Check whether the file is new. Throw an {@link IOException}, 
	 * if the file already exists and {@link OortConfiguration#isAllowFileOverWrite()} 
	 * is not set to true.
	 * 
	 * @param file
	 * @return file return the same file to allow chaining with other operations
	 * @throws IOException
	 */
    abstract File checkNew(File file) throws IOException;

    /**
	 * Create a release with the files in the staging directory.
	 * Skip the release, if the previous release has equal content.
	 * 
	 * @param version
	 * @return true, if the commit and copy was done.
	 * @throws IOException
	 */
    boolean commit(String version) throws IOException {
        try {
            if (useReleasesFolder) {
                File releasesFolder = new File(base, RELEASE_DIRECTORY_NAME);
                checkFolder(releasesFolder);
                String oldVersion = readVersionInfo();
                if (oldVersion != null) {
                    File oldVersionFolder = new File(releasesFolder, oldVersion);
                    if (oldVersionFolder.exists() && oldVersionFolder.isDirectory()) {
                        boolean equals = checkOldVersion(oldVersionFolder);
                        if (equals) {
                            logger.info("Skipping release, as the newly generated files do not differ from last release.");
                            return false;
                        }
                    }
                }
                File versionFolder = new File(releasesFolder, version);
                checkFolder(versionFolder);
                copyContents(staging, versionFolder, STAGING_DIRECTORY_LOCK_FILE_NAME);
            }
            copyContents(staging, base, STAGING_DIRECTORY_LOCK_FILE_NAME);
            return true;
        } finally {
            FileUtils.cleanDirectory(staging);
        }
    }

    private boolean checkOldVersion(File oldVersionFolder) throws IOException {
        FileFilter filter = createIngoreFilter(STAGING_DIRECTORY_LOCK_FILE_NAME, VERSION_INFO_FILE_NAME);
        File[] oldFiles = oldVersionFolder.listFiles(filter);
        File[] stagingFiles = staging.listFiles(filter);
        if (oldFiles.length == stagingFiles.length) {
            Arrays.sort(oldFiles);
            Arrays.sort(stagingFiles);
            boolean equals = true;
            for (int i = 0; i < stagingFiles.length && equals; i++) {
                final File oldFile = oldFiles[i];
                final File stagingFile = stagingFiles[i];
                String oldName = oldFile.getName();
                equals = oldName.equals(stagingFile.getName());
                if (equals) {
                    if (!oldFile.isDirectory() && !stagingFile.isDirectory()) {
                        if (oldName.toLowerCase().endsWith(".owl")) {
                            continue;
                        }
                        equals = FileUtils.contentEquals(oldFile, stagingFile);
                    } else {
                        if (oldFile.isDirectory() && stagingFile.isDirectory()) {
                            equals = equalsDirectory(oldFile, stagingFile);
                        } else {
                            equals = false;
                        }
                    }
                }
            }
            return equals;
        }
        return false;
    }

    private boolean equalsDirectory(File directory1, File directory2) throws IOException {
        if (FileUtils.isSymlink(directory1) || FileUtils.isSymlink(directory2)) {
            return false;
        }
        File[] files1 = directory1.listFiles();
        File[] files2 = directory2.listFiles();
        if (files1.length == 0 && files2.length == 0) {
            return true;
        }
        if (files1.length != files2.length) {
            return false;
        }
        Arrays.sort(files1);
        Arrays.sort(files2);
        boolean equals = true;
        for (int i = 0; i < files1.length && equals; i++) {
            File file1 = files1[i];
            File file2 = files2[i];
            if (file1.isFile() && file2.isFile()) {
                equals = FileUtils.contentEquals(file1, file2);
            } else {
                if (file1.isDirectory() && file2.isDirectory()) {
                    equals = equalsDirectory(file1, file2);
                } else {
                    equals = false;
                }
            }
        }
        return equals;
    }

    private void copyContents(File sourceFolder, File targetFolder, final String... ignores) throws IOException {
        FileUtils.copyDirectory(sourceFolder, targetFolder, createIngoreFilter(ignores), true);
    }

    /**
	 * Clean a directory, by deleting all files and folders in it. Retain the 
	 * top level files or folders, if their names are in the ignores array.
	 * 
	 * @param folder
	 * @param ignores
	 * @throws IOException
	 */
    private void cleanDirectory(final File folder, final String... ignores) throws IOException {
        File[] files = folder.listFiles(createIngoreFilter(ignores));
        if (files.length > 0) {
            logger.info("Cleaning folder: " + folder.getAbsolutePath());
            for (File file : files) {
                if (!FileUtils.isSymlink(file)) {
                    file.delete();
                } else {
                    FileUtils.forceDelete(file);
                }
            }
        }
    }

    private static FileFilter createIngoreFilter(final String... ignores) {
        FileFilter filter = null;
        if (ignores != null && ignores.length > 0) {
            filter = new FileFilter() {

                Set<String> names = createSet(ignores);

                public boolean accept(File pathname) {
                    return !names.contains(pathname.getName());
                }
            };
        }
        return filter;
    }

    private static <T> Set<T> createSet(T[] values) {
        if (values.length == 1) {
            return Collections.singleton(values[0]);
        }
        return new HashSet<T>(Arrays.asList(values));
    }

    static void checkFolder(File folder) throws IOException {
        FileUtils.forceMkdir(folder);
        if (!folder.exists()) {
            throw new IOException("Could not create directory: " + folder.getAbsolutePath());
        }
        if (!folder.isDirectory()) {
            throw new IOException(folder.getAbsolutePath() + " already exists, but is not a directory");
        }
        if (!folder.canWrite()) {
            throw new IOException("Can't write in directory: " + folder.getAbsolutePath());
        }
    }

    void deleteLockFile() {
        FileUtils.deleteQuietly(lockFile);
    }
}
