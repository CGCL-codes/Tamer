package org.jude.client.editor.swing.logical;

import java.awt.*;
import java.awt.datatransfer.*;
import javax.swing.*;
import java.util.*;
import java.io.*;
import javax.swing.event.*;
import org.jude.client.*;
import org.jude.client.logger.*;
import org.jude.client.db.*;
import org.jude.client.db.kb.*;
import org.jude.client.content.*;
import org.jude.client.content.autogenerated.*;
import org.jude.client.editor.*;
import org.jude.client.editor.swing.*;
import org.jude.client.editor.swing.logical.relation.*;
import org.jude.client.dataflavor.*;
import org.jude.simplelogic.*;

/**
 *  <p>
 *
 *  Display all the infos about a JudeObject using proper relation editors when
 *  they are avaible, and using an hyper-text like form in other cases. <p>
 *
 * <p> If you change this code take in consideration that it mut remain
 *     suitable for RelationBasedViewer subclass.
 *
 *  !! this is the main class that uses Relation editors, take in consideration
 *  during redesign of UI framework <p>
 *
 *  !! Complete META-KNOWLEDGE support and display all rules for type and
 *  relation description using a clickable/navigable/hypertext structure. <p>
 *
 *  !! Introduce a different order for each relation (description first, is_a
 *  later and so on..., use alphabetical for all otehr relations)
 *
 *@author     Massimo Zaniboni
 *@version    $Revision: 1.4 $
 */
public class RelationBasedEditor extends BasicLogicalSwingEditor {

    public static String editorDescription = "Edit using a hyper-text view of facts.";

    public static JudeObject editorCategory = Editor.SWING_EDITOR;

    public static Class javaContentClass = JudeObject.class;

    public static JudeObject editorType = Editor.EDITOR;

    public static JudeObject contentLogicalType = DB.id("object");

    protected JPanel mainPanel = new JPanel();

    protected SwingEditorWrapper wrapper;

    /**
     *  Constructor for the RelationBasedEditor object
     */
    public RelationBasedEditor() {
        mainPanel.setLayout(new BorderLayout());
        wrapper = new SwingEditorWrapper(this, mainPanel);
    }

    public SwingEditorWrapper getComponent() {
        return wrapper;
    }

    protected void updateView() {
        mainPanel.removeAll();
        TreeMap relationToSwingEditor = new TreeMap();
        QuerySolutions solutions = DB.get(DB.tuple(DB.var("RELATION"), DB.var("POSITION")), DB.has_all_no_private_relation__at_position(false, getLogicalContent(), DB.var("RELATION"), DB.var("POSITION")));
        Iterator it = solutions.iterator();
        while (it.hasNext()) {
            JudeObject sol = (JudeObject) it.next();
            Relation relation = DB.relation(sol.getTupleElement(0).getOid().toString());
            int position = sol.getTupleElement(1).getInteger() - 1;
            SwingEditor editor = null;
            if (position == 0) {
                editor = (SwingEditor) DB.createEditor(getLogicalContent(), relation, Editor.SWING_EDITOR, DB.getEditorType(this.getClass()));
            }
            if (editor == null) {
                RelationWithArgumentAtPosition content = new RelationWithArgumentAtPosition(relation, getLogicalContent(), position);
                editor = (SwingEditor) DB.createEditor(content, null, Editor.SWING_EDITOR, DB.getEditorType(this.getClass()));
            }
            if (editor != null) relationToSwingEditor.put(relation, editor);
        }
        JPanel box = new JPanel();
        box.setLayout(new BoxLayout(box, BoxLayout.Y_AXIS));
        it = relationToSwingEditor.values().iterator();
        while (it.hasNext()) {
            SwingEditor swingEditor = (SwingEditor) it.next();
            box.add(swingEditor.getComponent());
        }
        mainPanel.add(new JScrollPane(box), BorderLayout.CENTER);
    }
}
