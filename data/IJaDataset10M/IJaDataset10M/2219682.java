package net.sourceforge.ondex.webservice2.plugins.filter;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Writer;
import java.io.StringWriter;
import java.util.List;
import java.util.Set;
import java.util.UUID;
import javax.jws.WebMethod;
import javax.jws.WebParam;
import javax.jws.WebResult;
import net.sourceforge.ondex.args.FileArgumentDefinition;
import net.sourceforge.ondex.core.ONDEXGraph;
import net.sourceforge.ondex.filter.AbstractONDEXFilter;
import net.sourceforge.ondex.filter.FilterArguments;
import net.sourceforge.ondex.webservice2.result.WSFilterResult;
import net.sourceforge.ondex.webservice2.Executor.ExecutorRegister;
import net.sourceforge.ondex.webservice2.Exceptions.WebserviceException;
import net.sourceforge.ondex.webservice2.Exceptions.CaughtException;
import net.sourceforge.ondex.webservice2.Exceptions.GraphNotFoundException;
import net.sourceforge.ondex.webservice2.Exceptions.IllegalArguementsException;
import net.sourceforge.ondex.webservice2.Exceptions.PluginNotFoundException;
import net.sourceforge.ondex.webservice2.Exceptions.ReadOnlyException;
import net.sourceforge.ondex.webservice2.Exceptions.JobException;
import net.sourceforge.ondex.webservice2.plugins.PluginFinder;
import net.sourceforge.ondex.webservice2.plugins.PluginWS;
import net.sourceforge.ondex.workflow.model.OndexPluginInit;
import org.apache.log4j.Logger;

/**
* AutoGenerated
* @author Christian Brenninkmeijer
*/
public class FilterAuto extends PluginWS {

    private static final Logger logger = Logger.getLogger(FilterAuto.class);

    public FilterAuto() throws CaughtException {
        super();
    }

    @WebMethod(exclude = true)
    private AbstractONDEXFilter getFilter(String name) throws PluginNotFoundException, CaughtException {
        PluginFinder pluginFinder = PluginFinder.getInstance();
        return pluginFinder.getFilter(name);
    }

    /**
     * Retrieves inforamtion about the available filter.
     *
     * @return Set of the ids of the filter
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public Set<String> getFilterNames() throws CaughtException {
        logger.info("get filter called");
        PluginFinder pluginFinder = PluginFinder.getInstance();
        return pluginFinder.getFilterNames();
    }

    /**
     * Returns information about the requested filter.
     *
     * @param name Name of the filter to get info for.
     * @return info on the requested mapping
     * @throws PluginNotFoundException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public String getFilterInfo(@WebParam(name = "name") String name) throws PluginNotFoundException, CaughtException {
        logger.info("get filter info called with " + name);
        AbstractONDEXFilter filter = getFilter(name);
        return getInfo(filter);
    }

    @WebMethod(exclude = true)
    private FilterArguments createArguements(AbstractONDEXFilter filter, List<String> arguementNames, List<String> arguementValues) throws IllegalArguementsException {
        FilterArguments filterArguments = new FilterArguments(filter.getArgumentDefinitions());
        if (emptyArguements(filter, arguementNames, arguementValues)) {
            return filterArguments;
        }
        for (int i = 0; i < arguementNames.size(); i++) {
            createArguement(filter, filterArguments, arguementNames.get(i), arguementNames.get(i));
        }
        addDefaultArgements(filter, filterArguments);
        return filterArguments;
    }

    /**
     * Method to run Filter in accessible package.
     *
 	 *    Authors: [Ljava.lang.String;@618565
 	 *    Custodians: [Ljava.lang.String;@7cdc58
     * @param PermissionLevel
 	 *            (Optional. Defaults to :get) Minimal required permissions level
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult accessibleFilter(@WebParam(name = "PermissionLevel") java.lang.String PermissionLevel, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter accessible called");
        net.sourceforge.ondex.filter.accessible.Filter filter = new net.sourceforge.ondex.filter.accessible.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "PermissionLevel", PermissionLevel);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in accessionregex package.
     *
 	 *    Authors: [Ljava.lang.String;@1664f1a
 	 *    Custodians: [Ljava.lang.String;@1d33eef
     * @param TargetConceptClass
 	 *            (REQUIRED! No Default!) [List]Target Concept Class to filter out.
     * @param RefactorTrinaries
 	 *            (Optional. Defaults to :true) Where the qualifier of a trinary relation is out of scope create a binary relation, excluding the qualifier?
     * @param AttributeName
 	 *            (Optional. No Default.) In case of ternary relation removal, average over this AttributeName.
     * @param AccessionCV
 	 *            (REQUIRED! No Default!) [List]The Accession of CV? to apply the regex to
     * @param Regex
 	 *            (REQUIRED! No Default!) [List]The Regex which matches accessions
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult accessionregexFilter(@WebParam(name = "TargetConceptClass") java.lang.String[] TargetConceptClass, @WebParam(name = "RefactorTrinaries") java.lang.Boolean RefactorTrinaries, @WebParam(name = "AttributeName") java.lang.String AttributeName, @WebParam(name = "AccessionCV") java.lang.String[] AccessionCV, @WebParam(name = "Regex") java.lang.String[] Regex, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter accessionregex called");
        net.sourceforge.ondex.filter.accessionregex.Filter filter = new net.sourceforge.ondex.filter.accessionregex.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "TargetConceptClass", TargetConceptClass);
        createArguement(filter, arguments, "RefactorTrinaries", RefactorTrinaries);
        createArguement(filter, arguments, "AttributeName", AttributeName);
        createArguement(filter, arguments, "AccessionCV", AccessionCV);
        createArguement(filter, arguments, "Regex", Regex);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in allpairs package.
     *
 	 *    Authors: [Ljava.lang.String;@1b0d2d0
 	 *    Custodians: [Ljava.lang.String;@1e06b12
     * @param GdsWeight
 	 *            (REQUIRED! No Default!) The name of the GDS type to be used as edge weights
     * @param OnlyDirectedEdges
 	 *            (Optional. Defaults to :false) Follow edges only according to their direction?
     * @param InverseWeight
 	 *            (Optional. Defaults to :false) Takes the inverse of the GDS value as the weight. This is for probabilities or scores.
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult allpairsFilter(@WebParam(name = "GdsWeight") java.lang.String GdsWeight, @WebParam(name = "OnlyDirectedEdges") java.lang.Boolean OnlyDirectedEdges, @WebParam(name = "InverseWeight") java.lang.Boolean InverseWeight, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter allpairs called");
        net.sourceforge.ondex.filter.allpairs.Filter filter = new net.sourceforge.ondex.filter.allpairs.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "GdsWeight", GdsWeight);
        createArguement(filter, arguments, "OnlyDirectedEdges", OnlyDirectedEdges);
        createArguement(filter, arguments, "InverseWeight", InverseWeight);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in cloner package.
     *
 	 *    Authors: [Ljava.lang.String;@9576fd
 	 *    Custodians: [Ljava.lang.String;@b6e385
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult clonerFilter(@WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter cloner called");
        net.sourceforge.ondex.filter.cloner.Filter filter = new net.sourceforge.ondex.filter.cloner.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in conceptclass package.
     *
 	 *    Status: STABLE Tested March 2010 (Artem Lysenko) Works for the tutorial example - further testing necessary
 	 *    Authors: [Ljava.lang.String;@1136da6
 	 *    Custodians: [Ljava.lang.String;@83df14
     * @param TargetConceptClass
 	 *            (REQUIRED! No Default!) [List]Target Concept Class to filter out.
     * @param RefactorTrinaries
 	 *            (Optional. Defaults to :true) Where the qualifier of a trinary relation is out of scope create a binary relation, excluding the qualifier?
     * @param cv_to_filter
 	 *            (Optional. No Default.) Filter the concepts of specified CV.
     * @param acc_file
 	 *            (Optional. No Default.) A file of accessions of type cv_to_filter; one per line.
     * @param Exclude
 	 *            (Optional. Defaults to :true) Exclude concepts and relations that meet the given crieria, else if false then exclusivly include?
     * @param AttributeName
 	 *            (Optional. No Default.) In case of ternary relation removal, average over this AttributeName.
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult conceptclassFilter(@WebParam(name = "TargetConceptClass") java.lang.String[] TargetConceptClass, @WebParam(name = "RefactorTrinaries") java.lang.Boolean RefactorTrinaries, @WebParam(name = "cv_to_filter") java.lang.String cv_to_filter, @WebParam(name = "acc_file") java.lang.String acc_file, @WebParam(name = "Exclude") java.lang.Boolean Exclude, @WebParam(name = "AttributeName") java.lang.String AttributeName, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter conceptclass called");
        net.sourceforge.ondex.filter.conceptclass.Filter filter = new net.sourceforge.ondex.filter.conceptclass.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "TargetConceptClass", TargetConceptClass);
        createArguement(filter, arguments, "RefactorTrinaries", RefactorTrinaries);
        createArguement(filter, arguments, "cv_to_filter", cv_to_filter);
        createArguement(filter, arguments, "acc_file", acc_file);
        createArguement(filter, arguments, "Exclude", Exclude);
        createArguement(filter, arguments, "AttributeName", AttributeName);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in conceptclassneighbours package.
     *
     * @param Depth
 	 *            (REQUIRED! No Default!) The Depth (distance from seed in relations) to apply the filter to
     * @param ConceptClass
 	 *            (Optional. No Default.) The Concepts of ConceptClass seed the algorithm with
     * @param RelationTypeAtDepth
 	 *            (Optional. No Default.) [List]Restricts RelationType at a given depth define by an array of pairs (depth1,rtsa;depth2,rtsb...) when no concept class at a depth is specified the default is any allowed
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult conceptclassneighboursFilter(@WebParam(name = "Depth") java.lang.Integer Depth, @WebParam(name = "ConceptClass") java.lang.String ConceptClass, @WebParam(name = "RelationTypeAtDepth") java.lang.String[] RelationTypeAtDepth, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter conceptclassneighbours called");
        net.sourceforge.ondex.filter.conceptclassneighbours.Filter filter = new net.sourceforge.ondex.filter.conceptclassneighbours.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "Depth", Depth);
        createArguement(filter, arguments, "ConceptClass", ConceptClass);
        createArguement(filter, arguments, "RelationTypeAtDepth", RelationTypeAtDepth);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in context package.
     *
 	 *    Authors: [Ljava.lang.String;@1aabc29
 	 *    Custodians: [Ljava.lang.String;@2758d0
     * @param ContextID
 	 *            (REQUIRED! No Default!) The Concept ID of the Context that starts the path
     * @param ContextBoolean
 	 *            (Optional. No Default.) Defines two ContextIDs and a boolean operation (AND, OR, NOT), e.g. 11 AND 23
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult contextFilter(@WebParam(name = "ContextID") java.lang.Integer ContextID, @WebParam(name = "ContextBoolean") java.lang.String ContextBoolean, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter context called");
        net.sourceforge.ondex.filter.context.Filter filter = new net.sourceforge.ondex.filter.context.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "ContextID", ContextID);
        createArguement(filter, arguments, "ContextBoolean", ContextBoolean);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in contextconsensus package.
     *
 	 *    Authors: [Ljava.lang.String;@137e19e
 	 *    Custodians: [Ljava.lang.String;@1bd5f28
     * @param Threshold
 	 *            (Optional. Defaults to :0.5) Double value representing the share of contexts that qualify a graph element for being returned. Example: 0.5
     * @param ContextList
 	 *            (Optional. No Default.) Comma separated List of concept ids that serve as contexts, defining the set to work on. Leave blank for all.
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult contextconsensusFilter(@WebParam(name = "Threshold") java.lang.Float Threshold, @WebParam(name = "ContextList") java.lang.String ContextList, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter contextconsensus called");
        net.sourceforge.ondex.filter.contextconsensus.Filter filter = new net.sourceforge.ondex.filter.contextconsensus.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "Threshold", Threshold);
        createArguement(filter, arguments, "ContextList", ContextList);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in cv package.
     *
 	 *    Authors: [Ljava.lang.String;@1b27882
 	 *    Custodians: [Ljava.lang.String;@5b84b
     * @param CV
 	 *            (REQUIRED! No Default!) [List]A CV to include/exclude Concepts and Relations of (see Exclude param)
     * @param RefactorTrinaries
 	 *            (Optional. Defaults to :true) Where the qualifier of a trinary relation is out of scope create a binary relation, excluding the qualifier?
     * @param Exclude
 	 *            (Optional. Defaults to :true) Exclude concepts and relations that meet the given crieria, else if false then exclusivly include?
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult cvFilter(@WebParam(name = "CV") java.lang.String[] CV, @WebParam(name = "RefactorTrinaries") java.lang.Boolean RefactorTrinaries, @WebParam(name = "Exclude") java.lang.Boolean Exclude, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter cv called");
        net.sourceforge.ondex.filter.cv.Filter filter = new net.sourceforge.ondex.filter.cv.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "CV", CV);
        createArguement(filter, arguments, "RefactorTrinaries", RefactorTrinaries);
        createArguement(filter, arguments, "Exclude", Exclude);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in ec_hierarchies package.
     *
 	 *    Status: EXPERIMENTAL not tested yet
AttributeNameRequired: [Ljava.lang.String;@156f920
ConceptClassRequired: [Ljava.lang.String;@fdbc27
     * @param EC_Level
 	 *            (REQUIRED! No Default!) [List]The EC Level to filter out
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult ec_hierarchiesFilter(@WebParam(name = "EC_Level") java.lang.Integer[] EC_Level, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter ec_hierarchies called");
        net.sourceforge.ondex.filter.ec_hierarchies.Filter filter = new net.sourceforge.ondex.filter.ec_hierarchies.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "EC_Level", EC_Level);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in evidencetype package.
     *
 	 *    Custodians: [Ljava.lang.String;@4be179
     * @param EvidenceType
 	 *            (REQUIRED! No Default!) [List]EvidenceType to be taken into consideration.
     * @param RefactorTrinaries
 	 *            (Optional. Defaults to :false) Where the qualifier of a trinary relation is out of scope create a binary relation, excluding the qualifier?
     * @param Exclude
 	 *            (Optional. Defaults to :false) If true exclude concepts and/or relations from graph, else exclude all non-matching concepts and/or relations.
     * @param OnConcepts
 	 *            (Optional. Defaults to :true) If true filter on concepts, else on relations.
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult evidencetypeFilter(@WebParam(name = "EvidenceType") java.lang.String[] EvidenceType, @WebParam(name = "RefactorTrinaries") java.lang.Boolean RefactorTrinaries, @WebParam(name = "Exclude") java.lang.Boolean Exclude, @WebParam(name = "OnConcepts") java.lang.Boolean OnConcepts, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter evidencetype called");
        net.sourceforge.ondex.filter.evidencetype.Filter filter = new net.sourceforge.ondex.filter.evidencetype.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "EvidenceType", EvidenceType);
        createArguement(filter, arguments, "RefactorTrinaries", RefactorTrinaries);
        createArguement(filter, arguments, "Exclude", Exclude);
        createArguement(filter, arguments, "OnConcepts", OnConcepts);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in gdsvalue package.
     *
 	 *    Authors: [Ljava.lang.String;@1bfd53d
 	 *    Custodians: [Ljava.lang.String;@148bd9e
     * @param AttributeName
 	 *            (REQUIRED! No Default!) AttributeName to filter out.
     * @param GDSValue
 	 *            (REQUIRED! No Default!) [List]A value which will be matched against the GDSs.
     * @param Including
 	 *            (Optional. Defaults to :true) If true keep only concepts/relations that have GDS value or dont have the GDS at all. If false remove concepts that have GDS value.
     * @param ConceptClass
 	 *            (Optional. No Default.) [List]ConceptClass to filter within (only concepts within this class will be removed): default = all
     * @param RelationType
 	 *            (Optional. No Default.) [List]RelationType to filter within (only relations connected with this type will be removed): default = all
     * @param IgnoreValue
 	 *            (Optional. Defaults to :false) Removes concepts/relations that dont have the AttributeName.
     * @param Operator
 	 *            (Optional. Defaults to :=) A operator that will be used in conjuction with the gds value to determine if the object should be kept or not e.g. (>,<,=,<=,>=) NB mathmatical operators that are not "=" are only evaluated on Number Objects, all else will be false. i.e. "a" >= "b" is false but "a" >= "a" is true
     * @param Modulus
 	 *            (Optional. Defaults to :false) Treat values as modulus in comparison
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult gdsvalueFilter(@WebParam(name = "AttributeName") java.lang.String AttributeName, @WebParam(name = "GDSValue") java.lang.String[] GDSValue, @WebParam(name = "Including") java.lang.Boolean Including, @WebParam(name = "ConceptClass") java.lang.String[] ConceptClass, @WebParam(name = "RelationType") java.lang.String[] RelationType, @WebParam(name = "IgnoreValue") java.lang.Boolean IgnoreValue, @WebParam(name = "Operator") java.lang.String Operator, @WebParam(name = "Modulus") java.lang.Boolean Modulus, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter gdsvalue called");
        net.sourceforge.ondex.filter.gdsvalue.Filter filter = new net.sourceforge.ondex.filter.gdsvalue.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "AttributeName", AttributeName);
        createArguement(filter, arguments, "GDSValue", GDSValue);
        createArguement(filter, arguments, "Including", Including);
        createArguement(filter, arguments, "ConceptClass", ConceptClass);
        createArguement(filter, arguments, "RelationType", RelationType);
        createArguement(filter, arguments, "IgnoreValue", IgnoreValue);
        createArguement(filter, arguments, "Operator", Operator);
        createArguement(filter, arguments, "Modulus", Modulus);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in genomicBackend package.
     *
     * @param ChromosomeID
 	 *            (REQUIRED! No Default!) The Concept ID of the Chromosome (Chromosome)
     * @param From
 	 *            (REQUIRED! No Default!) The start position on the chromosome, e.g. 100
     * @param To
 	 *            (REQUIRED! No Default!) The stop position on the chromosome, e.g. 30000
     * @param Algorithm
 	 *            (Optional. Defaults to :Neighbourhood) Choose a specific subnetwork of interest, choices at the moment are: "NEIGHBOURHOOD", "GOA", "PATHWAY"
     * @param Keyword
 	 *            (Optional. No Default.) Concepts containing this string will get a size (GDS) of 40
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult genomicBackendFilter(@WebParam(name = "ChromosomeID") java.lang.Integer ChromosomeID, @WebParam(name = "From") java.lang.Integer From, @WebParam(name = "To") java.lang.Integer To, @WebParam(name = "Algorithm") java.lang.String Algorithm, @WebParam(name = "Keyword") java.lang.String Keyword, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter genomicBackend called");
        net.sourceforge.ondex.filter.genomic.Filter filter = new net.sourceforge.ondex.filter.genomic.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "ChromosomeID", ChromosomeID);
        createArguement(filter, arguments, "From", From);
        createArguement(filter, arguments, "To", To);
        createArguement(filter, arguments, "Algorithm", Algorithm);
        createArguement(filter, arguments, "Keyword", Keyword);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in isolateclusters package.
     *
 	 *    Authors: [Ljava.lang.String;@98f9c2
 	 *    Custodians: [Ljava.lang.String;@135707c
     * @param TargetConceptClass
 	 *            (REQUIRED! No Default!) [List]Target Concept Class to be contained in clusters.
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult isolateclustersFilter(@WebParam(name = "TargetConceptClass") java.lang.String[] TargetConceptClass, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter isolateclusters called");
        net.sourceforge.ondex.filter.isolateclusters.Filter filter = new net.sourceforge.ondex.filter.isolateclusters.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "TargetConceptClass", TargetConceptClass);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in nohits package.
     *
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult nohitsFilter(@WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter nohits called");
        net.sourceforge.ondex.filter.nohits.Filter filter = new net.sourceforge.ondex.filter.nohits.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in onepairshortestpath package.
     *
 	 *    Authors: [Ljava.lang.String;@16c14e7
 	 *    Custodians: [Ljava.lang.String;@d0726d
     * @param StartConceptID
 	 *            (REQUIRED! No Default!) The Concept ID that starts the path
     * @param EndConceptID
 	 *            (REQUIRED! No Default!) The Concept ID that ends the path
     * @param UseWeights
 	 *            (Optional. Defaults to :false) Use gds values as edge weights?
     * @param GdsWeight
 	 *            (Optional. No Default.) The name of the GDS type to be used as edge weights
     * @param OnlyDirectedEdges
 	 *            (Optional. Defaults to :false) Follow edges only according to their direction?
     * @param InverseWeight
 	 *            (Optional. Defaults to :false) Takes the inverse of the GDS value as the weight. This is for probabilities or scores.
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult onepairshortestpathFilter(@WebParam(name = "StartConceptID") java.lang.Integer StartConceptID, @WebParam(name = "EndConceptID") java.lang.Integer EndConceptID, @WebParam(name = "UseWeights") java.lang.Boolean UseWeights, @WebParam(name = "GdsWeight") java.lang.String GdsWeight, @WebParam(name = "OnlyDirectedEdges") java.lang.Boolean OnlyDirectedEdges, @WebParam(name = "InverseWeight") java.lang.Boolean InverseWeight, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter onepairshortestpath called");
        net.sourceforge.ondex.filter.onepairshortestpath.Filter filter = new net.sourceforge.ondex.filter.onepairshortestpath.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "StartConceptID", StartConceptID);
        createArguement(filter, arguments, "EndConceptID", EndConceptID);
        createArguement(filter, arguments, "UseWeights", UseWeights);
        createArguement(filter, arguments, "GdsWeight", GdsWeight);
        createArguement(filter, arguments, "OnlyDirectedEdges", OnlyDirectedEdges);
        createArguement(filter, arguments, "InverseWeight", InverseWeight);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in pfambasedortholog package.
     *
     * @param ConfidenceThreshold
 	 *            (Optional. Defaults to :100) Threshold value for inparanoid confidence
     * @param AnnotationScoreThreshold
 	 *            (Optional. Defaults to :0.75) Threshold value for GO annotation score
     * @param PfamSetIntersectionThreshold
 	 *            (Optional. Defaults to :2) Minimal number of matching protein families for a valid orthology relation
     * @param TermDepthCutoff
 	 *            (Optional. Defaults to :4) Maximal distance between GO terms to be considered similar
     * @param GoDataDirectory
 	 *            (REQUIRED! No Default!) Data directory of go file
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult pfambasedorthologFilter(@WebParam(name = "ConfidenceThreshold") java.lang.String ConfidenceThreshold, @WebParam(name = "AnnotationScoreThreshold") java.lang.String AnnotationScoreThreshold, @WebParam(name = "PfamSetIntersectionThreshold") java.lang.String PfamSetIntersectionThreshold, @WebParam(name = "TermDepthCutoff") java.lang.String TermDepthCutoff, @WebParam(name = "GoDataDirectory") java.lang.String GoDataDirectory, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter pfambasedortholog called");
        net.sourceforge.ondex.filter.pfambasedortholog.Filter filter = new net.sourceforge.ondex.filter.pfambasedortholog.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "ConfidenceThreshold", ConfidenceThreshold);
        createArguement(filter, arguments, "AnnotationScoreThreshold", AnnotationScoreThreshold);
        createArguement(filter, arguments, "PfamSetIntersectionThreshold", PfamSetIntersectionThreshold);
        createArguement(filter, arguments, "TermDepthCutoff", TermDepthCutoff);
        createArguement(filter, arguments, "GoDataDirectory", GoDataDirectory);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in relationneighbours package.
     *
 	 *    Authors: [Ljava.lang.String;@1087359
 	 *    Custodians: [Ljava.lang.String;@1ccf342
     * @param Depth
 	 *            (REQUIRED! No Default!) The Depth (distance from seed in relations) to apply the filter to
     * @param ConceptID
 	 *            (Optional. No Default.) [List]The Concept ID to seed the algorithm with
     * @param ConceptAccession
 	 *            (Optional. No Default.) [List]Concept accession to apply relation neighbours search to all matching concepts
     * @param ConceptClass
 	 *            (Optional. No Default.) ConceptClass to look for Concepts within if accession or name has been specified
     * @param ConceptAccessionCV
 	 *            (Optional. No Default.) CV to look for Concept accession within
     * @param ConceptName
 	 *            (Optional. No Default.) [List]Concept name to apply relation neighbours search to all matching concepts
     * @param RelationTypeAtDepth
 	 *            (Optional. No Default.) [List]Restricts RelationType at a given depth define by an array of pairs (depth1,rta;depth2,rtb...) when no relation type at a depth is specified the default is any allowed. A valid relation will contain the relation in its relation type set. Where possible define the RelationType, this will be faster.
     * @param ConceptClassAtDepth
 	 *            (Optional. No Default.) [List]Restricts Concept Class at a given depth define by an array of pairs (depth1,cca;depth2,ccb...) when no concept class at a depth is specified the default is any allowed (depth refers to the relations from the seed and the concept tested is the leading connection to the edge)
     * @param ConceptCVAtDepth
 	 *            (Optional. No Default.) [List]Restricts Concept CV at a given depth define by an array of pairs (depth1,cva;depth2,cvb...) when no concept cv at a depth is specified the default is any allowed (depth refers to the relations from the seed and the concept tested is the leading connection to the edge)
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult relationneighboursFilter(@WebParam(name = "Depth") java.lang.Integer Depth, @WebParam(name = "ConceptID") java.lang.String[] ConceptID, @WebParam(name = "ConceptAccession") java.lang.String[] ConceptAccession, @WebParam(name = "ConceptClass") java.lang.String ConceptClass, @WebParam(name = "ConceptAccessionCV") java.lang.String ConceptAccessionCV, @WebParam(name = "ConceptName") java.lang.String[] ConceptName, @WebParam(name = "RelationTypeAtDepth") java.lang.String[] RelationTypeAtDepth, @WebParam(name = "ConceptClassAtDepth") java.lang.String[] ConceptClassAtDepth, @WebParam(name = "ConceptCVAtDepth") java.lang.String[] ConceptCVAtDepth, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter relationneighbours called");
        net.sourceforge.ondex.filter.relationneighbours.Filter filter = new net.sourceforge.ondex.filter.relationneighbours.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "Depth", Depth);
        createArguement(filter, arguments, "ConceptID", ConceptID);
        createArguement(filter, arguments, "ConceptAccession", ConceptAccession);
        createArguement(filter, arguments, "ConceptClass", ConceptClass);
        createArguement(filter, arguments, "ConceptAccessionCV", ConceptAccessionCV);
        createArguement(filter, arguments, "ConceptName", ConceptName);
        createArguement(filter, arguments, "RelationTypeAtDepth", RelationTypeAtDepth);
        createArguement(filter, arguments, "ConceptClassAtDepth", ConceptClassAtDepth);
        createArguement(filter, arguments, "ConceptCVAtDepth", ConceptCVAtDepth);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in relationtype package.
     *
 	 *    Authors: [Ljava.lang.String;@7691c0
 	 *    Custodians: [Ljava.lang.String;@5b02a6
     * @param TargetRelationType
 	 *            (REQUIRED! No Default!) [List]Target RelationType to filter out.
     * @param ConceptClassRestriction
 	 *            (Optional. No Default.) [List]A Concept Class Restriction as an ordered pair representing from and to Concepts in an evaluated Relation. (add the reverse compliment if direction is not important)
     * @param CVRestriction
 	 *            (Optional. No Default.) [List]A CV Restriction as an ordered pair representing from and to Concepts in an evaluated Relation. (add the reverse compliment if direction is not important)
     * @param RemoveTernaryRelations
 	 *            (Optional. Defaults to :true) Set false if ternary relations should not be removed
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult relationtypeFilter(@WebParam(name = "TargetRelationType") java.lang.String[] TargetRelationType, @WebParam(name = "ConceptClassRestriction") java.lang.String[] ConceptClassRestriction, @WebParam(name = "CVRestriction") java.lang.String[] CVRestriction, @WebParam(name = "RemoveTernaryRelations") java.lang.Boolean RemoveTernaryRelations, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter relationtype called");
        net.sourceforge.ondex.filter.relationtype.Filter filter = new net.sourceforge.ondex.filter.relationtype.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "TargetRelationType", TargetRelationType);
        createArguement(filter, arguments, "ConceptClassRestriction", ConceptClassRestriction);
        createArguement(filter, arguments, "CVRestriction", CVRestriction);
        createArguement(filter, arguments, "RemoveTernaryRelations", RemoveTernaryRelations);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in relationtypemissing package.
     *
 	 *    Authors: [Ljava.lang.String;@10aefdb
 	 *    Custodians: [Ljava.lang.String;@10948bd
     * @param TargetRelationType
 	 *            (Optional. Defaults to :) Target RelationType missing to filter out.
     * @param TargetConceptClass
 	 *            (Optional. Defaults to :) Target Concept Class to filter out.
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult relationtypemissingFilter(@WebParam(name = "TargetRelationType") java.lang.String TargetRelationType, @WebParam(name = "TargetConceptClass") java.lang.String TargetConceptClass, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter relationtypemissing called");
        net.sourceforge.ondex.filter.relationtypemissing.Filter filter = new net.sourceforge.ondex.filter.relationtypemissing.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "TargetRelationType", TargetRelationType);
        createArguement(filter, arguments, "TargetConceptClass", TargetConceptClass);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in shortestpath package.
     *
 	 *    Authors: [Ljava.lang.String;@8697ce
 	 *    Custodians: [Ljava.lang.String;@586403
     * @param StartConceptID
 	 *            (REQUIRED! No Default!) The Concept ID that starts the path
     * @param UseWeights
 	 *            (Optional. Defaults to :false) Use gds values as edge weights?
     * @param GdsWeight
 	 *            (Optional. No Default.) The name of the GDS type to be used as edge weights
     * @param OnlyDirectedEdges
 	 *            (Optional. Defaults to :false) Follow edges only according to their direction?
     * @param InverseWeight
 	 *            (Optional. Defaults to :false) Takes the inverse of the GDS value as the weight. This is for probabilities or scores.
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult shortestpathFilter(@WebParam(name = "StartConceptID") java.lang.Integer StartConceptID, @WebParam(name = "UseWeights") java.lang.Boolean UseWeights, @WebParam(name = "GdsWeight") java.lang.String GdsWeight, @WebParam(name = "OnlyDirectedEdges") java.lang.Boolean OnlyDirectedEdges, @WebParam(name = "InverseWeight") java.lang.Boolean InverseWeight, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter shortestpath called");
        net.sourceforge.ondex.filter.shortestpath.Filter filter = new net.sourceforge.ondex.filter.shortestpath.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "StartConceptID", StartConceptID);
        createArguement(filter, arguments, "UseWeights", UseWeights);
        createArguement(filter, arguments, "GdsWeight", GdsWeight);
        createArguement(filter, arguments, "OnlyDirectedEdges", OnlyDirectedEdges);
        createArguement(filter, arguments, "InverseWeight", InverseWeight);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in significance package.
     *
 	 *    Authors: [Ljava.lang.String;@10e2610
 	 *    Custodians: [Ljava.lang.String;@1e4f66a
     * @param TargetAttributeName
 	 *            (REQUIRED! No Default!) Target AttributeName to filter for significance.
     * @param Significance
 	 *            (Optional. Defaults to :15.0) A significance value to filter relations with.
     * @param Inverse
 	 *            (Optional. Defaults to :false) If set to true only relation smaller than Significance will be kept.
     * @param AbsoluteValues
 	 *            (Optional. Defaults to :false) Absolute GDS values when testing for significance
     * @param Remove_no_att
 	 *            (Optional. Defaults to :false) Remove elements without the attribute, if set to true.
     * @param ConceptMode
 	 *            (Optional. Defaults to :false) If true filters concepts, if false filters realtions
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult significanceFilter(@WebParam(name = "TargetAttributeName") java.lang.String TargetAttributeName, @WebParam(name = "Significance") java.lang.Float Significance, @WebParam(name = "Inverse") java.lang.Boolean Inverse, @WebParam(name = "AbsoluteValues") java.lang.Boolean AbsoluteValues, @WebParam(name = "Remove_no_att") java.lang.Boolean Remove_no_att, @WebParam(name = "ConceptMode") java.lang.Boolean ConceptMode, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter significance called");
        net.sourceforge.ondex.filter.significance.Filter filter = new net.sourceforge.ondex.filter.significance.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "TargetAttributeName", TargetAttributeName);
        createArguement(filter, arguments, "Significance", Significance);
        createArguement(filter, arguments, "Inverse", Inverse);
        createArguement(filter, arguments, "AbsoluteValues", AbsoluteValues);
        createArguement(filter, arguments, "Remove_no_att", Remove_no_att);
        createArguement(filter, arguments, "ConceptMode", ConceptMode);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in subgraph package.
     *
 	 *    Custodians: [Ljava.lang.String;@ede59e
     * @param ConceptID
 	 *            (REQUIRED! No Default!) The root concept to start at.
     * @param FirstRelationType
 	 *            (Optional. No Default.) [List]RelationType limitation for depth 1.
     * @param FirstConceptClass
 	 *            (Optional. No Default.) [List]ConceptClass limitation for depth 1.
     * @param FirstRelationDirection
 	 *            (Optional. Defaults to :both) Direction of relation for depth 1, one of [both, incoming, outgoing].
     * @param SecondRelationType
 	 *            (Optional. No Default.) [List]RelationType limitation for depth 2.
     * @param SecondConceptClass
 	 *            (Optional. No Default.) [List]ConceptClass limitation for depth 2.
     * @param SecondRelationDirection
 	 *            (Optional. Defaults to :both) Direction of relation for depth 2, one of [both, incoming, outgoing].
     * @param ThirdRelationType
 	 *            (Optional. No Default.) [List]RelationType limitation for depth 3.
     * @param ThirdConceptClass
 	 *            (Optional. No Default.) [List]ConceptClass limitation for depth 3.
     * @param ThirdRelationDirection
 	 *            (Optional. Defaults to :both) Direction of relation for depth 3, one of [both, incoming, outgoing].
     * @param ForthRelationType
 	 *            (Optional. No Default.) [List]RelationType limitation for depth 4.
     * @param ForthConceptClass
 	 *            (Optional. No Default.) [List]ConceptClass limitation for depth 4.
     * @param ForthRelationDirection
 	 *            (Optional. Defaults to :both) Direction of relation for depth 4, one of [both, incoming, outgoing].
     * @param FifthRelationType
 	 *            (Optional. No Default.) [List]RelationType limitation for depth 5.
     * @param FifthConceptClass
 	 *            (Optional. No Default.) [List]ConceptClass limitation for depth 5.
     * @param FifthRelationDirection
 	 *            (Optional. Defaults to :both) Direction of relation for depth 5, one of [both, incoming, outgoing].
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult subgraphFilter(@WebParam(name = "ConceptID") java.lang.Integer ConceptID, @WebParam(name = "FirstRelationType") java.lang.String[] FirstRelationType, @WebParam(name = "FirstConceptClass") java.lang.String[] FirstConceptClass, @WebParam(name = "FirstRelationDirection") java.lang.String FirstRelationDirection, @WebParam(name = "SecondRelationType") java.lang.String[] SecondRelationType, @WebParam(name = "SecondConceptClass") java.lang.String[] SecondConceptClass, @WebParam(name = "SecondRelationDirection") java.lang.String SecondRelationDirection, @WebParam(name = "ThirdRelationType") java.lang.String[] ThirdRelationType, @WebParam(name = "ThirdConceptClass") java.lang.String[] ThirdConceptClass, @WebParam(name = "ThirdRelationDirection") java.lang.String ThirdRelationDirection, @WebParam(name = "ForthRelationType") java.lang.String[] ForthRelationType, @WebParam(name = "ForthConceptClass") java.lang.String[] ForthConceptClass, @WebParam(name = "ForthRelationDirection") java.lang.String ForthRelationDirection, @WebParam(name = "FifthRelationType") java.lang.String[] FifthRelationType, @WebParam(name = "FifthConceptClass") java.lang.String[] FifthConceptClass, @WebParam(name = "FifthRelationDirection") java.lang.String FifthRelationDirection, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter subgraph called");
        net.sourceforge.ondex.filter.subgraph.Filter filter = new net.sourceforge.ondex.filter.subgraph.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "ConceptID", ConceptID);
        createArguement(filter, arguments, "FirstRelationType", FirstRelationType);
        createArguement(filter, arguments, "FirstConceptClass", FirstConceptClass);
        createArguement(filter, arguments, "FirstRelationDirection", FirstRelationDirection);
        createArguement(filter, arguments, "SecondRelationType", SecondRelationType);
        createArguement(filter, arguments, "SecondConceptClass", SecondConceptClass);
        createArguement(filter, arguments, "SecondRelationDirection", SecondRelationDirection);
        createArguement(filter, arguments, "ThirdRelationType", ThirdRelationType);
        createArguement(filter, arguments, "ThirdConceptClass", ThirdConceptClass);
        createArguement(filter, arguments, "ThirdRelationDirection", ThirdRelationDirection);
        createArguement(filter, arguments, "ForthRelationType", ForthRelationType);
        createArguement(filter, arguments, "ForthConceptClass", ForthConceptClass);
        createArguement(filter, arguments, "ForthRelationDirection", ForthRelationDirection);
        createArguement(filter, arguments, "FifthRelationType", FifthRelationType);
        createArguement(filter, arguments, "FifthConceptClass", FifthConceptClass);
        createArguement(filter, arguments, "FifthRelationDirection", FifthRelationDirection);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in transitive package.
     *
 	 *    Authors: [Ljava.lang.String;@7dedad
 	 *    Custodians: [Ljava.lang.String;@17efd36
     * @param CV
 	 *            (Optional. No Default.) Seed cv that will be used to extract the subgraph.
     * @param AttributeName
 	 *            (Optional. No Default.) Seed attribute name that will be used to extract the subgraph.
     * @param level
 	 *            (Optional. No Default.) Cutoff level.
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult transitiveFilter(@WebParam(name = "CV") java.lang.String CV, @WebParam(name = "AttributeName") java.lang.String AttributeName, @WebParam(name = "level") java.lang.String level, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter transitive called");
        net.sourceforge.ondex.filter.transitive.Filter filter = new net.sourceforge.ondex.filter.transitive.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "CV", CV);
        createArguement(filter, arguments, "AttributeName", AttributeName);
        createArguement(filter, arguments, "level", level);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    /**
     * Method to run Filter in unconnected package.
     *
 	 *    Status: STABLE Tested March 2010 (Artem Lysenko)
 	 *    Authors: [Ljava.lang.String;@21e605
 	 *    Custodians: [Ljava.lang.String;@1845568
     * @param RemoveContextDependencies
 	 *            (Optional. Defaults to :false) Set true to remove context dependencies, otherwise unconnected concepts will still remain in the graph.
     * @param ConceptClassRestriction
 	 *            (Optional. No Default.) [List]A Concept Class Restriction as an ordered pair representing from and to Concepts in an evaluated Relation. (add the reverse compliment if direction is not important)
     * @param graphId
 	 *            (REQUIRED! No Default!) The ID of the Graph
     * @return String representation of all event fired by the filter
     * @throws WebserviceException
     */
    @WebResult(name = "info")
    @WebMethod(exclude = false)
    public WSFilterResult unconnectedFilter(@WebParam(name = "RemoveContextDependencies") java.lang.Boolean RemoveContextDependencies, @WebParam(name = "ConceptClassRestriction") java.lang.String[] ConceptClassRestriction, @WebParam(name = "graphId") Long graphId) throws WebserviceException {
        logger.info("filter unconnected called");
        net.sourceforge.ondex.filter.unconnected.Filter filter = new net.sourceforge.ondex.filter.unconnected.Filter();
        logger.info(");Filter created " + filter);
        ONDEXGraph graph = webServiceEngine.getGraphToEdit(graphId);
        logger.info("found graph");
        FilterArguments arguments = new FilterArguments(filter.getArgumentDefinitions());
        createArguement(filter, arguments, "RemoveContextDependencies", RemoveContextDependencies);
        createArguement(filter, arguments, "ConceptClassRestriction", ConceptClassRestriction);
        logger.info("created arguements");
        return runFilter(graph, filter, arguments);
    }

    @WebMethod(exclude = true)
    private WSFilterResult runFilter(ONDEXGraph graph, AbstractONDEXFilter filter, FilterArguments filterArguments) throws IllegalArguementsException, CaughtException, GraphNotFoundException {
        BufferedFilterListener bufferedFilterListener = new BufferedFilterListener(logger);
        filter.addFilterListener(bufferedFilterListener);
        logger.info("added listener");
        filter.setONDEXGraph(graph);
        logger.info("set graph");
        addDefaultArgements(filter, filterArguments);
        logger.info("added default arguements");
        OndexPluginInit init = new OndexPluginInit();
        logger.info("created init");
        init.setArguments(filterArguments);
        logger.info("set arguements");
        init.setPlugin(filter);
        logger.info("set filter");
        ONDEXGraph newGraph = webServiceEngine.makeGraph(graph.getName(), "filter");
        try {
            logger.info("running filter");
            engine.runFilter(init, graph, newGraph);
            logger.info("ran filter");
        } catch (Exception e) {
            throw new CaughtException(e, bufferedFilterListener, logger);
        }
        logger.info("done");
        return new WSFilterResult(newGraph, bufferedFilterListener);
    }

    /**
     * Deletes all jobs and all temporary files.
     *
     * Removes the job from memory and deletes any created files or other records.
     * Deletes all jobs and files not just Filter jobs and files.
     * Deletes all jobs and files making no destinction between which users stated the job/ created the file.
     *
     * @return TRUE if every job and file was deleted sucessfully.
     *
     * @throws JobException
     */
    @WebResult(name = "jobs")
    @WebMethod(exclude = false)
    public boolean deleteAllJobs() throws JobException {
        Boolean success = ExecutorRegister.getRegister().deleteAllJobs();
        success = success && PluginWS.deleteAllTemporaryFiles();
        return success;
    }
}
