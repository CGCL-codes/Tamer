package hambo.app.util;

import org.enhydra.xml.dom.DOMOps;
import org.enhydra.xml.xmlc.XMLCUtil;
import org.w3c.dom.html.*;
import org.w3c.dom.*;
import hambo.util.HTMLUtil;

/**
 * A class containing miscellaneous static methods to manipulate DOM objects.
 *
 */
public abstract class DOMUtil {

    /**
     * Prevent instantiation.
     */
    protected DOMUtil() {
    }

    public static CDATASection createCDATASection(Node node, String data) {
        CDATASection cs = null;
        if (node != null && data != null) {
            Document doc = node.getOwnerDocument();
            if (doc != null) cs = doc.createCDATASection(data);
        }
        return cs;
    }

    public static CDATASection createCDATASection(Document doc, String data) {
        CDATASection cs = null;
        if (doc != null && data != null) cs = doc.createCDATASection(data);
        return cs;
    }

    /**
     * Get an element by searching the DOM after a tag with a
     * certain id attribute. Try to use {@link #getElementByMethod}
     * instead of this one, since it's probably more efficient.
     *
     * @param root the node to search for the element in.
     * @param id the id attribute to search for.
     * @return the first element found with the given id.
     * If no element is found, null is returned. 
     */
    public static Element getElementById(Node root, String id) {
        if (root != null) return XMLCUtil.getElementById(id, root); else return null;
    }

    /**
     * Get an element by using reflection.
     * @param obj the Document to get the element from.
     * @param id the id attribute that the element contains.
     * @return the element with the given id.
     * If no element is found, null is returned. 
     */
    public static Element getElementByMethod(Document obj, String id) {
        String firstCharacter = id.substring(0, 1).toUpperCase();
        String endString = id.substring(1, id.length());
        try {
            return (Element) obj.getClass().getMethod("getElement" + firstCharacter + endString, null).invoke(obj, null);
        } catch (NoSuchMethodException ex) {
            return null;
        } catch (java.lang.reflect.InvocationTargetException ex) {
            return null;
        } catch (java.lang.IllegalAccessException ex) {
            return null;
        }
    }

    /**
     * Searches for an element that has the given tag name.
     * @param node the node to search for the tag name in.
     * @param tagName the tag name to search for.
     * @return the first element found with the given tag name.
     * If no element is found, null is returned.
     */
    public static Element findFirstElementByTagName(Node node, String tagName) {
        if (node == null || tagName == null) return null;
        if ((node instanceof Element) && (((Element) node).getTagName().equalsIgnoreCase(tagName))) return (Element) node;
        for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
            Element retElem = findFirstElementByTagName(child, tagName);
            if (retElem != null) {
                return retElem;
            }
        }
        return null;
    }

    /**
     * Removes the element with the given id from the tree.
     * @param page the tree to remove the element from.
     * @param id the id atttribute that the element contains.
     */
    public static void removeElementByName(Document page, String id) {
        removeNode(getElementByMethod(page, id));
    }

    /**
     * Returns the parent of this node. However, if a node has just been 
     * created and not yet added to the tree, or if it has been removed 
     * from the tree, this returns null.
     */
    public static Node getParent(Node node) {
        return node != null ? node.getParentNode() : null;
    }

    /**
     * The last child of this node. If there is no such node, or if the
     * referent node is null, this returns null.
     */
    public static Node getLastChild(Node node) {
        return node != null ? node.getLastChild() : null;
    }

    /**
     * The node immediately following this node. If there is no such node, 
     * or if the referent node is null, this returns null. 
     */
    public static Node getNextSibling(Node node) {
        return node != null ? node.getNextSibling() : null;
    }

    /**
     * <p>Returns a duplicate of this node, i.e., serves as a generic copy 
     * constructor for nodes. The duplicate node has no parent. Cloning 
     * an Element copies all attributes and their values, including those
     * generated by the XML processor to represent defaulted attributes.
     * This method also copies any text it contains (deep clone), since 
     * the text is contained in a child Text node. Cloning any other type
     * of node simply returns a copy of this node. </p>
     * <p>Note that cloning an immutable subtree results in a mutable copy,
     * but the children of an EntityReference clone are readonly.</p>
     * <p><i>This text was taken from W3C's javadoc</i></p>
     * @return the duplicate, or null if the referent node is null.
     */
    public static Node clone(Node node) {
        return node != null ? node.cloneNode(true) : null;
    }

    /**
     * Remove a given node from its parent node.
     * @param node the node to remove.
     * @return the removed node. Or null, if the argument is null.
     */
    public static Node removeNode(Node node) {
        if (node != null) {
            Node parent = node.getParentNode();
            if (parent != null) parent.removeChild(node);
        }
        return node;
    }

    /**
     * Remove a given element from its parent node.
     * @param elem the element to remove.
     * @return the removed element.
     */
    public static Element removeElement(Element elem) {
        return (Element) removeNode(elem);
    }

    /**
     * Removes a node in the tree and replaces it with a new node. If the new 
     * node is null, the old node is removed anyway.
     *
     * @param the new node to replace the old one with.
     * @param the old node that's removed.
     */
    public static void replaceNode(Node newNode, Node oldNode) {
        if (oldNode != null && newNode != null) {
            DOMOps.replaceNode(newNode, oldNode);
        } else if (oldNode != null) {
            removeNode(oldNode);
        }
    }

    /**
     * <p>Adds the node <code>newChild</code> to the end of the list of children
     * of another node. If <code>newChild</code> is already in the tree, 
     * it is first removed.</p>
     * <p>If any of the two argument nodes are null, this method aborts.</p>
     */
    public static void appendChild(Node parentNode, Node newChild) {
        if (parentNode != null && newChild != null) {
            parentNode.appendChild(newChild);
        }
    }

    /**
     * <p>Inserts the node <code>newChild</code> before the existing child node refChild.
     * If the newChild is already in the tree, it is first removed.</p>
     * <p>If any of the two argument nodes are null, this method aborts.</p>
     */
    public static void insertBefore(Node newChild, Node refChild) {
        if (newChild != null && refChild != null) {
            Node temp = getParent(refChild);
            if (temp != null) temp.insertBefore(newChild, refChild);
        }
    }

    /**
     * <p>Inserts the node <code>newChild</code> immediately after the existing
     * child node <code>refChild</code>. If <code>newChild</code> is already in
     * the tree, it is first removed.</p>
     * <p>If any of the two argument nodes are null, this method aborts.</p>
     */
    public static void insertAfter(Node newChild, Node refChild) {
        if (newChild != null && refChild != null) {
            Node dad = getParent(refChild);
            Node sibling = null;
            if (dad != null) {
                sibling = refChild.getNextSibling();
                if (sibling != null) insertBefore(newChild, sibling); else dad.appendChild(newChild);
            }
        }
    }

    /**
     * Imports a node (and its children) to a DOM. The node is appended in the root node.
     * @param root the node to append the imported node in.
     * @param importNode the node to import.
     */
    public static void appendExternalChild(Node root, Node importNode) {
        if (root == null || importNode == null) return;
        Node temp = root.getOwnerDocument().importNode(importNode, true);
        DOMUtil.appendChild(root, temp);
    }

    /**
     * Imports a node (and its children) to a DOM. The node replaces the first
     * child in the root node. If there is no child, the imported node is appended.
     * @param root the node which the imported node is placed in.
     * @param importNode the node to import.
     */
    public static void insertExternalChild(Node root, Node importNode) {
        if (root == null || importNode == null) return;
        Node temp = root.getOwnerDocument().importNode(importNode, true);
        Node remove = root.getFirstChild();
        if (temp != null) {
            if (remove != null) root.replaceChild(temp, remove); else DOMUtil.appendChild(root, temp);
        }
    }

    /**
     * Imports a node (and its children) to a DOM. The imported node replaces 
     * the other node. If there is no child, the imported node is appended.
     * @param oldNode the node which is replaced by the imported node.
     * @param importNode the node to import.
     */
    public static void replaceExternalChild(Node importNode, Node oldNode) {
        replaceExternalChild(importNode, oldNode, "");
    }

    /**
     * Imports a node (and its children) to a DOM. The imported node replaces 
     * the other node. If there is no child, the imported node is appended.
     * @param oldNode the node which is replaced by the imported node.
     * @param importNode the node to import.
     * @param errorMsg error message that is put in if something goes wrong.
     */
    public static void replaceExternalChild(Node importNode, Node oldNode, String errorMsg) {
        if (oldNode == null) return;
        Node temp = null;
        if (importNode != null) temp = oldNode.getOwnerDocument().importNode(importNode, true); else temp = oldNode.getOwnerDocument().createTextNode(errorMsg);
        Node parent = oldNode.getParentNode();
        if (temp != null && parent != null) parent.replaceChild(temp, oldNode);
    }

    /**
     * Searches a node for text nodes and returns the first found. 
     * @param node the node to search for a text node in.
     * @return the first found text node.
     */
    public static Text findFirstText(Node node) {
        return node != null ? XMLCUtil.findFirstText(node) : null;
    }

    /**
     * This method searches for a specific text node inside another Node.
     */
    public static Text findTextNode(Node node, String text) {
        if (node == null) return null;
        if (node instanceof Text) {
            if (node.getNodeValue().trim().equalsIgnoreCase(text)) return (Text) node;
        }
        for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
            Text textNode = findTextNode(child, text);
            if (textNode != null) {
                return textNode;
            }
        }
        return null;
    }

    /**
     * Searches a node for text nodes. Returns the String value that the first
     * found text node contains. 
     * @param node the node to search for a text node in.
     * @return the String value that the text node contains.
     */
    public static String findFirstTextData(Node node) {
        if (node != null) {
            Text textNode = XMLCUtil.findFirstText(node);
            if (textNode != null) return textNode.getData();
        }
        return null;
    }

    /**
     * Set the first text node descending <code>node</code> to <code>text</code>. If either
     * <code>node</code> or <code>text</code> is <code>null</code>, this is a no-op.
     *
     * <p><em>Note</em> This method will create a <code>CDATA_SECTION</code> node,
     * and will be treated differently from a Text node. You should
     * rather use {@link #replaceFirstTextNode(Node node, String
     * text)} or {@link #replaceFirstTextNode(Node node, String text,
     * boolean htmlDecode)}
     *
     * @param node the node to search for a text node in.
     * @param text the text value to use.
     *
     * @deprecated see description for more information.
     */
    public static void setFirstNodeText(Node node, String text) {
        setFirstNodeText(node, text, false);
    }

    /**
     * Set the first text node descending <code>node</code> to <code>text</code>. If either
     * <code>node</code> or <code>text</code> is <code>null</code>, this is a no-op.
     *
     * <p><em>Note</em> This method will create a <code>CDATA_SECTION</code> node,
     * and will be treated differently from a Text node. You should
     * rather use {@link #replaceFirstTextNode(Node node, String
     * text)} or {@link #replaceFirstTextNode(Node node, String text,
     * boolean htmlDecode)}
     *
     * @param node the node to search for a text node in.
     * @param text the text value to use.

     * @param ecode whether to html encode or not. Should be used if 
     *        the text contains chars that should be html encoded. See
     *        {@link hambo.util.HTMLUtil#decode} 
     *
     * @deprecated see description for more information.
     */
    public static void setFirstNodeText(Node node, String text, boolean encode) {
        if (node != null && text != null) {
            Text textNode = XMLCUtil.findFirstText(node);
            if (textNode != null) {
                Document doc = node.getOwnerDocument();
                if (doc instanceof HTMLDocument) {
                    CDATASection sec = doc.createCDATASection(encode ? HTMLUtil.encode(text) : text);
                    Node parent = textNode.getParentNode();
                    if (parent != null) parent.replaceChild(sec, textNode);
                } else textNode.setData(encode ? HTMLUtil.encode(text) : text);
            }
        }
    }

    /**
     * This method find the first Text node descending
     * <code>node</code>. The value will then be replaced by
     * <code>text</code>.
     *
     * @param node the node to search for a text node in.
     * @param text the text value to use.  
     *
     * @see org.enhydra.xml.xmlc.XMLCUtil#findFirstText 
     */
    public static void replaceFirstTextNode(Node node, String text) {
        if (node != null && text != null) {
            Text textNode = XMLCUtil.findFirstText(node);
            if (textNode != null) {
                textNode.setData(text);
            }
        }
    }

    /**
     * This method find the first Text node descending
     * <code>node</code>. The value will then be replaced by
     * <code>text</code>. The <code>htmlDecode</code> flag indecates
     * if the <code>text</code> should be html decoded before it's
     * inserted in the document.
     *
     * @param node the node to search for a text node in.
     * @param text the text value to use.
     * @param htmlDecode whether to encode or not. Should be used if
     *                   the text contains html encoded chars (example
     *                   <code>&amp;#224;, &amp;#38;, etc</code>).
     *
     * @see hambo.util.HTMLUtil#decode
     * @see org.enhydra.xml.xmlc.XMLCUtil#findFirstText 
     */
    public static void replaceFirstTextNode(Node node, String text, boolean htmlDecode) {
        if (!htmlDecode) {
            replaceFirstTextNode(node, text);
        } else {
            if (node != null && text != null) {
                Text textNode = XMLCUtil.findFirstText(node);
                if (textNode != null) {
                    textNode.setData(HTMLUtil.decode(text));
                }
            }
        }
    }

    /**
     * This method will create a new CDATASection with value  
     * <code>nodeValue</code>. The new CDATASection will replace the
     * first Text node descending <code>node</code>.
     *
     * <p>This method can be used to insert data that shouldn't be
     * encoded by the DOMFormatter, exmaple javascript code.
     *
     * @param node the node to search for a text node in.
     * @param text the text value to use.  
     *
     * @see org.enhydra.xml.xmlc.XMLCUtil#findFirstText 
     */
    public static void replaceFirstTextNodeWithCDATA(Node node, String nodeValue) {
        if (node != null && nodeValue != null) {
            Text textNode = XMLCUtil.findFirstText(node);
            if (textNode != null) {
                Document doc = node.getOwnerDocument();
                Node parent = null;
                CDATASection cdata = doc.createCDATASection(nodeValue);
                parent = textNode.getParentNode();
                if (parent != null) {
                    parent.replaceChild(cdata, textNode);
                }
            }
        }
    }

    /**
     * Appends the first text node in <em>node</em> to <em>text</em>. If either
     * <em>node</em> or <em>text</em> is <code>null</code>, this is a no-op.
     * @param node the node to search for a text node in.
     * @param text the text value to append.
     */
    public static void appendFirstNodeText(Node node, String text) {
        appendFirstNodeText(node, text, false);
    }

    /**
     * Appends the first text node in <em>node</em> to <em>text</em>. If either
     * <em>node</em> or <em>text</em> is <code>null</code>, this is a no-op.
     * @param node the node to search for a text node in.
     * @param text the text value to append.
     * @param encode whether to encode or not.
     */
    public static void appendFirstNodeText(Node node, String text, boolean encode) {
        if (node != null && text != null) {
            Text textNode = XMLCUtil.findFirstText(node);
            if (textNode != null) {
                Document doc = node.getOwnerDocument();
                StringBuffer buf = new StringBuffer(textNode.getData()).append(encode ? HTMLUtil.encode(text) : text);
                if (doc instanceof HTMLDocument) {
                    CDATASection sec = doc.createCDATASection(buf.toString());
                    Node parent = textNode.getParentNode();
                    if (parent != null) parent.replaceChild(sec, textNode);
                } else textNode.setData(buf.toString());
            }
        }
    }

    /**
     * Same thing as {@link Element#setAttribute}, except that if any of the
     * parameters are null, nothing is done and false is returned.
     *
     * @param node to set the attribute on.
     * @param name of the attribute.
     * @param value of the attribute.
     *
     * @return true if attribute has been set in the element.
     */
    public static boolean setAttribute(Node node, String name, String value) {
        if (node != null && name != null && value != null) if (node instanceof Element) {
            ((Element) node).setAttribute(name, value);
            return true;
        }
        return false;
    }

    /**
     * Same thing as {@link Element#setAttribute}, except that you can
     * specify if the <code>value</code> should be decoded before it
     * is inserted in the document. If any of the parameters are null,
     * nothing is done and false is returned.
     *
     * @param node to set the attribute on.
     * @param name of the attribute.
     * @param value of the attribute.
     * @param htmlDecode true will decode the value using HTMLUtil.decode. 
     *
     * @return true if attribute has been set in the element.  
     *
     * @see hambo.util.HTMLUtil#decode
     */
    public static boolean setAttribute(Node node, String name, String value, boolean htmlDecode) {
        if (node != null && name != null && value != null) if (node instanceof Element) {
            ((Element) node).setAttribute(name, HTMLUtil.decode(value));
            return true;
        }
        return false;
    }

    /**
     * The <code>value</code> is appended to the attribute's value.
     *
     * @param node to set the attribute on.
     * @param name of the attribute.
     * @param value of the attribute.
     * @param htmlDecode true will decode the value using HTMLUtil.decode. 
     *
     * @return true if value has been appended to the Attribute.
     */
    public static boolean appendAttribute(Node node, String name, String value) {
        if (node != null && name != null && value != null) if (node instanceof Element) {
            ((Element) node).setAttribute(name, ((Element) node).getAttribute(name) + value);
            return true;
        }
        return false;
    }

    /**
     * This method works like appendAttribute, except it handles 
     * the attribute value as a query string. It appends a question 
     * mark and then the given value to the attribute's value. If the attribute
     * value already contains a question mark, it appends an ampersand 
     * instead.
     *
     * @deprecated use the {@link hambo.util.Link}
     */
    public static boolean appendAttributeWithCheck(Node node, String name, String value) {
        if (node != null && name != null && value != null) if (node instanceof Element) {
            String href = ((Element) node).getAttribute(name);
            href = href + ((href.indexOf(63) != -1) ? "&#38;" : "?");
            ((Element) node).setAttribute(name, href + value);
            return true;
        }
        return false;
    }

    /**
     * Removes the <code>name</code> attribute from
     * <code>elem</code>. If either <code>name</code> or
     * <code>elem</code> are null nothing is done.
     */
    public static void removeAttribute(Element elem, String name) {
        if (elem != null && name != null) elem.removeAttribute(name);
    }

    /**
     * Search <code>node</code> for an attribute called <code>name</code>. 
     * If <code>node</code> has no such element, its children are searched.
     * @param node the node to search from.
     * @param name the attribute to search for.
     * @return the first found Element containing the attribute.
     */
    public static Element getFirstMatchingAttribute(Node node, String name) {
        if (node == null) return null;
        if (node instanceof Element) {
            if (((Element) node).getAttributeNode(name) != null) return (Element) node;
        }
        for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
            Element retElem = getFirstMatchingAttribute(child, name);
            if (retElem != null) {
                return retElem;
            }
        }
        return null;
    }

    /**
     * Search <code>node</code> for an attribute called <code>name</code> and
     * set its value to <code>value</code>. If <code>node</code> has no such
     * attribute, its children are searched.
     * @param node the node to seach from.
     * @param name the name of the attribute to set.
     * @param value the value to set the attribute to (if null, an empty
     * string is used).
     * @return the first found Element containing the attribute.
     */
    public static Element setFirstMatchingAttribute(Node node, String name, String value) {
        if (node == null) return null;
        if (node instanceof Element) {
            Attr attr = ((Element) node).getAttributeNode(name);
            if (attr != null) {
                ((Element) node).setAttribute(name, value != null ? value : "");
                return (Element) node;
            }
        }
        for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
            Element retElem = setFirstMatchingAttribute(child, name, value);
            if (retElem != null) {
                return retElem;
            }
        }
        return null;
    }

    /**
     * Finds the first node that has an attribute matching the given name. 
     * It then appends given value to the attribute's value.
     * @param node the node to search in.
     * @param name the attribute name to search for.
     * @param value the string that is appended to the attribute value.
     * @return the first found Element containing the attribute.
     */
    public static Element appendFirstMatchingAttribute(Node node, String name, String value) {
        if (node == null) return null;
        if (node instanceof Element) {
            Attr attr = ((Element) node).getAttributeNode(name);
            if (attr != null) {
                ((Element) node).setAttribute(name, attr.getValue() + value);
                return (Element) node;
            }
        }
        for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
            Element retElem = appendFirstMatchingAttribute(child, name, value);
            if (retElem != null) {
                return retElem;
            }
        }
        return null;
    }

    /**
     * This method works like appendFirstMatchingAttribute except it handles 
     * the attribute value as a value with a query string. It appends a question 
     * mark and then the given value to the attribute's value. If the attribute
     * value already contains a question mark, it appends an ampersand 
     * instead.
     * @param node the node to search in.
     * @param name the attribute name to search for.
     * @param value the string that is appended to the attribute value.
     * @return the first found Element containing the attribute.
     */
    public static Element appendFirstMatchingAttributeWithCheck(Node node, String name, String value) {
        if (node == null) return null;
        String attrValue = "";
        if (node instanceof Element) {
            attrValue = ((Element) node).getAttribute(name);
            if (attrValue != null && attrValue != "") {
                attrValue = attrValue + ((attrValue.indexOf(63) != -1) ? "&" : "?");
                ((Element) node).setAttribute(name, attrValue + value);
                return (Element) node;
            }
        }
        for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {
            Element retElem = appendFirstMatchingAttributeWithCheck(child, name, value);
            if (retElem != null) {
                return retElem;
            }
        }
        return null;
    }

    /**
     * This let's you set a javascript fragment in the beginning of the 
     * javascript element. The reason for that is that XMLC escapes all &quot; 
     * and ' in a value.
     *
     * @param page     the Document where the javascript element resides
     * @param fragment the fragment to insert
     */
    public static void setGlobalJavascriptFragment(Document page, String fragment) {
        Element javascript = DOMUtil.getElementByMethod(page, "javascript");
        if (javascript != null) {
            Node node = javascript.getFirstChild();
            if (node != null && node instanceof Comment) ((Comment) node).insertData(0, "\n\n" + fragment + "\n\n"); else javascript.appendChild(page.createTextNode("<!--\n" + fragment + "\n//-->"));
        }
    }

    /**
     * Set the selected item of an <code>HTMLSelectElement</code> to
     * match the option element whose value matches the input.
     * <p>Todo: don't use this since it use HTML specific Objects.
     * 
     * @param select  the HTMLSelectElement to manipulate
     * @param optVal  the option to match
     * @deprecated Don't use this since it use HTML specific Objects.
     */
    public static void setSelectedOption(HTMLSelectElement select, String optVal) {
        if (select == null || optVal == null) return;
        HTMLCollection options = select.getOptions();
        for (int i = 0; i < options.getLength(); i++) {
            Node n = options.item(i);
            if (n instanceof HTMLOptionElement) {
                HTMLOptionElement option = (HTMLOptionElement) n;
                if (optVal.equals(option.getValue())) {
                    select.setSelectedIndex(i);
                    break;
                }
            }
        }
    }
}
