package ca.gc.drdc_rddc.atlantic.xml;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.reflect.Array;
import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Logger;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;
import ca.gc.drdc_rddc.atlantic.hla.HLAArrayCodec;
import ca.gc.drdc_rddc.atlantic.hla.HLAFixedRecordCodec;
import ca.gc.drdc_rddc.atlantic.hla.HLACodec;
import ca.gc.drdc_rddc.atlantic.hla.HLACodecFactory;
import ca.gc.drdc_rddc.atlantic.hla.HLAEnumeration;

/**
 * 
 * The code generator is no longer under active development. A better solution
 * is available from DSTO, see Rodney Cheater.
 * 
 * Oct 13, 2004 1:41:56 PM
 * 
 * @author Dillman
 */
public class CodeGenerator extends DomParser {

    /**
     * Logger for this class
     */
    protected static final Logger logger = Logger.getLogger(CodeGenerator.class);

    protected String filename;

    protected HLACodecFactory factory;

    protected HLAFixedRecordCodec parentFrc;

    protected PrintStream out;

    protected String packageName;

    protected String baseDir;

    protected String fomName;

    protected boolean generate;

    protected HLAEnumeration parentEnum;

    protected String parentClsName;

    protected void printFileHeader() {
        out.println("// Generated by DRDC Atlantic from");
        out.println("// fom: " + fomName);
        out.println();
        out.println("package " + packageName + ";");
        out.println();
    }

    protected void createPackageDir() {
        String dirList[] = packageName.split("\\.");
        String dirName = baseDir;
        for (int i = 0; i < dirList.length; i++) {
            dirName = dirName + "/" + dirList[i];
            File dir = new File(dirName + "/");
            if (!dir.exists()) {
                dir.mkdir();
            } else if (!dir.isDirectory()) {
                logger.error("can't create directory due to name collision " + dirName);
            }
        }
    }

    protected void openClassFile(String classname) {
        filename = baseDir + '/' + packageName.replace('.', '/') + '/' + classname + ".java";
        createPackageDir();
        try {
            FileOutputStream fos = new FileOutputStream(filename);
            out = new PrintStream(fos);
        } catch (FileNotFoundException e) {
            logger.error(filename, e);
            out = System.err;
        }
        printFileHeader();
    }

    protected void closeClassFile() {
        out.close();
    }

    private class ObjectModelParser implements NodeParser {

        public void parse(Node n) throws Exception {
            parseChildNodes(n, "dataTypes");
            parseChildNodes(n, "objects");
            parseChildNodes(n, "interactions");
        }
    }

    private class DataTypesParser implements NodeParser {

        public void parse(Node n) throws Exception {
            generate = false;
            parseChildNodes(n, "simpleDataTypes");
            parseChildNodes(n, "enumeratedDataTypes");
            parseChildNodes(n, "arrayDataTypes");
            parseChildNodes(n, "fixedRecordDataTypes");
            factory.resolve();
            generate = true;
            parseChildNodes(n, "simpleDataTypes");
            parseChildNodes(n, "enumeratedDataTypes");
            parseChildNodes(n, "arrayDataTypes");
            parseChildNodes(n, "fixedRecordDataTypes");
        }
    }

    private class SimpleDataParser implements NodeParser {

        public void parse(Node n) throws Exception {
            if (!generate) {
                String name = getAttrVal(n, "name");
                String representation = getAttrVal(n, "representation");
                factory.registerCodec(name, representation);
                parseChildNodes(n);
            }
        }
    }

    private class ArrayDataParser implements NodeParser {

        public void parse(Node n) throws Exception {
            if (!generate) {
                String name = getAttrVal(n, "name");
                String dataType = getAttrVal(n, "dataType");
                String encoding = getAttrVal(n, "encoding");
                String cardinality = getAttrVal(n, "cardinality");
                factory.registerArrayCodec(name, dataType, encoding, cardinality);
                parseChildNodes(n);
            }
        }
    }

    private class EnumeratedDataParser implements NodeParser {

        public void parse(Node n) throws Exception {
            String name = getAttrVal(n, "name");
            String representation = getAttrVal(n, "representation");
            if (generate) {
                openClassFile(name);
                out.println("import java.util.Map;");
                out.println("import java.util.HashMap;");
                out.println();
                out.println("/**");
                out.println(" * " + getAttrVal(n, "semantics"));
                out.println(" * @author " + fomName);
                out.println(" */");
                out.println("public class " + name + " {");
                out.println();
                out.println("    /** Map of (key=enum value, value=enum name). */");
                out.println("    public static Map enumValues = new HashMap();");
                out.println();
                out.println("    /** Map of (key=enum name, value=enum value). */");
                out.println("    public static Map enumNames = new HashMap();");
                parseChildNodes(n);
                out.println("}");
                closeClassFile();
            } else {
                HLAEnumeration tmp = parentEnum;
                parentEnum = new HLAEnumeration(name);
                factory.registerEnumeration(name, parentEnum, representation);
                parseChildNodes(n);
                parentEnum = tmp;
            }
        }
    }

    private class EnumeratorParser implements NodeParser {

        public void parse(Node n) throws Exception {
            String name = getAttrVal(n, "name");
            String values = getAttrVal(n, "values");
            if (generate) {
                out.println();
                String semantics = getAttrVal(n, "semantics");
                if (semantics == null) {
                    out.println("    /** " + name + " = " + values + " */");
                } else {
                    out.println("    /** " + semantics + " */");
                }
                out.println("    public static final int " + name + " = " + values + ";");
                out.println("    {");
                out.println("        enumValues.put(new Integer(" + name + "), \"" + name + "\");");
                out.println("        enumNames.put(\"" + name + "\", new Integer(" + name + "));");
                out.println("    }");
            } else {
                parentEnum.addEnumerator(name, Long.parseLong(values));
            }
        }
    }

    private class FixedRecordDataParser implements NodeParser {

        public void parse(Node n) throws Exception {
            String name = getAttrVal(n, "name");
            if (generate) {
                openClassFile(name);
                out.println();
                out.println("/**");
                out.println(" * " + getAttrVal(n, "semantics"));
                out.println(" * @author " + fomName);
                out.println(" */");
                out.println("public class " + name + " {");
                out.println();
                parseChildNodes(n);
                out.println("}");
                closeClassFile();
            } else {
                HLAFixedRecordCodec temp = parentFrc;
                parentFrc = factory.registerFixedRecordCodec(name);
                parseChildNodes(n);
                parentFrc = temp;
            }
        }
    }

    private class FieldParser implements NodeParser {

        public void parse(Node n) throws Exception {
            String name = getAttrVal(n, "name");
            String dataType = getAttrVal(n, "dataType");
            HLACodec codec = factory.getHLACodec(dataType);
            if (generate) {
                String semantics = getAttrVal(n, "semantics");
                if (semantics != null) out.println("    /**" + semantics + "*/"); else out.println("    /** TODO: fix comment. */");
                String prototype = getPrototype(name, codec);
                out.println("    public " + prototype + ";");
            } else {
                if (codec == null) {
                    factory.registerCodec(name, dataType);
                    codec = factory.getHLACodec(dataType);
                }
                parentFrc.addField(name, codec);
            }
        }
    }

    private class ObjectClassParser implements NodeParser {

        public void parse(Node n) throws Exception {
            String clsName = getAttrVal(n, "name");
            PrintStream tmpOut = out;
            String tmpfname = filename;
            openClassFile(clsName);
            out.println();
            out.println("/**");
            out.println(" * " + getAttrVal(n, "semantics"));
            out.println(" * @author " + fomName);
            out.println(" */");
            out.println("public class " + clsName);
            if (parentClsName != null) {
                out.println("  extends " + parentClsName);
            }
            out.println("{");
            String tmpParentName = parentClsName;
            parentClsName = clsName;
            parseChildNodes(n);
            parentClsName = tmpParentName;
            out.println("}");
            closeClassFile();
            filename = tmpfname;
            out = tmpOut;
        }
    }

    private class AttributeParser implements NodeParser {

        public void parse(Node n) throws Exception {
            String name = getAttrVal(n, "name");
            String dataType = getAttrVal(n, "dataType");
            HLACodec codec = factory.getHLACodec(dataType);
            if (codec != null) {
                String semantics = getAttrVal(n, "semantics");
                if (semantics != null) out.println("    /**" + semantics + "*/"); else out.println("    /** TODO: fix comment. */");
                String prototype = getPrototype(name, codec);
                out.println("    public " + prototype + ";");
            } else {
                logger.error("Undefined attribute:" + name + " dataType: " + dataType);
            }
            parseChildNodes(n);
        }
    }

    private class InteractionClassParser implements NodeParser {

        public void parse(Node n) throws Exception {
            String clsName = getAttrVal(n, "name");
            PrintStream tmpOut = out;
            String tmpfname = filename;
            openClassFile(clsName);
            out.println();
            out.println("/**");
            out.println(" * " + getAttrVal(n, "semantics"));
            out.println(" * @author " + fomName);
            out.println(" */");
            out.println("public class " + clsName);
            if (parentClsName != null) {
                out.println("  extends " + parentClsName);
            }
            out.println("{");
            String tmpParentName = parentClsName;
            parentClsName = clsName;
            parseChildNodes(n);
            parentClsName = tmpParentName;
            out.println("}");
            closeClassFile();
            filename = tmpfname;
            out = tmpOut;
        }
    }

    /**
     * @param name
     * @param codec
     * @return
     */
    public String getPrototype(String name, HLACodec codec) {
        String fieldName = name;
        String type;
        Class cls = codec.getResultClass();
        while (cls == Array.class && !(codec instanceof HLAFixedRecordCodec)) {
            HLAArrayCodec ac = (HLAArrayCodec) codec;
            codec = ac.getElementCodec();
            cls = codec.getResultClass();
            fieldName = fieldName + "[]";
        }
        if (cls == Integer.class) {
            type = "int";
        } else if (cls == Byte.class) {
            type = "byte";
        } else if (cls == Long.class) {
            type = "long";
        } else if (cls == Short.class) {
            type = "short";
        } else if (cls == Double.class) {
            type = "double";
        } else if (cls == Float.class) {
            type = "float";
        } else if (cls == String.class) {
            type = "String";
        } else if (codec instanceof HLAFixedRecordCodec) {
            type = factory.getCodecName(codec);
        } else {
            type = cls.getName();
        }
        return type + " " + fieldName;
    }

    /**
     * Constructor.
     */
    public CodeGenerator() {
        super();
        factory = new HLACodecFactory();
        nodeParserMap.put("objectModel", new ObjectModelParser());
        nodeParserMap.put("dataTypes", new DataTypesParser());
        nodeParserMap.put("simpleData", new SimpleDataParser());
        nodeParserMap.put("enumeratedData", new EnumeratedDataParser());
        nodeParserMap.put("enumerator", new EnumeratorParser());
        nodeParserMap.put("arrayData", new ArrayDataParser());
        nodeParserMap.put("fixedRecordData", new FixedRecordDataParser());
        nodeParserMap.put("field", new FieldParser());
        nodeParserMap.put("objectClass", new ObjectClassParser());
        nodeParserMap.put("attribute", new AttributeParser());
        nodeParserMap.put("interactionClass", new InteractionClassParser());
        nodeParserMap.put("parameter", new AttributeParser());
    }

    /**
     * @param args
     */
    public static void main(String args[]) {
        String filename = "VMS-FOM_3.3.3-comms.xml";
        BasicConfigurator.resetConfiguration();
        BasicConfigurator.configure();
        CodeGenerator cg = new CodeGenerator();
        cg.baseDir = "src";
        cg.packageName = "vms.fom";
        cg.fomName = filename;
        System.out.print("Generating from " + cg.fomName);
        try {
            cg.parseFile(filename);
        } catch (SAXException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
