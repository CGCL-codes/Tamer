package net.sf.istcontract.aws.communication.protocol.Toy13_5_2;

import net.sf.istcontract.aws.communication.message.Message;
import net.sf.istcontract.aws.communication.message.MessageFactory;
import net.sf.istcontract.aws.communication.message.MessageTemplate;
import net.sf.istcontract.aws.communication.performative.ConsentSuggestion;
import net.sf.istcontract.aws.communication.performative.Performative;
import net.sf.istcontract.aws.communication.performative.Suggest;
import net.sf.istcontract.aws.engine.AgentKernel;
import net.sf.istcontract.aws.exception.AgentException;
import net.sf.istcontract.aws.input.domain.EBookContract;
import net.sf.istcontract.aws.utils.AgentLogger;
import net.sf.istcontract.aws.knowledge.ontology.OntologyConcept;
import net.sf.istcontract.aws.communication.performative.*;
import net.sf.istcontract.aws.communication.protocol.*;

/**
 *
 * This is a protocol role implementation. There is one Java file like this for every role on the protocol
 *
 * It is part of the CommunicationManager component.
 *
 * @author Autogenerated by ingenias2contractcodegenerator (Ignasi Gomez-Sebastia)
 *
 */
public class InitiatorRole extends ConversationInitiator {

    IConversationListener owner;

    public InitiatorRole() {
        super();
    }

    @Override
    public final void processIncomingMessage(Performative perf, IConversationListener owner) throws ProtocolViolationException {
        if (1 == 2) {
        } else if (perf instanceof ConsentSuggestion) {
            handleConsentSuggestion(perf, getNextMessages());
        } else if (perf instanceof Inform) {
            handleInform(perf, getNextMessages());
        } else if (perf instanceof DismissSuggestion) {
            handleDismissSuggestion(perf, getNextMessages());
        } else if (perf instanceof Agree) {
            handleAgree(perf, getNextMessages());
        } else {
            AgentLogger.log("Exception: Performatives of type " + perf.getClass().getName() + " can not be handled by Role " + this.getClass().getName() + " on protocol " + this.getProtocol().getName());
            throw new ProtocolViolationException("Exception: Performatives of type " + perf.getClass().getName() + " can not be handled by Role " + this.getClass().getName() + " on protocol " + this.getProtocol().getName());
        }
    }

    @Override
    public void startConversation(IConversationListener owner, String addreseeAgentID, OntologyConcept content, ProtocolNode rootNode, String idDialogToBeUsed) {
        this.owner = owner;
        this.protocolNode = rootNode;
        Message myMessage = MessageFactory.createNewMessage(owner.getAgentId(), addreseeAgentID, idDialogToBeUsed, content, getMessage());
        sendMessage(myMessage);
    }

    private void handleConsentSuggestion(Performative perf, MessageTemplate[] possibleReplies) {
    }

    private void handleInform(Performative perf, MessageTemplate[] possibleReplies) {
    }

    private void handleDismissSuggestion(Performative perf, MessageTemplate[] possibleReplies) {
    }

    private void handleAgree(Performative perf, MessageTemplate[] possibleReplies) {
    }

    /**
     * Sends a reply message
     * @param message message created using MessageFactory.createReply(...) using a corresponding MessageTemplate according to what the reply should be (follows a protocol - one of MessageTemplates returned by getNextMessges()
     */
    @Override
    public final void sendMessage(Message message) {
        try {
            owner.sendMessage(message, this);
        } catch (AgentException ex) {
            AgentLogger.log("Cannot send message: " + message.toString() + "\n" + ex.getMessage());
        }
    }
}
