package org.jcvi.fluvalidator;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.jcvi.common.core.Range;
import org.jcvi.common.core.seq.fastx.fasta.nt.NucleotideSequenceFastaRecord;
import org.jcvi.fluvalidator.errors.AmbiguityError;
import org.jcvi.fluvalidator.errors.MissingEndCoverageError;
import org.jcvi.fluvalidator.errors.MissingStartCoverageError;
import org.jcvi.fluvalidator.errors.ValidationError;

/**
 * A <code>ValidationResult</code> is a fully parsed and decoded result for
 * a {@link NucleotideSequenceFastaRecord} as generated by a {@link ValidationService} and 
 * {@link ValidationReportParser}.  This is the basic unit of validation and
 * contains all of the data necessary to make higher-order decisions about the
 * actual state of the validated record.
 *
 * @author jsitz@jcvi.org
 */
public class ValidationResult {

    /** The validation identifier of this result. */
    private final String id;

    /** The segment this result was expected to be identified as. */
    private FluSegment expectedSegment;

    /** The segment this result was actually identified as. */
    private FluSegment segment;

    /** The validated length of this record. */
    private int validLength;

    /** The major Influenza type identified in this record. */
    private String type;

    /** The Influenza subtype identified in this record. */
    private final ValidationSerotype serotype;

    private Range codingRegion = null;

    /** A sorted map of all the {@link ValidationError}s encontered for this record. */
    private final Map<Class<? extends ValidationError>, List<ValidationError>> sortedErrors;

    /**
     * Creates a new <code>ValidationResult</code>.  This will create an 
     * "empty" result with no recorded errors, no expected or verified segment,
     * no major type or subtype, and no valid length.  
     * <p>
     * <em>Note:</em> Despite its sparse initial state, it is important to
     * realize that many {@link ValidationEvaluator}s may 
     * {@link ValidationEvaluator#evaluate(ValidationResult)} this result to
     * be {@link ValidationState#VALID}.  Failures to populate the result with
     * actual data from a validation report should be handled carefully to 
     * avoid this silent bug.
     * 
     * @param id The identifier for this result.
     */
    public ValidationResult(String id) {
        super();
        this.id = id;
        this.segment = FluSegment.UNKNOWN;
        this.serotype = new ValidationSerotype();
        this.sortedErrors = new HashMap<Class<? extends ValidationError>, List<ValidationError>>();
    }

    public Range getCodingRegion() {
        return this.codingRegion;
    }

    public void setGeneRange(Range codingRegion) {
        this.codingRegion = codingRegion;
    }

    /**
     * Sets the segment name expected for this result.
     * 
     * @param expectedName The expected segment name.
     */
    public void setExpectedSegment(String expectedName) {
        try {
            this.setExpectedSegment(FluSegment.valueOf(expectedName));
        } catch (final Exception e) {
            this.setExpectedSegment(FluSegment.UNKNOWN);
        }
    }

    /**
     * Sets the segment expected for this result.
     * 
     * @param expected The expected segment.
     */
    public void setExpectedSegment(FluSegment expected) {
        this.expectedSegment = expected;
    }

    /**
     * Retrieves the expected segment name for this result.
     * 
     * @return The name of the segment this result is expected to belong to.
     */
    public FluSegment getExpectedSegment() {
        return (this.expectedSegment == null) ? this.getSegment() : this.expectedSegment;
    }

    /**
     * Checks to see if the expected segment name matches the actual segment
     * name as reported by the {@link ValidationService}.
     * 
     * @return <code>true</code> if {@link #getSegment()} and 
     * {@link #getExpectedSegment()} return equivalent segment names or at leas
     * one of them was unknown, otherwise <code>false</code>.
     */
    public boolean isExpectedSegment() {
        return (this.expectedSegment == null || this.expectedSegment.equals(FluSegment.UNKNOWN) || this.segment.equals(FluSegment.UNKNOWN) || this.expectedSegment.equals(this.segment));
    }

    /**
     * Retrieves the count of basecall ambiguities encountered in this result.
     * 
     * @return The number of {@link AmbiguityError}s returned for this result.
     */
    public int getAmbiguityCount() {
        return this.getErrorsByType(AmbiguityError.class).size();
    }

    /**
     * Retrieves a {@link List} of errors from this result that match the 
     * supplied error type.
     * <p>
     * <em>Note:</em> Only strict type matching is performed.  Asking for all
     * errors of a certain type will only return errors specifically reported
     * as that type.  Errors which are subclasses of the requested type will
     * not be returned.
     * 
     * @param <T> A type of {@link ValidationError}.
     * @param errorClass The error class to retrieve.
     * @return An unmodifiable {@link List} of errors matching the given error
     * type.  If no errors of the given type are found, then an empty list is
     * returned.
     */
    @SuppressWarnings("unchecked")
    public <T extends ValidationError> List<T> getErrorsByType(Class<T> errorClass) {
        if (this.sortedErrors.containsKey(errorClass)) {
            return Collections.unmodifiableList((List<T>) this.sortedErrors.get(errorClass));
        }
        return Collections.emptyList();
    }

    /**
     * Checks to see if at least one error of the given type was reported for
     * this result.
     * <p>
     * <em>Note:</em> Only strict type matching is performed.  Checking for the
     * existence of a certain type will only check errors specifically reported
     * as that type.  Errors which are subclasses of the requested type will
     * be ignored.
     * 
     * @param <T> A type of {@link ValidationError}.
     * @param errorClass The error class to check for.
     * @return <code>true</code> if at least one error of the requested type
     * was reported for this result, <code>false</code> if no errors of this
     * type where reported.
     */
    public final <T extends ValidationError> boolean hasError(Class<T> errorClass) {
        return !this.getErrorsByType(errorClass).isEmpty();
    }

    /**
     * Retrieves the identifier for this result.  This identifier is usally 
     * linked to the {@link NucleotideSequenceFastaRecord} which generated this result, but the
     * relationship is not required.  The identifier is only guaranteed to be
     * unique to the set of records returned by the 
     * {@link ValidationReportParser}.
     * 
     * @return The identifier for this result.
     */
    public String getIdentifier() {
        return this.id;
    }

    /**
     * Retrieves the actual segment this result was found to belong to,
     * according to the {@link ValidationService}.
     * 
     * @return The actual segment identified in this result.
     */
    public FluSegment getSegment() {
        return (this.segment == null) ? FluSegment.UNKNOWN : this.segment;
    }

    /**
     * Sets the segment name which was actually found for this result by the
     * {@link ValidationService}.
     * 
     * @param segmentName The actual segment name identified in this result.
     */
    public void setSegment(String segmentName) {
        try {
            this.setSegment(FluSegment.valueOf(segmentName));
        } catch (final Exception e) {
            this.setSegment(FluSegment.UNKNOWN);
        }
    }

    /**
     * Sets the segment name which was actually found for this result by the
     * {@link ValidationService}.
     * 
     * @param segment The actual segment identified in this result.
     */
    public void setSegment(FluSegment segment) {
        this.segment = segment;
    }

    /**
     * Retrieves the length of the record validated in this result.  This should
     * equal the length of the {@link NucleotideSequenceFastaRecord} which generated this result.
     * 
     * @return The validated length of this result, in base pairs.
     */
    public int getValidLength() {
        return this.validLength;
    }

    /**
     * Sets the length of the record validated in this result.
     * 
     * @param validLength The validated length of this result, in base pairs.
     */
    public void setValidLength(int validLength) {
        this.validLength = validLength;
    }

    /**
     * Returns the major Influenza type (A, B, C) this result was identified
     * as.
     * 
     * @return A <code>String</code> version of the major influezna type.
     */
    public String getType() {
        return this.type;
    }

    /**
     * Sets the major Influenza type for this result, as identified by a 
     * {@link ValidationService}.
     * 
     * @param type The major type as a <code>String</code>.
     */
    public void setType(String type) {
        this.type = type;
    }

    /**
     * Retrieves the {@link ValidationSerotype} which was identified in this 
     * result.  It should be expected that this will only be a partial serotype
     * (e.g. "H1" or "N7") since results are limited to a single segment and
     * in almost all cases, multiple segments are required in order to identify
     * the full serotype of a sample.
     * 
     * @return The serotype identified in this result.
     */
    public ValidationSerotype getSerotype() {
        return this.serotype;
    }

    /**
     * Calculates the number of uncovered bases at the start of the segment.
     * 
     * @return The number of bases missing, or 0 if no coverage is missing.
     */
    public int getMissingStartBases() {
        final List<MissingStartCoverageError> errors = this.getErrorsByType(MissingStartCoverageError.class);
        if (errors.size() > 0) {
            return (int) errors.get(0).getLocation().getLength();
        }
        return 0;
    }

    /**
     * Calculates the number of uncovered bases at the end of the segment.
     * 
     * @return The number of bases missing, or 0 if no coverage is missing.
     */
    public int getMissingEndBases() {
        final List<MissingEndCoverageError> errors = this.getErrorsByType(MissingEndCoverageError.class);
        if (errors.size() > 0) {
            return (int) errors.get(0).getLocation().getLength();
        }
        return 0;
    }

    /**
     * Adds an error to this result.  
     * <p>
     * <em>Implementation Details:</em> The type of the error is captured by 
     * this method and may be used to store the error in an easily retrievable
     * fashion.  Because of this, care should be taken to preserve the type of
     * the error passed to the method.
     * 
     * @param <T> The type of this {@link ValidationError}.
     * @param error The reported error.
     */
    public <T extends ValidationError> void addError(T error) {
        if (!this.sortedErrors.containsKey(error.getClass())) {
            this.sortedErrors.put(error.getClass(), new ArrayList<ValidationError>());
        }
        this.sortedErrors.get(error.getClass()).add(error);
    }

    /**
     * Adds a collection of errors to this result.
     * <p>
     * This is equivalent to calling {@link #addError(ValidationError)} 
     * iteratively over the collection.
     * 
     * @param errors The errors to add to the result.
     * @see #addError(ValidationError)
     */
    public void addErrors(Collection<? extends ValidationError> errors) {
        for (final ValidationError error : errors) {
            this.addError(error);
        }
    }

    /**
     * Fetch a list of all errors encountered on this result.
     * 
     * @return An umodifiable {@link List} of all errors reported for this
     * result.
     */
    public List<ValidationError> getErrors() {
        final List<ValidationError> errors = new ArrayList<ValidationError>();
        for (final Class<?> errorClass : this.sortedErrors.keySet()) {
            for (final ValidationError error : this.sortedErrors.get(errorClass)) {
                errors.add(error);
            }
        }
        return Collections.unmodifiableList(errors);
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((this.id == null) ? 0 : this.id.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (this.getClass() != obj.getClass()) return false;
        final ValidationResult other = (ValidationResult) obj;
        if (this.id == null) {
            if (other.id != null) return false;
        } else if (!this.id.equals(other.id)) return false;
        return true;
    }
}
