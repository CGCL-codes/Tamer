package takatuka.tukFormat;

import takatuka.vm.autoGenerated.*;
import takatuka.tukFormat.logic.*;
import takatuka.tukFormat.logic.factory.*;
import takatuka.tukFormat.logic.file.*;
import takatuka.optimizer.bytecode.changer.logic.freq.*;
import takatuka.classreader.logic.factory.*;
import takatuka.classreader.logic.logAndStats.*;
import takatuka.optimizer.bytecode.branchSetter.logic.*;
import takatuka.optimizer.bytecode.changer.logic.*;
import takatuka.optimizer.cpGlobalization.dataObjs.constantPool.*;
import takatuka.tukFormat.verifier.logic.TukFileVerifier;
import takatuka.vm.autoGenerated.forExceptionPrettyPrint.*;
import takatuka.vm.autoGenerated.vmSwitch.*;

/**
 * <p>Title: </p>
 * <p>Description: </p>
 * @author Faisal Aslam
 * @version 1.0
 */
public class StartMeLF extends StartMeBCC {

    private static final LogHolder logHolder = LogHolder.getInstanceOf();

    private static boolean alwaysBigMethods = false;

    public static LFWriter writer = null;

    /**
     * If the JVM is based on a big switch or labels based direct references
     */
    public static boolean generateSwitchNotLables = false;

    protected StartMeLF() {
    }

    public static boolean shouldAlwaysBigMethods() {
        return alwaysBigMethods;
    }

    public static void setAlwaysBigMethods() {
        alwaysBigMethods = true;
    }

    @Override
    public void workAfterWrite() {
        TukFileVerifier.getInstanceOf().execute();
    }

    @Override
    public void init(String args[]) throws Exception {
        super.init(args);
        InstructionFrequency.shouldFunction = true;
        writer = new LFWriter(args[1]);
    }

    @Override
    public void setFactoryFacade() {
        super.setFactoryFacade();
        FactoryPlaceholder.getInstanceOf().setFactory(LFFactoryFacade.getInstanceOf());
    }

    @Override
    public void setOutputWriter(String args[]) throws Exception {
        super.outputWriter = writer;
    }

    private void vmAutoGenerate() {
        logHolder.addLog("Generating vm related things like native headers....");
        HeaderFileForWantedopCodes.getInstanceOf().execute();
        NativeMethodTable.getInstanceOf().writeTable();
        ReferencesTable.getInstanceOf().writeTable();
        NativeHeaderFilePerJavaClass.getInstanceOf().writeHeaderFiles();
        if (generateSwitchNotLables) {
            GenerateSwitch.getInstanceOf().generate();
        } else {
            GenerateLabels.getInstanceOf().generate();
        }
        GenerateExceptionData.getInstanceOf().generate();
    }

    @Override
    public void execute(String args[]) throws Exception {
        super.execute(args);
        CPStatisticGenerator.getInstanceOf().cacheStatisticsJustAfterGlobalization();
        BranchInstructionsHandler.getInstanceOf().restoreBranchInformation();
        LFEngine.getInstanceOf().execute();
        logHolder.addLog("Loading format is generated....");
        vmAutoGenerate();
        CPStatisticGenerator.getInstanceOf().execute();
    }

    public static void main(String args[]) throws Exception {
        (new StartMeLF()).start(args);
    }
}
