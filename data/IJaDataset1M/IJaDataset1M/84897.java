package perun.client.dialogs.xmleditor;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.*;
import java.io.IOException;
import java.io.Reader;
import javax.swing.*;
import javax.swing.tree.DefaultTreeModel;
import javax.xml.parsers.SAXParser;
import perun.client.dialogs.xmleditor.jtreetable.JTreeTable;
import perun.client.dialogs.xmleditor.jtreetable.TreeTableModelAdapter;
import perun.common.xml.ParserFactory;
import perun.common.exception.InvalidDataException;
import perun.common.log.Log;

/**
 * Panel that shows the properties TreeTable
 */
public class XMLEditorPanel extends JPanel {

    private static final String TASKS_TAG = "task";

    private static final String BONUSES_TAG = "bonuses";

    private static final String BONUS_TAG = "bonus";

    private static final String ENTER_NEW_VALUE = "enter value";

    private final String dataTag;

    private String dataType;

    private JPopupMenu itemPopup;

    /** Creates new form XMLParametersEditor
	 *
	 * @param dataTag represents the data type shown in <code>TreeTable</code>
	 */
    public XMLEditorPanel(String dataTag) {
        this.dataTag = dataTag;
        initComponents();
        if (dataTag.equals(TASKS_TAG)) initPopupMenu();
        inputParser = ParserFactory.getNewParser();
    }

    /** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
    private void initComponents() {
        jScrollPane1 = new javax.swing.JScrollPane();
        jDataPanel = new javax.swing.JPanel();
        setLayout(new java.awt.BorderLayout());
        setPreferredSize(new java.awt.Dimension(200, 200));
        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        jDataPanel.setLayout(new java.awt.BorderLayout());
        jDataPanel.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(1, 1, 1, 1)));
        jScrollPane1.setViewportView(jDataPanel);
        add(jScrollPane1, java.awt.BorderLayout.CENTER);
    }

    private javax.swing.JScrollPane jScrollPane1;

    private javax.swing.JPanel jDataPanel;

    /**
	 * Inits popup menu for bonus add/remove
	 */
    private void initPopupMenu() {
        itemPopup = new JPopupMenu();
        JMenuItem addItem = new JMenuItem();
        JMenuItem removeItem = new JMenuItem();
        addItem.setText("Add bonus");
        addItem.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent evt) {
                itemActionPerformed(evt, true);
            }
        });
        removeItem.setText("Remove bonus");
        removeItem.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent evt) {
                itemActionPerformed(evt, false);
            }
        });
        itemPopup.add(addItem);
        itemPopup.add(removeItem);
    }

    /**
	 * Someone clicked the <code>TreeTable</code>
	 */
    private void treeTableMouseClicked(MouseEvent evt) {
        if ((treeTable != null) && (evt.getModifiers() == evt.BUTTON3_MASK)) itemPopup.show(this, evt.getX(), evt.getY());
    }

    /**
	 * Action from add/remove menu was performed
	 *
	 * @param add identifies if specified action is an addition
	 */
    private void itemActionPerformed(ActionEvent evt, boolean add) {
        if (add) {
            int rowNumber = treeTable.getSelectedRow();
            if ((rowNumber != -1) && ((treeTable.getModel().getValueAt(rowNumber, 0).equals(BONUS_TAG)) || (treeTable.getModel().getValueAt(rowNumber, 0).equals(BONUSES_TAG)))) {
                XMLTreeTableNode node = (XMLTreeTableNode) (((TreeTableModelAdapter) treeTable.getModel()).nodeForRow(rowNumber));
                XMLTreeTableNode newNode = new XMLTreeTableNode(BONUS_TAG);
                newNode.setData(ENTER_NEW_VALUE);
                if (treeTable.getModel().getValueAt(rowNumber, 0).equals(BONUSES_TAG)) ((DefaultTreeModel) dataModel).insertNodeInto(newNode, (XMLTreeTableNode) node, 0); else ((DefaultTreeModel) dataModel).insertNodeInto(newNode, (XMLTreeTableNode) node.getParent(), node.getParent().getIndex(node) + 1);
            } else JOptionPane.showMessageDialog(this, "Have to select " + BONUS_TAG + " or " + BONUSES_TAG + " tag to perform addition");
        } else {
            int rowNumber = treeTable.getSelectedRow();
            if ((rowNumber != -1) && (treeTable.getModel().getValueAt(rowNumber, 0).equals(BONUS_TAG))) {
                XMLTreeTableNode node = (XMLTreeTableNode) (((TreeTableModelAdapter) treeTable.getModel()).nodeForRow(rowNumber));
                if (node.getParent().getChildCount() <= 1) JOptionPane.showMessageDialog(this, "Cannot remove last " + BONUS_TAG + " tag"); else ((DefaultTreeModel) dataModel).removeNodeFromParent(node);
            } else JOptionPane.showMessageDialog(this, "Have to select " + BONUS_TAG + " tag to remove");
        }
    }

    SAXParser inputParser;

    XMLTreeTableModel dataModel;

    XMLTreeTableNode treeRootNode;

    JTreeTable treeTable;

    /**
	 * intializes the tree from a given stream
	 *
	 * @param initStream is a XML stream to build a tree from
	 * @return identifier String of a trigger (type)
	 */
    public void initTree(Reader initStream) throws InvalidDataException {
        XMLParametersHandler XMLHandler = new XMLParametersHandler(dataTag);
        try {
            inputParser.parse(new org.xml.sax.InputSource(initStream), XMLHandler);
            treeRootNode = XMLHandler.getTreeRoot();
            dataModel = new XMLTreeTableModel(treeRootNode);
            if (treeTable != null) jDataPanel.remove(treeTable);
            treeTable = new JTreeTable(dataModel);
            jDataPanel.add(treeTable, BorderLayout.CENTER);
            treeTable.addMouseListener(new MouseAdapter() {

                public void mouseClicked(MouseEvent evt) {
                    treeTableMouseClicked(evt);
                }
            });
            setPreferredSize(new Dimension(180, 200));
            setMinimumSize(new Dimension(180, 200));
            dataType = XMLHandler.getDataType();
        } catch (org.xml.sax.SAXException sae) {
            Log.exception(Log.ERROR, sae);
            throw new InvalidDataException(sae.toString());
        } catch (IOException ioe) {
            Log.exception(Log.CRITICAL, ioe);
        }
    }

    public String getDataType() {
        return dataType;
    }

    /**
	 * creates XML data from a tree
	 *
	 * @return XML String representing data
	 */
    public String toXML() {
        String returnValue;
        returnValue = "<" + dataTag + " type=\"" + dataType + "\">";
        if (treeRootNode != null) returnValue += treeRootNode.toXMLChildren();
        returnValue += "</" + dataTag + ">";
        return returnValue;
    }

    /**
	 * Indicated whether the data was modified
	 */
    public boolean isModified() {
        return dataModel.isDataModified();
    }
}
