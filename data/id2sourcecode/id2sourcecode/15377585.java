    public static String man(String cmd_) {
        if ("!".equals(cmd_)) {
            return "! ?-apq? <path>|<paths> ?<arg0> <arg1> ...?\n" + "     Convert the path to the reference to the Java object\n" + "     and then invoke the method specified in the argument list.\n";
        } else if ("!!!".equals(cmd_)) {
            return "!!! <obj_ref>\n" + "     Cast the object reference to its most specific class.\n";
        } else if ("attach".equals(cmd_)) {
            return "attach ?-c? <src path>... -to|-with <dest path>...\n" + "     Attaches components/ports in <src path>s to/with components/ports in <dest path>.\n" + "     If components are specified in the paths, the command finds available ports\n" + "     in the components to do the attachment.\n" + "Options:\n" + "     -c    Creates port if not existent.\n" + "     -to   Attached to listen to the outputs of the destination ports.\n" + "     -with Attached to listen to whatever the destination ports listen to.\n" + "See Also:\n" + "     detach, connect.\n";
        } else if ("attach_simulator".equals(cmd_)) {
            return "attach_simulator ?-aq? ?<#threads allowed> | event? <path1> ?<path2>...?\n" + "     Attaches a default simulation runtime to components specified in the path(s).\n" + "    ï¿½If # of threads allowed is not specified, the runtime creates as many threads\n" + "     as possible if needed.\n" + "Options:\n" + "     -a      Match all hidden components.\n" + "     -q      Suppress verbose warnings such as \"invalid path\".\n" + "  event      Use sequential event simulation runtime rather than the real-time one.\n";
        } else if ("cat".equals(cmd_)) {
            return "cat ?-acdhnpqt? ?<path>\n" + "cat <java_object_reference>\n" + "     Print out the information of the component or object.\n" + "     -a      Match all hidden components (and ports if -p is specified).\n" + "     -c      Display only the connections for a component.\n" + "     -d      Display both the internal states and the connections in details\n" + "             for a component.\n" + "     -h      Display hidden ports when displaying connections (-c).\n" + "     -n      Display ports that do not connect to other ports when displaying\n" + "             connections (-c).\n" + "     -p      Match ports as well.\n" + "     -q      Suppress verbose warnings such as \"invalid path\".\n" + "     -t      Display the port type when displaying connections (-c).\n" + "Note:\n" + "     The second form is particularly useful in examining the contents of a Java array.\n";
        } else if ("cd".equals(cmd_)) {
            return "cd ?-aq? ?<path?>\n" + "     Change the current directory.\n" + "     If multiple components are matched to the path, the first matched component\n" + "     becomes the current working directory. No specific rule is defined in\n" + "     determining the first match.\n" + "Options:\n" + "     -a      Match all hidden components.\n" + "     -q      Suppress verbose warnings such as \"invalid path\".\n";
        } else if ("connect".equals(cmd_)) {
            return "connect ?-acpqs? <src path>... -to|-and <dest path>...\n" + "     Connects components/ports in <src path>s to components/ports in <dest path>.\n" + "     If components are specified in the paths, the command finds available ports\n" + "     in the components in order to make the connections.\n\n" + "     A bidirectional connection either consists of two unidirectional connections\n" + "     or one shared connection. By default (no -s option), the command creates two\n" + "     unidirectional connections in response to the -and option.\n\n" + "     The original connections (if exist) of the ports will be joined all together\n" + "     on the same wire after connect.\n" + "Options:\n" + "     -a    Match all hidden components (and ports if -p is specified).\n" + "     -c    Create ports if the ports do not exist.\n" + "     -p    Match ports as well.\n" + "     -q    Suppress verbose warnings such as \"invalid path\".\n" + "     -s    Set up one shared bidirectional connection (with -and).\n" + "     -and  Sets up bidirectional connection.\n" + "     -to   Sets up unidirectional connection (destination ports are set as IN type).\n" + "See Also:\n" + "     disconnect.\n";
        } else if ("cp".equals(cmd_)) {
            return "cp ?-apq? <source path>... <dest path>\n" + "cp ?-apq? <source path>... -d <dest path>...\n" + "     Copy components/ports.  This command returns the references of the object(s)\n" + "     being copied.\n";
        } else if ("detach".equals(cmd_)) {
            return "detach ?-apq? <instrument_port_path>... -to|-with <destination_path>...\n" + "     Detaches an instrument port.\n" + "Options:\n" + "     -a     Match all hidden components (and ports if -p is specified).\n" + "     -p     Match ports as well.\n" + "     -q     Suppress verbose warnings such as \"invalid path\".\n" + "     -to    Remove the instrument port from listening to what comes out of the\n" + "            specified ports.\n" + "     -with  Remove the instrument port from listening to what the specified ports\n" + "            receive.\n" + "See Also:\n" + "     attach.\n";
        } else if ("disconnect".equals(cmd_)) {
            return "disconnect ?-apq? <path>...\n" + "     Disconnects components/ports specified in <path>s.  If components are specified\n" + "     in the path(s), all the ports of the components are disconnected from the rest\n" + "     of the system.\n" + "Options:\n" + "     -a     Match all hidden components (and ports if -p is specified).\n" + "     -p     Match ports as well.\n" + "     -q     Suppress verbose warnings such as \"invalid path\".\n" + "See Also:\n" + "     connect.\n";
        } else if ("exit".equals(cmd_)) {
            return "exit\n" + "     Close the current terminal.  If the current terminal is the last one, then\n" + "     the command exits Java.\n";
        } else if ("explore".equals(cmd_)) {
            return "explore ?-aq? <path of starting component> ?-transparent <path>...? ?-excluded <path>...? ?-stop <path>...?\n" + "     Explore and print the component topology.\n\n" + "     This command explores the component topology by tracing from the starting\n" + "     component, all the way to the root component. During the exploration process,\n" + "     if the -f flag is not on (default), the command does not trace into a containing\n" + "     component. As a result, the components that can be traced from the starting\n" + "     component are at the same (component hierarchy) layer as, or higher layer than,\n" + "     the starting component.\n\n" + "     One may specify components (in the -transparent option) as transparent during\n" + "     the course of exploration. Also components may be (in the -excluded option)\n" + "     excluded from the topology exploration.\n" + "Options:\n" + "     -a                  Match all hidden components.\n" + "     -excluded <...>     Exclude the components from being explored.\n" + "     -f                  Discover the \"flat\" topology of all \"leaf\" components reached.\n" + "     -q                  Suppress verbose warnings such as \"invalid path\".\n" + "     -stop <...>         Implies the \"-f\" option.  It stops exploring further inside the \"stop\" components.\n" + "     -transparent <...>  Make the components transparent in the exploration.\n";
        } else if ("getflag".equals(cmd_)) {
            return "getflag ?-adlpq? <path>...\n" + "     Displays the flags of the given components.\n" + "     By default, this command only examines the following standard component flags\n" + "     and display enabled ones: Trace, Garbage, GarbageDisplay, Debug, ErrorNotice\n" + "     and EventExport. The option \"-l\" makes the command examine all the programmable\n" + "     flags.  A programmable flag is found by discovering the pair of the \"read\" method,\n" + "     is<flag>Enabled(), and the \"write\" method, set<flag>Enabled(boolean), in the\n" + "     component (or more precisely, in the component's JavaBeans properties).\n" + "     With the \"-d\" option, the command displays not only the enabled flags but also\n" + "     the disabled ones, for reference purpose.\n" + "Options:\n" + "     -a    Match all hidden components (and ports if -p is specified).\n" + "     -d    Displays disabled flags as well.\n" + "     -l    Displays all the programmable flags in addition to the standard ones.\n" + "     -p    Match ports as well.\n" + "     -q    Suppress verbose warnings such as \"invalid path\".\n" + "See Also:\n" + "     setflag.\n";
        } else if ("grep".equals(cmd_)) {
            return "grep <pattern> <text>\n" + "     Searches a pattern in a big chunk of text and prints the result.\n";
        } else if ("inject".equals(cmd_)) {
            return "inject ?-apq? <data> <port path>...\n" + "     Inject data to port(s).\n" + "Options:\n" + "     -a    Match all hidden components (and ports if -p is specified).\n" + "     -p    Match ports as well.\n" + "     -q    Suppress verbose warnings such as \"invalid path\".\n";
        } else if ("ls".equals(cmd_)) {
            return "ls ?-apql? ?<path>...?\n" + "     List the child components/ports in the paths specified.\n" + "Options:\n" + "     -a    Match all hidden components (and ports if -p is specified).\n" + "     -l    List in the long format (more detailed information).\n" + "     -p    Match ports as well.\n" + "     -q    Suppress verbose warnings such as \"invalid path\".\n";
        } else if ("mkdir".equals(cmd_)) {
            return "mkdir ?-aq? <Java class name> <path>...\n" + "mkdir ?-aq? <Java object ref> <path>...\n" + "mkdir ?-aq? <port path> ?<port path>...?\n" + "mkdir ?-aq? <component path>\n" + "     Create components/ports.  This command returns the reference of the\n" + "     object(s) being created.  If the class name or the Java object is not\n" + "     a component/port, a wrapper component (drcl.comp.WrapperComponent) is\n" + "     created to encapsulate the object.\n\n" + "     The fourth form uses the default class to create component(s) at the\n" + "     specified path.  It is equivalent to\n\n" + "          mkdir ?-aq? <default_class> <component_path>\n\n" + "Options:\n" + "     -a    Match all hidden components.\n" + "     -q    Suppress verbose warnings such as \"invalid path\".\n" + "See Also:\n" + "     set_default_class, whats_default_class\n";
        } else if ("mv".equals(cmd_)) {
            return "mv ?-apq? <source path>... <dest path>\n" + "mv ?-apq? <source path>... -d <dest path>...\n" + "     Move components/ports.  This command returns the reference of the\n" + "     object(s) being moved.  Note that the command does not change the\n" + "     connections of the moved components/ports.\n\n" + "     The second form of this command is the same as \"cp\" except that the\n" + "     source components are removed from the original directories and moved\n" + "     to the first directory component specified in the destination path(s).\n" + "Options:\n" + "     -a    Match all hidden components (and ports if -p is specified).\n" + "     -p    Match ports as well.\n" + "     -q    Suppress verbose warnings such as \"invalid path\".\n" + "See Also:\n" + "     disconnect\n";
        } else if ("nlines".equals(cmd_)) {
            return "nlines <text>\n" + "     Count and print the number of lines in a chunk of text.\n";
        } else if ("pipe".equals(cmd_)) {
            return "pipe ?-a? ?-break|-connect? <path1> ?<path2>...?\n" + "     Connect/break a series of components/ports in a pipe manner.\n" + "Options:\n" + "     -a         Form the pipe by \"attach\" instead of \"connect\".\n" + "     -connect   Connect a pipe, the default action if none is specified.\n" + "     -break     Break a pipe.\n" + "See Also:\n" + "     attach, connect.\n";
        } else if ("pwd".equals(cmd_)) {
            return "pwd\n" + "     Print the current working path.\n";
        } else if ("reboot".equals(cmd_)) {
            return "reboot ?-apq? <path1> ?<path2>...?\n" + "     Reset components and the runtime(s) behind components.  The command\n" + "     calls drcl.comp.Component.reboot() for all the components specified\n" + "     in the path(s).\n" + "Options:\n" + "     -a    Match all hidden components (and ports if -p is specified).\n" + "     -p    Match ports as well.\n" + "     -q    Suppress verbose warnings such as \"invalid path\".\n" + "See Also:\n" + "     reset\n";
        } else if ("reset".equals(cmd_)) {
            return "reset ?-apq? <path1> ?<path2>...?\n" + "     Reset components.\n" + "Options:\n" + "     -a    Match all hidden components (and ports if -p is specified).\n" + "     -p    Match ports as well.\n" + "     -q    Suppress verbose warnings such as \"invalid path\".\n" + "See Also:\n" + "     reboot\n";
        } else if ("resume".equals(cmd_)) {
            return "resume ?-apq? <path1> ?<path2>...?\n" + "     Resume (stopped) components and all the components within.\n" + "Options:\n" + "     -a    Match all hidden components (and ports if -p is specified).\n" + "     -p    Match ports as well.\n" + "     -q    Suppress verbose warnings such as \"invalid path\".\n" + "See Also:\n" + "     run, stop\n";
        } else if ("rm".equals(cmd_)) {
            return "rm ?-apq? <path1> ?<path2>...?\n" + "     Remove components/ports.  This command returns the object(s) being removed.\n" + "     The removed components/ports are not disconnected.\n" + "Options:\n" + "     -a    Match all hidden components (and ports if -p is specified).\n" + "     -p    Match ports as well.\n" + "     -q    Suppress verbose warnings such as \"invalid path\".\n" + "See Also:\n" + "     disconnect\n";
        } else if ("rt".equals(cmd_)) {
            return "rt ?-apq? <path> ?<method> ?<arg>...??\n" + "     Access runtime and its information.  The command retrieves the runtime\n" + "     behind the component specified, and does a method call on the runtime if\n" + "     a method is specified.\n" + "Options:\n" + "     -a    Match all hidden components (and ports if -p is specified).\n" + "     -p    Match ports as well.\n" + "     -q    Suppress verbose warnings such as \"invalid path\".\n";
        } else if ("run".equals(cmd_)) {
            return "run ?-apq? <path1> ?<path2>...?\n" + "     Start (active) components and all the components within.\n" + "Options:\n" + "     -a    Match all hidden components (and ports if -p is specified).\n" + "     -p    Match ports as well.\n" + "     -q    Suppress verbose warnings such as \"invalid path\".\n" + "See Also:\n" + "     stop, resume\n";
        } else if ("script".equals(cmd_)) {
            return "script <script> ?-at <time> ?later?? ?-period <period>? ?-to <runtime instance>?\n" + "     ?-shell <shell instance>?\n" + "     Execute a script at a future time instant (recursively).\n" + "Options:\n" + "     -at <...>       The time instant to execute this script the first time\n" + "        ?later?      (default: 0.0).  The time instant is relative if \"later\" is\n" + "                     present.\n" + "     -period <...>   Execute this script periodically (default: 0.0, execute only one time).\n" + "     -shell <...>    Associate execution of this script to the shell (default:\n" + "                     the current shell instance).\n" + "     -on <...>       Associate execution of this script to the runtime instance\n" + "                     (default: the default runtime instance).\n";
        } else if ("setflag".equals(cmd_)) {
            return "setflag ?-apq? <flag>... <enabled> ?-at <list_of_debug_levels>?\n" + "     ?<recursively>? <path1> ?<path2>...?\n" + "     Turn on/off the given flags on the components/objects.\n\n" + "     The command enables/disables the given flag(s) on the matched components/objects.\n" + "     Six flags are defined for drcl.comp.Component: Trace, Garbage, GarbageDisplay, Debug,\n" + "     ErrorNotice and EventExport. Additional flags that are defined in sub-components or\n" + "     objects may be enabled/disabled by this command as well.\n\n" + "     A component may define debug levels to further classify debug messages. Each level\n" + "     can be enabled/disabled individually with the \"-at\" option. Enabling the debug flag\n" + "     of a component without specifying debug levels enables the debug flag and all the\n" + "     debug levels if defined. Available debug levels can be shown with the getflag\n" + "     command.\n" + "Options:\n" + "     -a    Match all hidden components (and ports if -p is specified).\n" + "     -at   Enable/disable debug levels.\n" + "     -p    Match ports as well.\n" + "     -q    Suppress verbose warnings such as \"invalid path\".\n" + "See Also:\n" + "     getflag.\n";
        } else if ("set_default_class".equals(cmd_)) {
            return "set_default_class ?class_name?\n" + "     Set the name of the default class for 'mkdir' a component without the class\n" + "     or object argument.  If class_name is not specified, 'drcl.comp.Component'\n" + "     is used instead.\n" + "See Also:\n" + "     mkdir, whats_default_class.\n";
        } else if ("stop".equals(cmd_)) {
            return "stop ?-apq? <path1> ?<path2>...?\n" + "     Stop (active) components and all the components within.\n" + "Options:\n" + "     -a    Match all hidden components (and ports if -p is specified).\n" + "     -p    Match ports as well.\n" + "     -q    Suppress verbose warnings such as \"invalid path\".\n" + "See Also:\n" + "     run, resume\n";
        } else if ("subtext".equals(cmd_)) {
            return "subtext <text> <start line #> <end line #>\n" + "     Extracts lines of text from text.\n";
        } else if ("term".equals(cmd_)) {
            return "term title ?-t <term_class>? ?-s <shell_class>|<shell_object>? ?<init script>?\n" + "     Open a new terminal.\n" + "     Default <term_class> is drcl.ruv.Dterm.\n" + "     Default <shell_class> is drcl.ruv.ShellTcl.\n";
        } else if ("wait_until".equals(cmd_)) {
            return "wait_until <condition>\n" + "     Blocks the terminal until the specified condition is met.\n" + "     <condition> is a script that returns a boolean value.\n" + "     This command can only be used as a standalone command. The result will not\n" + "     be predictable if it is used in other commands such as \"if\"\n";
        } else if ("watch".equals(cmd_)) {
            return "watch ?-acpq? ?-label <label>? -add|-remove <path>...\n" + "     Add/remove a system watcher at the system monitor /.system/monitor.\n" + "     The events observed by the watcher are output to whichever components\n" + "     that are connected to the system monitor.\n\n" + "     The command attaches a port of the RUV system watcher component to the ports\n" + "     specified in the destination path(s). Then the watcher port starts to listen\n" + "     to what comes out of the specified ports and prints whatever it receives on\n" + "     the terminal. One may add and remove multiple watchers in a command. For example,\n\n" + "         watch -label L1 -add x@p1 y@p2 -remove z@p3 -label none -add w@p4 u@p5\n\n" + "     adds x@p1 and y@p2 to the L1 watcher and removes z@p3 from the L1 watcher,\n" + "     and adds w@p4 and u@p5 to the default watcher (with no label).\n" + "Options:\n" + "     -a      Match all hidden components (and ports if -p is specified).\n" + "     -c      Create ports if the specified ports do not exist.\n" + "     -label  The watcher label\n" + "     -p      Match ports as well.\n" + "     -q      Suppress verbose warnings such as \"invalid path\".\n";
        } else if ("whats_default_class".equals(cmd_)) {
            return "whats_default_class\n" + "     Prints the name of the default class for 'mkdir'.\n" + "See Also:\n" + "     mkdir, set_default_class\n";
        } else {
            return "Unrecognized command.\n";
        }
    }
