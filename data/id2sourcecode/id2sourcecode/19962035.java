    private static final void makeWF_BasicJavaWriterFormat_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicJavaWriterFormat.jwf", "!<header>\n\n\n\n$<{java.CodeWriter.package>package $<java.CodeWriter.package>;$<}java.CodeWriter.package>\n\n\n\nimport java.io.*;\nimport java.util.*;\n\n\n\n\n!<{import>// section:import\n!<import>!<}import>\n\n\n\npublic class $<main.CodeWriter> \n$<{java.CodeWriter.extends>  extends $<java.CodeWriter.extends> $<}java.CodeWriter.extends> \n$<{java.CodeWriter.implements>  implements $<java.CodeWriter.implements> $<}java.CodeWriter.implements>\n{\n\n  /* Constants << */\n \n  // Command line arguments\n  public static final String WRITER__ARGUMENT_CONTROL_PREFIX = \"$<main.CodeWriter.argument.ControlPrefix>\";\n  public static final String WRITER__ARGUMENT_OutputFolder   = \"$<main.CodeWriter.argument.name.OutputFolder>\";\n  public static final String WRITER__ARGUMENT_MetaPropFile   = \"$<main.CodeWriter.argument.name.MetaPropFile>$<main.CodeWriter.argument.name.BuildPropFile>\";\n  public static final String WRITER__ARGUMENT_BackupFolder   = \"$<main.CodeWriter.argument.name.BackupFolder>\";\n  public static final String WRITER__ARGUMENT_NoBackup       = \"$<main.CodeWriter.argument.name.NoBackup>\";\n\n  // User Interface text message parts\n  public static final String WRITER__UITEXT_Method                     = \"method \";\n  public static final String WRITER__UITEXT_Main                       = \"main \";\n  public static final String WRITER__UITEXT_ExceptionIn                = \"Exception in \";\n  public static final String WRITER__UITEXT_ColonNewLine               = \":\\n\";\n  public static final String WRITER__UITEXT_NewLine                    = \"\\n\";\n  public static final String WRITER__UITEXT_Section                    = \"section \";\n  public static final String WRITER__UITEXT_SavedFile                  = \"Saved file:       \";\n  public static final String WRITER__UITEXT_UnableToSaveFile           = \"Unable to save file: \";\n  public static final String WRITER__UITEXT_UnableToBackupFile         = \"Unable to backup file: \";\n  public static final String WRITER__UITEXT_ToBackupFolder             = \" to backup folder: \";\n  public static final String WRITER__UITEXT_BackupFolderColon          = \"Backup folder: \";\n  public static final String WRITER__UITEXT_BackupFolderExistFailure   = \" does not exist and cannot be created.\";\n  public static final String WRITER__UITEXT_BackupFolderNotAFolder     = \" is not a folder.\";\n  public static final String WRITER__UITEXT_BackupFolderNotWritable    = \" is not writable.\";\n  public static final String WRITER__UITEXT_CodeWriterState            = \"Code Writer State: \";\n  public static final String WRITER__UITEXT_GetFileIndexEquals         = \"\\n_getFileIndex()    = \";\n  public static final String WRITER__UITEXT_GetFullFileNameEquals      = \"\\n_getFullFileName() = \";\n  public static final String WRITER__UITEXT_GetOutputFolderEquals      = \"\\n_getOutputFolder() = \";\n  public static final String WRITER__UITEXT_ErrorHeader                = \"\\n\\n--- CodeWriter Error Description Start ---\\n\\n\";\n  public static final String WRITER__UITEXT_ErrorFooter                = \"\\n--- CodeWriter Error Description End -----\\n\\n\";\n  public static final String WRITER__UITEXT_UnableToLoadMetaProps      = \"Unable to load metadata from file: \";\n  public static final String WRITER__UITEXT_UndefinedProperty          = \"Undefined property: \";\n  public static final String WRITER__UITEXT_UnableToCreateOutputFolder = \"Unable to create output folder: \";\n  public static final String WRITER__UITEXT_PlaceHolderException \n    = \"This placeholder Exception should never be thrown: there is an error in the WriterFormat.\";\n\n  // String constants \n  public static final String WRITER__STRING_empty                    = \"\";\n  public static final String WRITER__STRING_dot                      = \".\";\n  public static final String WRITER__STRING_separator                = File.separator;\n\n  public static final int WRITER__FILE_BUFFER_SIZE                   = 4096;  // initial size of StringBuffer\n\n  /* Constants >> */\n\n\n\n\n  /* Writer Variables << */\n\n  protected String[]     writer__iFileNameRoots    = new String[] {};      // generated file name roots\n  protected int          writer__iNumFiles         = 0;                    // number of generated files\n  \n  protected String       writer__iFileNamePrefix   = WRITER__STRING_empty; // failsafe default\n  protected String       writer__iFileNameSuffix   = WRITER__STRING_empty; // failsafe default\n\n  protected String       writer__iBackupPrefix     = WRITER__STRING_empty; // failsafe default\n  protected String       writer__iBackupSuffix     = WRITER__STRING_empty; // failsafe default\n\n  protected StringBuffer writer__iCurrentText      = new StringBuffer();   // current text\n  protected int          writer__iCurrentFileIndex = 0;                    // current file index\n\n  protected String[]     writer__iArgs             = new String[0];        // cmd line args\n  protected int          writer__iNumArgs          = 0;                    // number of cmd line args\n  protected String[]     writer__iUserArgs         = new String[0];        // user cmd line args\n  protected int          writer__iNumUserArgs      = 0;                    // number of user cmd line args\n\n  protected boolean      writer__iSave             = true;                 // save generated code to disk\n  protected boolean      writer__iBackup           = true;                 // make backups\n\n  protected String       writer__iOutputFolder     = WRITER__STRING_dot;   // written code is output to this folder\n  protected String       writer__iBackupFolder     = WRITER__STRING_dot;   // overwritten files are placed here\n  protected String       writer__iMetaPropFile     = null;                 // metadata properties file path\n\n  protected Properties   writer__iProperties       = null;                 // build properties\n  protected boolean      writer__iPropertiesInit   = false;                // true => lookup table initialiased\n\n  protected Object       writer__iContext          = null;                 // context object\n  protected Object       writer__iResult           = null;                 // result object\n\n  protected boolean      writer__iThrow            = false;                // throw Exceptions\n\n  /* Writer Variables >> */\n\n\n  !<{support>\n  // version 0.1 compatibility\n  // section:support\n  !<support>!<}support>\n\n\n\n  !<{declare>// section:declare\n  !<declare>!<}declare>\n\n\n\n\n  /** Execute. */\n  public static void main( String pArgs[] ) {\n    $<main.CodeWriter> cw = new $<main.CodeWriter>();\n    Object result = cw._generate( pArgs, false );\n    \n    int exitvalue = 0;\n    if( result instanceof Integer ) {\n      exitvalue = ((Integer)result).intValue();\n    }\n\n    System.exit( exitvalue );\n  }\n\n\n\n\n  /* Writer Services << */\n\n  /** Generate. */\n  public Object _generate( String[] pArgs ) {\n    return _generate( pArgs, false );\n  }\n\n\n  /** Generate. */\n  public Object _generate( String[] pArgs, boolean pThrow ) {\n     writer__iThrow = pThrow;\n\n    try {\n      writer__initialize();\n      writer__handleArgs( pArgs );\n      writer__write();    \n\n      Object result = _getResult();\n      if( null == result ) {\n        result = _getText();\n        _setResult( result );\n      }\n\n      return result;\n    } \n    catch( RuntimeException re ) { throw re; }\n    catch( Exception e ) {\n      writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Method + WRITER__UITEXT_Main, e );\n      return new Integer(1);\n    }\n  }\n\n\n  /* Initialize. */\n  public void writer__initialize() {\n    writer__iCurrentFileIndex = 0;\n    writer__setDefaults();\n  }\n\n\n\n  /** Main file generation loop. Template script is placed here in the body section. */\n  public void writer__write() {\n    if( false ) { throw new RuntimeException( WRITER__UITEXT_PlaceHolderException ); }\n\n    // initialize\n    String writer__currentSection = \"init\";\n\n    try {\n      if( false ) { throw new RuntimeException( WRITER__UITEXT_PlaceHolderException ); }\n\n      !<{init>// section:init\n      !<init>!<}init>\n\n\n      // write files loop\n      int      writer__numFiles = _getNumFiles();\n      int      writer__fileI    = 0;\n      writer__next_file: for( writer__fileI = 0; writer__fileI < writer__numFiles; writer__fileI = writer__fileI + 1 ) {\n\n        try {\n          if( false ) { throw new RuntimeException( WRITER__UITEXT_PlaceHolderException ); }\n\n\n          !<{prewrite>// section:prewrite\n          writer__currentSection = \"prewrite\";\n          !<prewrite>!<}prewrite>\n\n\n          if( ! writer__startFile() ) { continue writer__next_file; }\n\n\n          !<{body>// section:body\n          writer__currentSection = \"body\";\n          !<body>!<}body>\n\n\n          if( ! writer__endFile() ) { continue writer__next_file; }\n\n\n          !<{postwrite>// section:postwrite\n          writer__currentSection = \"postwrite\";\n          !<postwrite>!<}postwrite>\n\n\n        } \n        catch( RuntimeException re ) { throw re; }\n        catch( Exception e ) {\n           writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Section + writer__currentSection, e );\n        }\n\n        writer__nextFile();       \n      }\n \n\n      !<{cleanup>// section:cleanup\n      writer__currentSection = \"cleanup\";\n      !<cleanup>!<}cleanup>\n\n    } \n    catch( RuntimeException re ) { throw re; }\n    catch( Exception e ) {\n      writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Section + writer__currentSection, e );\n    }\n  }\n\n\n\n  /** Start writing a file. */\n  public boolean writer__startFile() {\n    writer__iCurrentText = new StringBuffer( WRITER__FILE_BUFFER_SIZE );\n    return true;\n  }\n\n\n\n  /** End writing a file. */\n  public boolean writer__endFile() {\n    boolean endOK = true;\n  \n    String filePath = \"output-file-path\";\n\n    if( endOK ) {\n      String fileName = _getFullFileName();\n      filePath \n        = writer__iOutputFolder\n        + WRITER__STRING_separator\n        + fileName;\n\n      if( writer__iBackup ) {\n        try {\n          writer__backup( filePath, fileName, writer__iBackupFolder );\n        } \n        catch( RuntimeException re ) { throw re; }\n        catch( Exception e ) {\n          writer__handleException( WRITER__UITEXT_UnableToBackupFile \n                                   + filePath \n                                   + WRITER__UITEXT_ToBackupFolder\n                                   + writer__iBackupFolder\n                                   ,e );\n          endOK = false;\n        }\n      }\n    }\n\n    File outputFolder = null;\n    try {\n      outputFolder = new File( filePath ).getParentFile();\n      if( null != outputFolder && !outputFolder.exists() ) {\n        outputFolder.mkdirs();\n      }\n    }\n    catch( RuntimeException re ) { throw re; }\n    catch( Exception e ) {\n      writer__handleException( WRITER__UITEXT_UnableToCreateOutputFolder \n                               + outputFolder\n                               ,e );\n      endOK = false;\n    }\n\n\n    if( endOK && writer__iSave ) {\n      try {\n        _saveTextFile( filePath, writer__iCurrentText.toString() );\n        writer__userMessage( WRITER__UITEXT_SavedFile + filePath + WRITER__UITEXT_NewLine, false );\n      } \n      catch( RuntimeException re ) { throw re; }\n      catch( Exception e ) {\n        writer__handleException( WRITER__UITEXT_UnableToSaveFile + filePath, e );\n        endOK = false;\n      }\n    }\n\n    return endOK;\n  }\n\n\n\n  /** Move to next file. */\n  public void writer__nextFile() {\n    writer__iCurrentFileIndex = writer__iCurrentFileIndex + 1;\n  }\n\n\n\n  /** Handle command line arguments to CodeWriter. */\n  public void writer__handleArgs( String[] pArgs ) {\n\n    // set arg names\n    String argName_OutputFolder     = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_OutputFolder;\n    String argName_MetaPropFile     = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_MetaPropFile;\n    String argName_BackupFolder     = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_BackupFolder;\n    String argName_NoBackup         = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_NoBackup;\n\n    // parse\n    int numArgs = pArgs.length;\n    for(int argI = 0; argI < numArgs; argI = argI + 1 ) {\n      if( 0 < argName_OutputFolder.length() && pArgs[argI].startsWith( argName_OutputFolder ) ) {\n        _setOutputFolder( pArgs[ argI ].substring( argName_OutputFolder.length() ) );\n      }\n      else if( 0 < argName_MetaPropFile.length() && pArgs[argI].startsWith( argName_MetaPropFile ) ) {\n        _setMetaPropFile( pArgs[ argI ].substring( argName_MetaPropFile.length() ) );\n      }\n      else if( 0 < argName_BackupFolder.length() && pArgs[argI].startsWith( argName_BackupFolder ) ) {\n        _setBackupFolder( pArgs[ argI ].substring( argName_BackupFolder.length() ) );\n      }\n      else if( 0 < argName_NoBackup.length() && argName_NoBackup.equals( pArgs[ argI ] ) ) {\n        _backup( $<lang.FalseString> ); // NOTE: -B => don't make backups\n      }\n    }\n\n    writer__initArgs( pArgs.length, pArgs );\n  }\n\n\n\n  /** Set defaults from configuration property set. */\n  public void writer__setDefaults() {\n\n    $<{main.FileNameRoot>_setFileNameRoot( \"$<\\main.FileNameRoot>\" );$<}main.FileNameRoot>\n    $<{main.FileNamePrefix>_setFileNamePrefix( \"$<\\main.FileNamePrefix>\" );$<}main.FileNamePrefix>\n    $<{main.FileNameSuffix>_setFileNameSuffix( \"$<\\main.FileNameSuffix>\" );$<}main.FileNameSufffix>\n\n    $<{main.OutputFolder>_setOutputFolder( \"$<\\main.OutputFolder>\" );$<}main.OutputFolder>\n\n    $<{main.BackupFolder>_setBackupFolder( \"$<\\main.BackupFolder>\" );$<}main.BackupFolder>\n    $<{main.BackupPrefix>_setBackupPrefix( \"$<\\main.BackupPrefix>\" );$<}main.BackupPrefix>\n    $<{main.BackupSuffix>_setBackupSuffix( \"$<\\main.BackupSuffix>\" );$<}main.BackupSufffix>\n    _backup( \"$<lang.TrueString>\".equals( \"$<jostraca.MakeBackup>\" ) );\n\n  }\n\n\n\n  /** Initialize command line arguments. */\n  public void writer__initArgs( int pNumArgs, String[] pArgs ) {\n    int      argI        = 0;\n    int      userArgI    = 0;\n\n    writer__iNumArgs     = pNumArgs;\n    writer__iArgs        = pArgs;\n    writer__iNumUserArgs = writer__iNumArgs;\n\n    for( argI = 0; argI < writer__iNumArgs; argI = argI + 1 ) {\n      if( writer__iArgs[argI].startsWith( WRITER__ARGUMENT_CONTROL_PREFIX ) ) {\n        writer__iNumUserArgs = writer__iNumUserArgs - 1;\n      }\n    }\n\n    writer__iUserArgs = new String[ writer__iNumUserArgs ];\n    for( argI = 0; argI < writer__iNumArgs; argI = argI + 1 ) {\n      if( !writer__iArgs[argI].startsWith( WRITER__ARGUMENT_CONTROL_PREFIX ) ) {\n        writer__iUserArgs[ userArgI ] = writer__iArgs[ argI ];\n        userArgI = userArgI + 1;\n      }\n    }\n  }\n\n\n\n  /** Print a user readable message. */\n  public void writer__userMessage( String pMessage, boolean pIsError ) {\n    (pIsError?System.err:System.out).print( pMessage );\n  }\n\n\n\n  /** Handle exceptions: print an explanation for user. */\n  public void writer__handleException( String pMessage, Exception pException ) {\n\n    StringBuffer userMsg = new StringBuffer();\n\n    userMsg.append( WRITER__UITEXT_ErrorHeader );\n\n    userMsg.append( writer__describeState() + pMessage + WRITER__UITEXT_ColonNewLine );\n\n    StringWriter stringWriter = new StringWriter();\n    pException.printStackTrace( new PrintWriter( stringWriter) );\n    userMsg.append( stringWriter.toString() );\n\n    userMsg.append( WRITER__UITEXT_ErrorFooter );\n\n    if( writer__iThrow ) {\n      throw new RuntimeException( userMsg.toString() );\n    }\n    else {\n      writer__userMessage( userMsg.toString(), true );\n    }\n  }\n\n\n\n  /** Provide a concise description of the state of the CodeWriter. */\n  public String writer__describeState() {\n    String currentState \n      = WRITER__UITEXT_CodeWriterState\n      + WRITER__UITEXT_GetFileIndexEquals    + _getFileIndex() \n      + WRITER__UITEXT_GetFullFileNameEquals + _getFullFileName()\n      + WRITER__UITEXT_GetOutputFolderEquals + _getOutputFolder()\n      + WRITER__UITEXT_NewLine\n      ; \n    return currentState;\n  }\n\n\n\n  /** Backup overwritten files, if they exist.\n   *  Backups have the format: [YYYYMMDDhhmmss][prefix][filename][suffix].\n   */ \n  public void writer__backup( String pFilePath, String pFileName, String pBackupFolder ) {\n\n    File backupFolder = new File( pBackupFolder );\n\n    // check backup folder ( create if necessary )\n    if( ! backupFolder.exists() ) {\n      if( ! backupFolder.mkdirs() ) {\n        throw new RuntimeException( WRITER__UITEXT_BackupFolderColon\n                                    + backupFolder\n                                    + WRITER__UITEXT_BackupFolderExistFailure );\n      }\n    }\n    if( ! backupFolder.isDirectory() ) {\n      throw new RuntimeException( WRITER__UITEXT_BackupFolderColon \n                                  + backupFolder\n                                  + WRITER__UITEXT_BackupFolderNotAFolder );\n    }\n    if( ! backupFolder.canWrite() ) {\n      throw new RuntimeException( WRITER__UITEXT_BackupFolderColon\n                                  + backupFolder\n                                  + WRITER__UITEXT_BackupFolderNotWritable );\n    }\n\n    // create backup file path\n    Calendar calendar = Calendar.getInstance();\n    String year_yyyy = _align( String.valueOf( calendar.get(Calendar.YEAR) ),         \"0\", 4, 'r' );\n    String month_mm  = _align( String.valueOf( (1+calendar.get(Calendar.MONTH)) ),    \"0\", 2, 'r' );\n    String day_dd    = _align( String.valueOf( calendar.get(Calendar.DAY_OF_MONTH) ), \"0\", 2, 'r' );\n    String hour_hh   = _align( String.valueOf( calendar.get(Calendar.HOUR_OF_DAY) ),  \"0\", 2, 'r' );\n    String minute_mm = _align( String.valueOf( calendar.get(Calendar.MINUTE) ),       \"0\", 2, 'r' );\n    String second_ss = _align( String.valueOf( calendar.get(Calendar.SECOND) ),       \"0\", 2, 'r' );\n    String dateTime       = year_yyyy+month_mm+day_dd+hour_hh+minute_mm+second_ss;\n    String backupFileName = dateTime + writer__iBackupPrefix + pFileName + writer__iBackupSuffix;\n    File   backupFilePath = new File( pBackupFolder, backupFileName );\n    \n    File   fullBackupFolder = backupFilePath.getParentFile();\n    if( null != fullBackupFolder && !fullBackupFolder.exists() ) {\n      if( ! fullBackupFolder.mkdirs() ) {\n        throw new RuntimeException( WRITER__UITEXT_BackupFolderColon\n                                    + fullBackupFolder\n                                    + WRITER__UITEXT_BackupFolderExistFailure );\n      }\n    }\n\n\n    // save backup file\n    File fileToBackup = new File( pFilePath );\n    if( fileToBackup.exists() ) {\n      String fileContents = _loadTextFile( pFilePath );\n      _saveTextFile( backupFilePath.getPath(), fileContents );\n    }\n  }\n\n\n\n  /** Load build properties. */\n  public void writer__initProperties() {\n\n    String metaPropFile = _getMetaPropFile();\n    if( null != metaPropFile ) {\n      writer__iProperties = new Properties();\n      \n      try {\n        FileInputStream fis = new FileInputStream( _getMetaPropFile() );\n        writer__iProperties.load( fis );\n        fis.close();\n      }\n      catch( RuntimeException re ) { throw re; }\n      catch( Exception e ) {\n        writer__handleException( WRITER__UITEXT_UnableToLoadMetaProps+_getMetaPropFile(), e );\n      }\n\n      writer__iPropertiesInit = true;\n    }\n  }\n\n  /* Writer Services >> */\n \n\n\n\n  /* Template Services (File Generation) << */\n\n  /** Set the prefix of the files to be generated. */\n  public void _setFileNamePrefix( String pPrefix ) {\n    if( null == pPrefix ) {\n      return; // ignore\n    }\n    writer__iFileNamePrefix = pPrefix;\n  }\n\n\n\n  /** Get prefix of files to be generated. */\n  public String _getFileNamePrefix() {\n    return writer__iFileNamePrefix;\n  }\n\n\n\n  /** Set the suffix of the files to be generated. */\n  public void _setFileNameSuffix( String pSuffix ) {\n    if( null == pSuffix ) {\n      return; // ignore\n    }\n    writer__iFileNameSuffix = pSuffix;\n  }\n\n\n\n  /** Get suffix of files to be generated. */\n  public String _getFileNameSuffix() {\n    return writer__iFileNameSuffix;\n  }\n\n\n\n  /** Set the full name of the file to be generated. \n   *  Prefix and Suffix are set to empty.\n   */\n  public void _setFullFileName( String pName ) {\n    _setFileNamePrefix( WRITER__STRING_empty );\n    _setFileNameRoot(   pName );\n    _setFileNameSuffix( WRITER__STRING_empty );\n  }\n\n\n\n  /** Get the full name of current file being generated. */\n  public String _getFullFileName() {\n    return _getFileNamePrefix() + _getFileNameRoot() + _getFileNameSuffix();\n  }\n\n\n\n  /** Set the names of the files to be generated. \n   *  Prefix and Suffix are set to empty.\n   */\n  public void _setFullFileNames( String[] pNames ) {\n    _setFileNamePrefix( WRITER__STRING_empty );\n    _setFileNameRoots(  pNames );\n    _setFileNameSuffix( WRITER__STRING_empty );\n  }\n\n\n\n  /** Get the full names of the files to be generated. */\n  public String[] _getFullFileNames() {\n\n    String[] fileNameRoots  = _getFileNameRoots();\n    int      numFiles       = fileNameRoots.length;\n    String[] fullFileNames  = new String[ numFiles ];\n    String   fileNamePrefix = _getFileNamePrefix();\n    String   fileNameSuffix = _getFileNameSuffix();\n\n    for( int fileI = 0; fileI < numFiles; fileI = fileI + 1 ) {\n      fullFileNames[ fileI ] = fileNamePrefix + fileNameRoots[ fileI ] + fileNameSuffix;\n    }\n\n    return fullFileNames;\n  }\n\n\n\n  /** Set the root of the name of the file to be generated. */\n  public void _setFileNameRoot( String pFileNameRoot ) {\n    if( null == pFileNameRoot ) {\n      return; // ignore\n    }\n    _setFileNameRoots( new String[] { pFileNameRoot } );\n  }\n\n\n\n  /** Get the root of the name of the current file being generated. */\n  public String _getFileNameRoot() {\n    if( 0 < writer__iFileNameRoots.length ) {\n      return writer__iFileNameRoots[ writer__iCurrentFileIndex ];\n    }\n    return WRITER__STRING_empty;\n  }\n\n\n\n  /** Set the roots of the names of the files to be generated. */\n  public void _setFileNameRoots( String[] pFileNameRoots ) {\n    if( null == pFileNameRoots ) {\n      return; // ignore\n    }\n\n    // copy\n    String[] roots = (String[]) pFileNameRoots.clone();\n\n    // normalize - replace nulls\n    int numRoots = roots.length;\n    for(int rootI = 0; rootI < numRoots; rootI = rootI + 1 ) {\n      if( null == roots[ rootI ] ) {\n        roots[ rootI ] = WRITER__STRING_empty;\n      }\n    }\n\n    // save roots\n    writer__iFileNameRoots = roots;\n    writer__iNumFiles      = numRoots;\n  }\n\n\n\n  /** Get roots of the names of files to be generated. */\n  public String[] _getFileNameRoots() {\n    return writer__iFileNameRoots;\n  }\n\n\n\n  /** Get index of file currently being generated. */\n  public int _getFileIndex() {\n    return writer__iCurrentFileIndex;\n  }\n\n\n\n  /** Get number of files to generate. */\n  public int _getNumFiles() {\n    return writer__iNumFiles;\n  }\n\n\n\n  /** Set output folder. */\n  public void _setOutputFolder( String pOutputFolder ) {\n    writer__iOutputFolder = pOutputFolder;\n  }\n\n\n\n  /** Get output folder. */\n  public String _getOutputFolder() {\n    return writer__iOutputFolder;\n  }\n\n\n\n  /** Set backup folder. */\n  public void _setBackupFolder( String pBackupFolder ) {\n    writer__iBackupFolder = pBackupFolder;\n  }\n\n\n\n  /** Get backup folder. */\n  public String _getBackupFolder() {\n    return writer__iBackupFolder;\n  }\n\n\n\n  /** Set the prefix of backup files. */\n  public void _setBackupPrefix( String pPrefix ) {\n    if( null == pPrefix ) {\n      return; // ignore\n    }\n    writer__iBackupPrefix = pPrefix;\n  }\n\n\n\n  /** Set the suffix of backup files. */\n  public void _setBackupSuffix( String pSuffix ) {\n    if( null == pSuffix ) {\n      return; // ignore\n    }\n    writer__iBackupSuffix = pSuffix;\n  }\n\n\n\n  /** Set to true if generated files are to be backed up to disk automatically. */\n  public void _backup( boolean pBackup ) {\n    writer__iBackup = pBackup;\n  }\n\n\n\n  /** Set to true if generated files are to be saved to disk automatically. */\n  public void _save( boolean pSave ) {\n    writer__iSave = pSave;\n  }\n\n\n\n  /** Save a text file. */\n  public void _saveTextFile( String pFilePath, String pContent ) {\n    try {\n      StringReader   sr = new StringReader( pContent );\n      BufferedReader br = new BufferedReader( sr );\n      FileWriter     fw = new FileWriter( pFilePath );\n      BufferedWriter bw = new BufferedWriter( fw );\n\n      String line;\n      while( null != (line = br.readLine()) ) {\n        bw.write( line );\n        bw.newLine();\n      }\n\n      bw.close();\n      br.close();\n    }\n    catch( RuntimeException re ) { throw re; }\n    catch( Exception e ) {\n      throw new RuntimeException( e.getMessage() );\n    }\n  }\n\n\n\n  /** Load a text file. */\n  public String _loadTextFile( String pFilePath ) {\n    try {\n      File       file       = new File( pFilePath );\n      FileReader in         = new FileReader( file );\n      int        size       = (int) file.length();\n      char[]     data       = new char[size];\n      int        charsRead  = 0;\n\n      while( charsRead < size ) {\n        charsRead += in.read( data, charsRead, size - charsRead );\n      }\n\n      return new String( data );\n    }\n    catch( RuntimeException re ) { throw re; }\n    catch( Exception e ) {\n      throw new RuntimeException( e.getMessage() );\n    }\n  }\n\n\n  /** Set build properties file. */\n  public void _setMetaPropFile( String pMetaPropFile ) {\n    writer__iMetaPropFile  = pMetaPropFile;\n    writer__iPropertiesInit = false;\n  }\n\n\n\n  /** Get build properties file. */\n  public String _getMetaPropFile() {\n    return writer__iMetaPropFile;\n  }\n\n\n  /* Template Services (File Generation) >> */\n\n\n\n\n  /* Template Services (Control) << */\n\n  /** Get the value of a compile-time property. */\n  public String _getProperty( String pName ) {\n    String result = WRITER__STRING_empty;\n\n    if( ! writer__iPropertiesInit ) {\n      writer__initProperties();\n    }\n\n    if( writer__iProperties.containsKey( pName ) ) {\n      result = writer__iProperties.getProperty( pName );\n    }\n    else {\n      throw new RuntimeException( WRITER__UITEXT_UndefinedProperty+pName );\n    }\n\n    return result;\n  }\n\n\n\n  /** Get first user arg. */\n  public String _getFirstUserArg() {\n    return _getUserArg(0);\n  }\n\n\n\n  /** Get second user arg. */\n  public String _getSecondUserArg() {\n    return _getUserArg(1);\n  }\n\n\n\n  /** Get third user arg. */\n  public String _getThirdUserArg() {\n    return _getUserArg(2);\n  }\n\n\n\n  /** Get nth (n=0,1,2,...) user arg (the nth arg with no WRITER__ARGUMENT_CONTROL_PREFIX). */\n  public String _getUserArg( int pOrdinal ) {\n    if( pOrdinal < _getNumUserArgs() ) {\n      String[] userargs =  _getUserArgs();\n      return userargs[ pOrdinal ];\n    }\n    else {\n      return WRITER__STRING_empty;\n    }\n  }\n\n\n\n  /** Get user command line arguments to CodeWriter. */\n  public String[] _getUserArgs() {\n    return writer__iUserArgs;\n  }\n\n\n\n  /** Get number of user command line arguments to CodeWriter. */\n  public int _getNumUserArgs() {\n    return writer__iNumUserArgs;\n  }\n\n\n\n  /** Get all command line arguments to CodeWriter. */\n  public String[] _getArgs() {\n    return writer__iArgs;\n  }\n\n\n\n  /** Get total number of command line arguments to CodeWriter. */\n  public int _getNumArgs() {\n    return writer__iNumArgs;\n  }\n\n\n  \n  /** Set a context object for the template to use. */\n  public void _setContext( Object pContext) {\n    writer__iContext = pContext;\n  }\n\n\n\n  /** Get the context object if set. NOTE: may return null. */\n  public Object _getContext() {\n    return writer__iContext;\n  }\n\n  /* Template Services (Control) >> */\n\n\n\n\n  /* Template Services (Text Production) << */\n\n  // inserts\n  // ...\n\n  public void _insert( String pText ) {\n    writer__iCurrentText.append( pText );\n  }\n\n  public void _insert( Object pObject ) {\n    writer__iCurrentText.append( String.valueOf(pObject) );\n  }\n\n  public void _insert( int pInt ) {\n    writer__iCurrentText.append( pInt );\n  }\n\n  public void _insert( long pLong ) {\n    writer__iCurrentText.append( pLong );\n  }\n\n  public void _insert( short pShort ) {\n    writer__iCurrentText.append( pShort );\n  }\n\n  public void _insert( byte pByte ) {\n    writer__iCurrentText.append( pByte );\n  }\n\n  public void _insert( double pDouble ) {\n    writer__iCurrentText.append( pDouble );\n  }\n\n  public void _insert( float pFloat ) {\n    writer__iCurrentText.append( pFloat );\n  }\n\n  public void _insert( char pChar ) {\n    writer__iCurrentText.append( pChar );\n  }\n\n  public void _insert( boolean pBoolean ) {\n    writer__iCurrentText.append( pBoolean );\n  }\n\n\n\n  /** Create a String containing specified number of spaces. */\n  public String _spaces( int pNumSpaces ) {\n    int numSpaces = pNumSpaces;\n    if( 0 > numSpaces ) { numSpaces *= -1; }\n    StringBuffer spaces = new StringBuffer( numSpaces );\n    for(int spaceI = 0; spaceI < numSpaces; spaceI = spaceI + 1 ) {\n      spaces.append(\" \");\n    }\n    return spaces.toString();\n  }\n\n\n\n  /** Left align String with spaces. */ \n  public String _left( String pText, int pColWidth ) {\n    return _align( pText, \" \", pColWidth, 'l' );\n  } \n\n\n\n  /** Right align String with spaces. */ \n  public String _right( String pText, int pColWidth ) {\n    return _align( pText, \" \", pColWidth, 'r' );\n  } \n\n\n\n  /** Center align String with spaces. */ \n  public String _center( String pText, int pColWidth ) {\n    return _align( pText, \" \", pColWidth, 'c' );\n  } \n\n\n\n  /** Align text within background text to specified column width. \n   *  Alignment can be 'l': left, 'c': center, 'r': right.\n   */\n  public String _align( String pText, String pBackText, int pColWidth, char pAlignment ) {\n    String result = pText;\n \n    if( null == pText ) { \n       result = WRITER__STRING_empty; \n    }\n    else if( null != pBackText ) {\n      try {\n        int textLen = pText.length();\n        if( pColWidth > textLen ) {\n          int    backTextLen     = pBackText.length();\n          int    remainWidth     = pColWidth - textLen;\n          int    backTextRepeats = remainWidth / backTextLen;\n          int    backTextRemain  = remainWidth % backTextLen;\n          String back            = WRITER__STRING_empty;\n          for( int backTextI = 0; backTextI < backTextRepeats; backTextI = backTextI + 1 ) {\n            back = back + pBackText;\n          }\n          back = back + pBackText.substring( 0, backTextRemain );\n \n          switch( pAlignment ) {\n          case 'l':\n            result = result + back;\n            break;\n          case 'c':\n            result = back.substring( 0, (back.length()/2) ) + result + back.substring( (back.length()/2) );\n            break;\n          case 'r':\n            result = back + result;\n            break;\n          }\n        }\n      } \n      catch( RuntimeException re ) { throw re; }\n      catch( Exception e ) {\n        result = pText;\n      }\n    }\n    return result;\n  }\n\n\n\n  /** Set the text of file currently being generated. */\n  public void _setText( String pText) {\n    writer__iCurrentText = new StringBuffer( pText );\n  }\n\n\n\n  /** Get the text of file currently being generated. */\n  public String _getText() {\n    return writer__iCurrentText.toString();\n  }\n\n\n  /** Set result object (optional). */\n  public void _setResult( Object pResult ) {\n    writer__iResult = pResult;\n  }\n\n\n\n  /** Get the result object (may be null). */\n  public Object _getResult() {\n    return writer__iResult;\n  }\n\n  /* Template Services (Text Production) >> */\n\n}\n\n\n!<footer>\n");
    }
