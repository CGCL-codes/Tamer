    private static final void makeWF_BasicPerlWriterFormat_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicPerlWriterFormat.jwf", "!<header>\n$<{perl.use.strict>use strict;$<}perl.use.strict>\n\n\n!<{import># section:import\n!<import>!<}import>\n\n\npackage $<main.CodeWriter>;\n\nsub new {\n  my $self = {};\n  bless $self;\n  $self->{writer__iText} = \"\";\n\n  # Constants \n\n  # Command line arguments\n  $self->{WRITER__ARGUMENT_CONTROL_PREFIX}         = \"$<main.CodeWriter.argument.ControlPrefix>\";\n  $self->{WRITER__ARGUMENT_OutputFolder}           = \"$<main.CodeWriter.argument.name.OutputFolder>\";\n  $self->{WRITER__ARGUMENT_MetaPropFile}           = \"$<main.CodeWriter.argument.name.MetaPropFile>\";\n  $self->{WRITER__ARGUMENT_BackupFolder}           = \"$<main.CodeWriter.argument.name.BackupFolder>\";\n  $self->{WRITER__ARGUMENT_NoBackup}               = \"$<main.CodeWriter.argument.name.NoBackup>\";\n\n  # User Interface text message parts\n  $self->{WRITER__UITEXT_Method}                   = \"method \";\n  $self->{WRITER__UITEXT_Main}                     = \"main \";\n  $self->{WRITER__UITEXT_ExceptionIn}              = \"Exception in \";\n  $self->{WRITER__UITEXT_ColonNewLine}             = \":\\n\";\n  $self->{WRITER__UITEXT_NewLine}                  = \"\\n\";\n  $self->{WRITER__UITEXT_Section}                  = \"section \";\n  $self->{WRITER__UITEXT_SavedFile}                = \"Saved file:       \";\n  $self->{WRITER__UITEXT_UnableToSaveFile}         = \"Unable to save file: \";\n  $self->{WRITER__UITEXT_UnableToBackupFile}       = \"Unable to backup file: \";\n  $self->{WRITER__UITEXT_ToBackupFolder}           = \" to backup folder: \";\n  $self->{WRITER__UITEXT_BackupFolderColon}        = \"Backup folder: \";\n  $self->{WRITER__UITEXT_BackupFolderExistFailure} = \" does not exist and cannot be created.\";\n  $self->{WRITER__UITEXT_BackupFolderNotAFolder}   = \" is not a folder.\";\n  $self->{WRITER__UITEXT_BackupFolderNotWritable}  = \" is not writable.\";\n  $self->{WRITER__UITEXT_CodeWriterState}          = \"Code Writer State: \";\n  $self->{WRITER__UITEXT_GetFileIndexEquals}       = \"\\n_getFileIndex()    = \";\n  $self->{WRITER__UITEXT_GetFullFileNameEquals}    = \"\\n_getFullFileName() = \";\n  $self->{WRITER__UITEXT_GetOutputFolderEquals}    = \"\\n_getOutputFolder() = \";\n  $self->{WRITER__UITEXT_ErrorHeader}              = \"\\n\\n--- CodeWriter Error Description Start ---\\n\\n\";\n  $self->{WRITER__UITEXT_ErrorFooter}              = \"\\n--- CodeWriter Error Description End -----\\n\\n\";\n  $self->{WRITER__UITEXT_UnableToLoadMetaProps}    = \"Unable to load metadata from file: \";\n\n  # String constants\n  $self->{WRITER__STRING_empty}                    = \"\";\n  $self->{WRITER__STRING_dot}                      = \".\";\n  $self->{WRITER__STRING_separator}                = \"$<\\jostraca.system.fileSeparator>\";\n\n\n\n  # Writer Variables\n\n  $self->{writer__iFileNameRoots}      = [];                            # generated file name roots\n  $self->{writer__iNumFiles}           = 0;                             # number of generated files\n\n  $self->{writer__iFileNamePrefix}     = $self->{WRITER__STRING_empty}; # failsafe default\n  $self->{writer__iFileNameSuffix}     = $self->{WRITER__STRING_empty}; # failsafe default\n\n  $self->{writer__iBackupPrefix}       = $self->{WRITER__STRING_empty}; # failsafe default\n  $self->{writer__iBackupSuffix}       = $self->{WRITER__STRING_empty}; # failsafe default\n\n  $self->{writer__iCurrentText}        = $self->{WRITER__STRING_empty}; # current text\n  $self->{writer__iCurrentFileIndex}   = 0;                             # current file index\n\n  $self->{writer__iArgs}               = [];                            # cmd line args\n  $self->{writer__iNumArgs}            = 0;                             # number of cmd line args\n  $self->{writer__iUserArgs}           = [];                            # user cmd line args\n  $self->{writer__iNumUserArgs}        = 0;                             # number of user cmd line args\n\n  $self->{writer__iSave}               = $<lang.TrueString>;            # save generated code to disk\n  $self->{writer__iBackup}             = $<lang.TrueString>;            # make backups\n\n  $self->{writer__iOutputFolder}       = $self->{WRITER__STRING_dot};   # written code is output to this folder\n  $self->{writer__iBackupFolder}       = $self->{WRITER__STRING_dot};   # overwritten files are placed here\n  $self->{writer__iMetaPropFile}       = $self->{WRITER__STRING_empty}; # metadata properties file path\n\n  $self->{writer__iProperties}         = {};                            # lookup table for compile time properties\n  $self->{writer__iPropertiesInit}     = $<lang.FalseString>;           # true => lookup table initialiased\n\n  return $self;\n}\n\n\n!<{support># version 0.1 compatibility # section:support\n!<support>!<}support>\n\n\n\n!<{declare># section:declare!<declare>\n!<}declare>\n\n\n\n# Execute.\nsub main {\n  my $self = shift;\n  my @pArgs = @_;\n\n  eval {\n    $self->writer__initialize();\n    $self->writer__handleArgs( @pArgs );\n    $self->writer__write();\n  };\n  if( $@ ) {\n    $self->writer__handleException( $self->{WRITER__UITEXT_ExceptionIn} \n                                    . $self->{WRITER__UITEXT_Method} \n                                    . $self->{WRITER__UITEXT_Main}, $@ );      \n  }\n}\n\n\n\n# Writer Services\n\n# Initialize.\nsub writer__initialize() {\n  my $self = shift;\n  $self->{writer__iCurrentFileIndex} = 0;\n  $self->writer__setDefaults();\n}\n\n\n\n# Main file generation loop. Template script is placed here in the body section.\nsub writer__write {\n  my $self = shift;\n\n  # initialize\n  $self->{writer__currentSection} = \"init\";\n\n  eval {\n\n    !<{init># section:init\n    !<init>!<}init> \n\n\n    # write files loop\n    my $writer__numFiles = $self->_getNumFiles();\n    my $writer__fileI    = 0;\n    writer__next_file: for( $writer__fileI = 0; \n                            $writer__fileI < $writer__numFiles;\n                            $writer__fileI = $writer__fileI + 1 ) {\n      eval {\n\n        !<{prewrite># section:prewrite\n        $self->{writer__currentSection} = \"prewrite\";\n        !<prewrite>!<}prewrite> \n\n\n        if( ! $self->writer__startFile() ) { \n          next writer__next_file; \n        }\n\n\n        !<{body># section:body\n        $self->{writer__currentSection} = \"body\";\n        !<body>!<}body> \n\n\n        if( ! $self->writer__endFile() ) { \n          next writer__next_file; \n        }\n\n\n        !<{postwrite># section:postwrite\n        $self->{writer__currentSection} = \"postwrite\";\n        !<postwrite>!<}postwrite> \n\n      };\n      if( $@ ) {\n        $self->writer__handleException( $self->{WRITER__UITEXT_ExceptionIn} \n                                        . $self->{WRITER__UITEXT_Section} \n                                        . $self->{writer__currentSection}, $@ );\n      }\n\n      $self->writer__nextFile();       \n    }\n \n\n    !<{cleanup># section:cleanup\n    $self->{writer__currentSection} = \"cleanup\";\n    !<cleanup>!<}cleanup> \n\n  };\n  if( $@ ) {\n    $self->writer__handleException( $self->{WRITER__UITEXT_ExceptionIn} \n                                    . $self->{WRITER__UITEXT_Section} \n                                    . $self->{writer__currentSection}, $@ );\n  }\n}\n\n\n\n# Start writing a file.\nsub writer__startFile {\n  my $self = shift;\n  $self->{writer__iCurrentText} = $self->{WRITER__STRING_empty};\n  return $<lang.TrueString>;\n}\n\n\n\n# End writing a file.\nsub writer__endFile {\n  my $self = shift;\n  my $endOK = $<lang.TrueString>;\n\n  my $fileName = $self->_getFullFileName();\n  my $filePath = $self->{writer__iOutputFolder}    \n               . $self->{WRITER__STRING_separator}    \n               . $fileName\n               ;\n\n  if( $self->{writer__iBackup} ) {\n    eval {\n      $self->writer__backup( $filePath, $fileName, $self->{writer__iBackupFolder} );\n    };\n    if( $@ ) {\n       $self->writer__handleException( $self->{WRITER__UITEXT_UnableToBackupFile} \n                                       . $filePath \n                                       . $self->{WRITER__UITEXT_ToBackupFolder}\n                                       . $self->{writer__iBackupFolder}, $@ );\n       $endOK = $<lang.FalseString>;\n    }\n  }\n \n  if( $endOK && $self->{writer__iSave} ) {\n    eval {\n      $self->_saveTextFile( $filePath, $self->{writer__iCurrentText} );\n      $self->writer__userMessage( $self->{WRITER__UITEXT_SavedFile} . $filePath . $self->{WRITER__UITEXT_NewLine}, 0 );\n    };\n    if( $@ ) {\n      $self->writer__handleException( $self->{WRITER__UITEXT_UnableToSaveFile} . $filePath, $@ );\n      $endOK = $<lang.FalseString>;\n    }\n  }\n\n  return $endOK;\n}\n\n\n\n# Move to next file.\nsub writer__nextFile {\n  my $self = shift;\n  $self->{writer__iCurrentFileIndex} = $self->{writer__iCurrentFileIndex} + 1;\n}\n\n\n\n# Handle command line arguments to CodeWriter.\nsub writer__handleArgs {\n  my $self = shift;\n  my @pArgs = @_; \n\n  # set arg names\n  my $argName_OutputFolder           = $self->{WRITER__ARGUMENT_CONTROL_PREFIX} . $self->{WRITER__ARGUMENT_OutputFolder};\n  my $argName_MetaPropFile           = $self->{WRITER__ARGUMENT_CONTROL_PREFIX} . $self->{WRITER__ARGUMENT_MetaPropFile};\n  my $argName_BackupFolder           = $self->{WRITER__ARGUMENT_CONTROL_PREFIX} . $self->{WRITER__ARGUMENT_BackupFolder};\n  my $argName_NoBackup               = $self->{WRITER__ARGUMENT_CONTROL_PREFIX} . $self->{WRITER__ARGUMENT_NoBackup};\n\n  # parse args\n  my $numArgs = @pArgs;\n  my $argI;\n  for( $argI = 0; $argI < $numArgs; $argI = $argI + 1 ) {\n    if( $pArgs[$argI] =~ /^$argName_OutputFolder(.*)$/ ) {\n      $self->_setOutputFolder( $1 );\n    }\n    elsif( $pArgs[$argI] =~ /^$argName_MetaPropFile(.*)$/ ) {\n      $self->_setMetaPropFile( $1 );\n    }\n    elsif( $pArgs[$argI] =~ /^$argName_BackupFolder(.*)$/ ) {\n      $self->_setBackupFolder( $1 );\n    }\n    elsif( $argName_NoBackup eq $pArgs[$argI] ) {\n      $self->_backup( $<lang.FalseString> ); ## NOTE: -B => don't make backups\n    }\n  }\n\n  $self->writer__initArgs( scalar(@pArgs), @pArgs );\n}\n\n\n\n# Set defaults from configuration property set.\nsub writer__setDefaults {\n  my $self = shift;\n\n  $<{main.FileNameRoot>$self->_setFileNameRoot( \"$<\\main.FileNameRoot>\" );$<}main.FileNameRoot>\n  $<{main.FileNamePrefix>$self->_setFileNamePrefix( \"$<\\main.FileNamePrefix>\" );$<}main.FileNamePrefix>\n  $<{main.FileNameSuffix>$self->_setFileNameSuffix( \"$<\\main.FileNameSuffix>\" );$<}main.FileNameSufffix>\n\n  $<{main.OutputFolder>$self->_setOutputFolder( \"$<\\main.OutputFolder>\" );$<}main.OutputFolder>\n\n  $<{main.BackupFolder>$self->_setBackupFolder( \"$<\\main.BackupFolder>\" );$<}main.BackupFolder>\n  $<{main.BackupPrefix>$self->_setBackupPrefix( \"$<\\main.BackupPrefix>\" );$<}main.BackupPrefix>\n  $<{main.BackupSuffix>$self->_setBackupSuffix( \"$<\\main.BackupSuffix>\" );$<}main.BackupSufffix>\n  $self->_backup( \"$<lang.TrueString>\" eq \"$<jostraca.MakeBackup>\" );\n\n}\n\n\n\n# Initialize command line arguments.\nsub writer__initArgs {\n  my $self = shift;\n  $self->{writer__iNumArgs}     = shift;\n  $self->{writer__iArgs}        = \\@_;\n\n  my $argI        = 0;\n  my $userArgI    = 0;\n  my @args        = @{$self->{writer__iArgs}};\n\n  $self->{writer__iNumUserArgs} = $self->{writer__iNumArgs};\n\n  for( $argI = 0; $argI < $self->{writer__iNumArgs}; $argI = $argI + 1 ) {\n    if( $args[$argI] =~ /^$self->{WRITER__ARGUMENT_CONTROL_PREFIX}/ ) {\n      $self->{writer__iNumUserArgs} = $self->{writer__iNumUserArgs} - 1;\n    }\n  }\n\n  for( $argI = 0; $argI < $self->{writer__iNumArgs}; $argI = $argI + 1 ) {\n    if( $args[$argI] =~ /^$self->{WRITER__ARGUMENT_CONTROL_PREFIX}/ ) {\n      next;\n    } \n    else {\n      ${$self->{writer__iUserArgs}}[ $userArgI ] = $args[ $argI ];\n      $userArgI = $userArgI + 1;\n    }\n  }\n}\n\n\n\n# Print a user readable message.\nsub writer__userMessage {\n  my $self = shift;\n  my $pMessage = shift;\n  my $pError = shift;\n\n  if( $pError ) {\n    print STDERR $pMessage;\n  }\n  else {\n    print( $pMessage );\n  }\n}\n\n\n\n# Handle exceptions: print an explanation for user.\nsub writer__handleException {\n  my $self = shift;\n  my $pMessage   = shift;\n  my $pException = shift;\n\n  my $userMsg = $self->{WRITER__UITEXT_ErrorHeader};\n\n  $userMsg .= $self->writer__describeState() . $pMessage . $self->{WRITER__UITEXT_ColonNewLine};\n  $userMsg .= $pException;\n  $userMsg .= $self->{WRITER__UITEXT_ErrorFooter};\n\n  $self->writer__userMessage( $userMsg, 1 );\n}\n\n\n\n# Provide a concise description of the state of the CodeWriter.\nsub writer__describeState {\n  my $self = shift;\n\n  my $currentState \n    = $self->{WRITER__UITEXT_CodeWriterState} \n    . $self->{WRITER__UITEXT_GetFileIndexEquals}    . $self->_getFileIndex()\n    . $self->{WRITER__UITEXT_GetFullFileNameEquals} . $self->_getFullFileName()\n    . $self->{WRITER__UITEXT_GetOutputFolderEquals} . $self->_getOutputFolder()\n    . $self->{WRITER__UITEXT_NewLine}\n    ; \n  return $currentState;\n}\n\n\n\n# Backup overwritten files, if they exist.\n# Backups have the format: [YYYYMMDDhhmmss][prefix][filename][suffix].\nsub writer__backup {\n  my $self = shift;\n\n  my $pFilePath     = shift;\n  my $pFileName     = shift;\n  my $pBackupFolder = shift;\n\n  my $backupFolder = $pBackupFolder;\n\n  # check backup folder ( create if necessary )\n  if( !( -e $backupFolder) ) {\n    if( !( mkdir( $backupFolder, 0700 ) ) ) {\n      die( $self->{WRITER__UITEXT_BackupFolderColon}\n           . $backupFolder\n           . $self->{WRITER__UITEXT_BackupFolderExistFailure} );\n    }\n  }\n  if( !( -d $backupFolder ) ) {\n    die( $self->{WRITER__UITEXT_BackupFolderColon} \n         . $backupFolder\n         . $self->{WRITER__UITEXT_BackupFolderNotAFolder} );\n  }\n  if( !( -w $backupFolder ) ) {\n    die( $self->{WRITER__UITEXT_BackupFolderColon}\n         . $backupFolder\n         . $self->{WRITER__UITEXT_BackupFolderNotWritable} );\n  }\n\n  # create backup file path\n  my @calendar = localtime();\n  my $year_yyyy = $self->_align( 1900+$calendar[5], \"0\", 4, 'r' );\n  my $month_mm  = $self->_align( 1+$calendar[4],    \"0\", 2, 'r' );\n  my $day_dd    = $self->_align( $calendar[3],      \"0\", 2, 'r' );\n  my $hour_hh   = $self->_align( $calendar[2],      \"0\", 2, 'r' );\n  my $minute_mm = $self->_align( $calendar[1],      \"0\", 2, 'r' );\n  my $second_ss = $self->_align( $calendar[0],      \"0\", 2, 'r' );\n  my $dateTime = $year_yyyy.$month_mm.$day_dd.$hour_hh.$minute_mm.$second_ss;\n  my $backupFileName = $dateTime . $self->{writer__iBackupPrefix} . $pFileName . $self->{writer__iBackupSuffix};\n  my $backupFilePath = $pBackupFolder . $self->{WRITER__STRING_separator} . $backupFileName;\n  \n  # save backup file\n  if( -e $pFilePath ) {\n    my $fileContents = $self->_loadTextFile( $pFilePath );\n    $self->_saveTextFile( $backupFilePath, $fileContents );\n  }\n}\n\n\n\n# Set compile time properties.\nsub writer__initProperties {\n  my $self = shift;\n\n  my $metaPropFile = $self->_getMetaPropFile();\n\n  if( \"\" ne $metaPropFile ) {\n    $self->{writer__iProperties} = {};\n      \n    eval {\n      open( PF, $metaPropFile );\n      my $content = \"\\n\".join('',@_=<PF>);\n      close( PF );\n\n      $content =~ s/\\r\\n/\\n/g;\n      $content =~ s/\\r/\\n/g;\n      while( $content =~ /\\n\\s*(.*?)\\s*[=:]\\s*((\\\\\\s*\\n|.)*)/g ) {\n        my $name  = $1;\n        my $value = $2;\n        if( $name !~ /^#/ ) {\n          chomp($value);\n          $value =~ s/\\\\\\s*\\n//g;\n          ${$self->{writer__iProperties}}{$name} = $value;\n        }\n      }\n\n    };\n    if( $@ ) {\n      $self->writer__handleException( $self->{WRITER__UITEXT_UnableToLoadMetaProps} . $self->_getMetaPropFile() );\n    }\n\n    $self->{writer__iPropertiesInit} = $<lang.TrueString>;\n  }\n}\n\n\n\n# Template Services (File Generation)\n\n# Set the prefix of the files to be generated. \nsub _setFileNamePrefix {\n  my $self = shift;\n  my $pPrefix = shift;\n  $self->{writer__iFileNamePrefix} = $pPrefix;\n}\n\n\n\n# Get prefix of files to be generated.\nsub _getFileNamePrefix {\n  my $self = shift;\n  return $self->{writer__iFileNamePrefix};\n}\n\n\n\n#} Set the suffix of the files to be generated.\nsub _setFileNameSuffix {\n  my $self = shift;\n  my $pSuffix = shift;\n  $self->{writer__iFileNameSuffix} = $pSuffix;\n}\n\n\n\n# Get suffix of files to be generated.\nsub _getFileNameSuffix {\n  my $self = shift;\n  return $self->{writer__iFileNameSuffix};\n}\n\n\n\n#} Set the full name of the file to be generated. \n# Prefix and Suffix are set to empty.\nsub _setFullFileName {\n  my $self = shift;\n  my $pName = shift;\n  $self->_setFileNamePrefix( $self->{WRITER__STRING_empty} );\n  $self->_setFileNameRoot(   $pName );\n  $self->_setFileNameSuffix( $self->{WRITER__STRING_empty} );\n}\n\n\n\n# Get the full name of current file being generated.\nsub _getFullFileName {\n  my $self = shift;\n  return $self->_getFileNamePrefix() . $self->_getFileNameRoot() . $self->_getFileNameSuffix();\n}\n\n\n\n# Set the names of the files to be generated. \n# Prefix and Suffix are set to empty.\nsub _setFullFileNames {\n  my $self = shift;\n  my @pNames = @_;\n  $self->_setFileNamePrefix( $self->{WRITER__STRING_empty} );\n  $self->_setFileNameRoots(  @pNames );\n  $self->_setFileNameSuffix( $self->{WRITER__STRING_empty} );\n}\n\n\n\n# Get the full names of the files to be generated.\nsub _getFullFileNames {\n  my $self = shift;\n\n  my @fileNameRoots  = $self->_getFileNameRoots();\n  my $numFiles       = @fileNameRoots;\n  my @fullFileNames;\n  my $fileNamePrefix = $self->_getFileNamePrefix();\n  my $fileNameSuffix = $self->_getFileNameSuffix();\n\n  my $fileI;\n  for( $fileI = 0; $fileI < $numFiles; $fileI = $fileI + 1 ) {\n    $fullFileNames[ $fileI ] = $fileNamePrefix . $fileNameRoots[ $fileI ] . $fileNameSuffix;\n  }\n\n  return @fullFileNames;\n}\n\n\n\n# Set the root of the name of the file to be generated. \nsub _setFileNameRoot {\n  my $self = shift;\n  my $pFileNameRoot = shift;\n  $self->_setFileNameRoots( ($pFileNameRoot) );\n}\n\n\n\n# Get the root of the name of current file being generated.\nsub _getFileNameRoot {\n  my $self = shift;\n  return ${$self->{writer__iFileNameRoots}}[ $self->{writer__iCurrentFileIndex} ];\n}\n\n\n\n# Set the roots of the names of the files to be generated. \nsub _setFileNameRoots {\n  my $self = shift;\n\n  my @pFileNameRoots = @_;\n\n  $self->{writer__iFileNameRoots} = \\@pFileNameRoots;\n  $self->{writer__iNumFiles}      = @pFileNameRoots;\n}\n\n\n\n# Get roots of the names of files to be generated.\nsub _getFileNameRoots {\n  my $self = shift;\n  return @{$self->{writer__iFileNameRoots}};\n}\n\n\n\n# Get index of file currently being generated. \nsub _getFileIndex {\n  my $self = shift;\n  return $self->{writer__iCurrentFileIndex};\n}\n\n\n\n#} Get number of files to generate.\nsub _getNumFiles {\n  my $self = shift;\n  return $self->{writer__iNumFiles};\n}\n\n\n\n#} Set output folder.\nsub _setOutputFolder {\n  my $self = shift;\n\n  $self->{writer__iOutputFolder} = shift;\n}\n\n\n\n# Get output folder.\nsub _getOutputFolder {\n  my $self = shift;\n  return $self->{writer__iOutputFolder};\n}\n\n\n\n#} Set backup folder.\nsub _setBackupFolder {\n  my $self = shift;\n\n  my $pBackupFolder = shift;\n  $self->{writer__iBackupFolder} = $pBackupFolder;\n}\n\n\n\n# Get backup folder.\nsub _getBackupFolder {\n  my $self = shift;\n  return $self->{writer__iBackupFolder};\n}\n\n\n\n#} Set the prefix of backup files.\nsub _setBackupPrefix {\n  my $self = shift;\n  $self->{writer__iBackupPrefix} = shift;\n}\n\n\n\n# Set the suffix of backup files.\n# @param rSuffix Backup files suffix.\nsub _setBackupSuffix {\n  my $self = shift;\n  $self->{writer__iBackupSuffix} = shift;\n}\n\n\n\n# Set to true if generated files are to be backed up to disk automatically. \nsub _backup {\n  my $self = shift;\n  $self->{writer__iBackup} = shift;\n}\n\n\n\n# Set to true if generated files are to be saved to disk automatically. \nsub _save {\n  my $self = shift;\n  $self->{writer__iSave} = shift;\n}\n\n\n\n# Save a text file.\nsub _saveTextFile {\n  my $self = shift;\n\n  my $pFilePath = shift;\n  my $pContent  = shift;\n\n  open( FILE, '>'.$pFilePath ) or die \"Unable to write file: \".$pFilePath;\n  print FILE $pContent;\n  close( FILE );\n}\n\n\n\n# Load a text file.\nsub _loadTextFile {\n  my $self = shift;\n\n  my $pFilePath = shift;\n\n  open( FILE, $pFilePath ) or die \"Unable to read file: \".$pFilePath;\n  my $content = join('',@_=<FILE>);\n  close( FILE );\n  \n  return $content;\n}\n\n\n\n# Set build properties file.\nsub _setMetaPropFile {\n  my $self = shift;\n\n  my $pMetaPropFile = shift;\n\n  $self->{writer__iMetaPropFile}   = $pMetaPropFile;\n  $self->{writer__iPropertiesInit} = 0;\n}\n\n\n\n# Get build properties file.\nsub _getMetaPropFile {\n  my $self = shift;\n  return $self->{writer__iMetaPropFile};\n}\n\n\n\n# Template Services (Control)\n\n# Get the value of a compile-time property.\nsub _getProperty {\n  my $self = shift;\n\n  my $pName = shift;\n\n  if( ! $self->{writer__iPropertiesInit} ) {\n    $self->writer__initProperties();\n  }\n\n  return ${$self->{writer__iProperties}}{$pName};\n}\n\n\n\n# Get first user arg.\nsub _getFirstUserArg {\n  my $self = shift;\n  return $self->_getUserArg(0);\n}\n\n\n\n# Get second user arg.\nsub _getSecondUserArg {\n  my $self = shift;\n  return $self->_getUserArg(1);\n}\n\n\n\n# Get third user arg.\nsub _getThirdUserArg {\n  my $self = shift;\n  return $self->_getUserArg(2);\n}\n\n\n\n# Get nth (n=0,1,2,...) user arg (the nth arg with no WRITER__ARGUMENT_CONTROL_PREFIX).\nsub _getUserArg {\n  my $self = shift;\n\n  my $pOrdinal = shift;\n\n  if( $pOrdinal < $self->_getNumUserArgs() ) {\n      my @userargs = $self->_getUserArgs();\n      return $userargs[$pOrdinal];\n  }\n  else {\n    return $self->{WRITER__STRING_empty};\n  }\n}\n\n\n\n# Get user command line arguments to CodeWriter.\nsub _getUserArgs {\n  my $self = shift;\n  return @{$self->{writer__iUserArgs}};\n}\n\n\n\n# Get number of user command line arguments to CodeWriter.\nsub _getNumUserArgs {\n  my $self = shift;\n  return $self->{writer__iNumUserArgs};\n}\n\n\n\n#} Get all command line arguments to CodeWriter. \nsub _getArgs() {\n  my $self = shift;\n  return @{$self->{writer__iArgs}};\n}\n\n\n\n# Get total number of command line arguments to CodeWriter.\nsub _getNumArgs() {\n  my $self = shift;\n  return $self->{writer__iNumArgs};\n}\n\n\n\n\n\n# Template Services (Text Production)\n\n# Insert text into generated file. \nsub _insert {\n  my $self = shift;\n  my $pText = shift;\n\n  $self->{writer__iCurrentText} = $self->{writer__iCurrentText} . $pText;\n}\n\n\n\n# Create a String containing specified number of spaces.\nsub _spaces {\n  my $self = shift;\n  my $pNumSpaces = shift;\n  return ' ' x abs($pNumSpaces);\n}\n\n\n\n# Left align String with spaces. \nsub _left {\n  my $self = shift;\n  my $pText     = shift;\n  my $pColWidth = shift;\n  return $self->_align( $pText, \" \", $pColWidth, 'l' );\n} \n\n\n\n# Right align String with spaces. \nsub _right {\n  my $self = shift;\n  my $pText     = shift;\n  my $pColWidth = shift;\n  return $self->_align( $pText, \" \", $pColWidth, 'r' );\n} \n\n\n\n# Center align String with spaces. \nsub _center {\n  my $self = shift;\n  my $pText     = shift;\n  my $pColWidth = shift;\n  return $self->_align( $pText, \" \", $pColWidth, 'c' );\n} \n\n\n\n# Align text within background text with specified column width.\n# Alignment can be 'l': left, 'c': center, 'r': right\nsub _align {\n  my $self = shift;\n\n  my $pText      = shift;\n  my $pBackText  = shift;\n  my $pColWidth  = shift;\n  my $pAlignment = shift;\n\n  my $result = $pText;\n  \n\n  eval {\n    my $textLen = length( $pText );\n    if( $pColWidth > $textLen ) {\n      my $backTextLen     = length( $pBackText );\n      my $remainWidth     = $pColWidth - $textLen;\n      my $backTextRepeats = int( $remainWidth / $backTextLen );\n      my $backTextRemain  = $remainWidth % $backTextLen;\n      my $back            = $self->{WRITER__STRING_empty};\n      my $backTextI;\n      for( $backTextI = 0; $backTextI < $backTextRepeats; $backTextI = $backTextI + 1 ) {\n        $back = $back . $pBackText;\n      }\n      if( 0 < $backTextRemain ) {\n        $back = $back . substr( $pBackText, 0, $backTextRemain );\n      }                       \n\n      if( 'l' eq $pAlignment ) {\n        $result = $result . $back;\n      } \n      elsif( 'c' eq $pAlignment ) {\n        $result = substr( $back, 0, (length($back)/2) ) . $result . substr( $back, (length($back)/2) );\n      } \n      elsif( 'r' eq $pAlignment ) {\n        $result = $back . $result;\n      }\n    }\n  };\n  if( $@ ) {\n    $result = $pText;\n  }\n\n  return $result;\n}\n\n\n\n# Set the text of file currently being generated.\nsub _setText {\n  my $self = shift;\n  $self->{writer__iCurrentText} = shift;\n}\n\n\n\n# Get the text of file currently being generated.\nsub _getText {\n  my $self = shift;\n  return $self->{writer__iCurrentText};\n}\n\n\n\n# Start execution\nmy $cw = $<main.CodeWriter>->new();\n$cw->main( @ARGV );\nexit( 0 );\n\n\n\n!<footer>\n");
    }
