    private static final void makeWF_BasicCWriterFormat_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicCWriterFormat.jwf", "!<header>\n\n#include <stdio.h>\n#include <string.h>\n#include <dirent.h>\n#include <time.h>\n\n\n\n!<{include>/* section:include */\n!<include>!<}include>\n\n\n\n/* Constants << */ \n\n/* Command line arguments */\nchar* WRITER__ARGUMENT_CONTROL_PREFIX          = \"$<main.CodeWriter.argument.ControlPrefix>\";\nchar* WRITER__ARGUMENT_OutputFolder            = \"$<main.CodeWriter.argument.name.OutputFolder>\";\nchar* WRITER__ARGUMENT_MetaPropFile            = \"$<main.CodeWriter.argument.name.MetaPropFile>\";\nchar* WRITER__ARGUMENT_BackupFolder            = \"$<main.CodeWriter.argument.name.BackupFolder>\";\nchar* WRITER__ARGUMENT_NoBackup                = \"$<main.CodeWriter.argument.name.NoBackup>\";\n\n/* User Interface text message parts */\nchar* WRITER__UITEXT_Method                    = \"method \";\nchar* WRITER__UITEXT_Main                      = \"main \";\nchar* WRITER__UITEXT_ExceptionIn               = \"Exception in \";\nchar* WRITER__UITEXT_ColonNewLine              = \":\\n\";\nchar* WRITER__UITEXT_NewLine                   = \"\\n\";\nchar* WRITER__UITEXT_Section                   = \"section \";\nchar* WRITER__UITEXT_SavedFile                 = \"Saved file:       \";\nchar* WRITER__UITEXT_UnableToSaveFile          = \"Unable to save file: \";\nchar* WRITER__UITEXT_UnableToBackupFile        = \"Unable to backup file: \";\nchar* WRITER__UITEXT_ToBackupFolder            = \" to backup folder: \";\nchar* WRITER__UITEXT_BackupFolderColon         = \"Backup folder: \";\nchar* WRITER__UITEXT_BackupFolderExistFailure  = \" does not exist and cannot be created.\";\nchar* WRITER__UITEXT_BackupFolderNotAFolder    = \" is not a folder.\";\nchar* WRITER__UITEXT_BackupFolderNotWritable   = \" is not writable.\";\nchar* WRITER__UITEXT_CodeWriterState           = \"Code Writer State: \";\nchar* WRITER__UITEXT_GetFileIndexEquals        = \"\\n_getFileIndex()    = \";\nchar* WRITER__UITEXT_GetFullFileNameEquals     = \"\\n_getFullFileName() = \";\nchar* WRITER__UITEXT_GetOutputFolderEquals     = \"\\n_getOutputFolder() = \";\nchar* WRITER__UITEXT_ErrorHeader               = \"\\n\\n--- CodeWriter Error Description Start ---\\n\\n\";\nchar* WRITER__UITEXT_ErrorFooter               = \"\\n--- CodeWriter Error Description End -----\\n\\n\";\nchar* WRITER__UITEXT_UnableToLoadMetaProps     = \"Unable to load metadata from file: \";\nchar* WRITER__UITEXT_PlaceHolderException      = \"This placeholder Exception should never be thrown: there is an error in the WriterFormat.\";\n\n/* String constants */\n#define WRITER__STRING_empty                   \"\"\n#define WRITER__STRING_dot                     \".\"\n#define WRITER__STRING_separator               \"$<\\jostraca.system.fileSeparator>\"\n\n#define WRITER__MAX_LINE_LEN 2222\n\n\n\n\n/* Constants >> */\n\n\n\n\n/* section:define */\n#define _insertf(f,v) { sprintf( writer__iSprintfInsertBuffer, f, v); _insert( writer__iSprintfInsertBuffer ); }\n!<define>\n\n\n\n/* requires a NULL entry will empty line at end */\nstruct writer__FileText {\n  char*                    line;\n  struct writer__FileText* next; \n};\n\n\n\n/* Writer Variables << */\n\nchar**    writer__iFileNameRoots                   = NULL;                     /* generated file name roots */\nint       writer__iNumFiles                        = 0;                        /* number of generated files */\n  \nchar*     writer__iFileNamePrefix                  = WRITER__STRING_empty;     /* failsafe default */\nchar*     writer__iFileNameSuffix                  = WRITER__STRING_empty;     /* failsafe default */\n\nchar*     writer__iBackupPrefix                    = WRITER__STRING_empty;     /* failsafe default */\nchar*     writer__iBackupSuffix                    = WRITER__STRING_empty;     /* failsafe default */\n\nstruct writer__FileText* writer__iCurrentText      = NULL;                     /* current text */\nstruct writer__FileText* writer__iCurrentTextLine  = NULL;                     /* current text line */\nint                      writer__iCurrentFileIndex = 0;                        /* current file index */\n\nchar**    writer__iArgs                            = NULL;                     /* cmd line args */\nint       writer__iNumArgs                         = 0;                        /* number of cmd line args */\nchar**    writer__iUserArgs                        = NULL;                     /* user cmd line args */\nint       writer__iNumUserArgs                     = 0;                        /* number of user cmd line args */\n\nint       writer__iSave                            = 1;                        /* save generated code to disk */\nint       writer__iBackup                          = 1;                        /* make backups */\n\nchar*     writer__iOutputFolder                    = WRITER__STRING_dot;       /* written code is output to this folder */\nchar*     writer__iBackupFolder                    = WRITER__STRING_dot;       /* overwritten files are placed here */\nchar*     writer__iMetaPropFile                    = WRITER__STRING_empty;     /* metadata properties file path */\n\nstruct writer__FileText* writer__iProperties       = NULL;                     /* empty set of properties */  \nint       writer__iPropertiesInit                  = 1;                        /* true => lookup table initialiased */\n\nint       writer__iException                       = 0;                        /* true => exception was thrown */\nchar*     writer__iExceptionMessage                = WRITER__STRING_empty;     /* internal message describing the exception */\n\n\nchar  writer__iSprintfInsertBuffer[ WRITER__MAX_LINE_LEN ];\n\n/* Writer Variables >> */\n\n\n\nvoid      writer__initialize();\nvoid      writer__write();\nint       writer__startFile();\nint       writer__endFile();\nvoid      writer__nextFile();\nvoid      writer__handleArgs( int argc, char *argv[] );\nvoid      writer__setDefaults();\nvoid      writer__initArgs(int argc, char** argv);\nvoid      writer__userMessage( char* pMessage, int pError );\nvoid      writer__handleException( char* pMessage, char* pException );\nchar*     writer__describeState();\nvoid      writer__backup( char* pFilePath, char* pFileName, char* pBackupFolder );\nstruct writer__FileText* writer__insert( char* pText, struct writer__FileText* pTextLine );\nvoid      writer__initProperties(); \n\n\nvoid      _setFileNamePrefix(char* pPrefix);\nchar*     _getFileNamePrefix();\nvoid      _setFileNameSuffix(char* pSuffix);\nchar*     _getFileNameSuffix();\nvoid      _setFullFileName( char* pName );\nchar*     _getFullFileName();\nvoid      _setFullFileNames( int pNumFileNames, char* pFullFileNames[] );\nchar**    _getFullFileNames();\nvoid      _setFileNameRoot(char* pFileNameRoot);\nchar*     _getFileNameRoot();\nvoid      _setFileNameRoots(int pNumFileNameRoots, char* pFileNameRoots[]);\nchar**    _getFileNameRoots();\nint       _getFileIndex();\nint       _getNumFiles();\nvoid      _setOutputFolder(char* pOutputFolder);\nchar*     _getOutputFolder();\nvoid      _setBackupFolder(char* pBackupFolder);\nchar*     _getBackupFolder();\nvoid      _backup( int pBackup );\nvoid      _setBackupPrefix( char* pBackupPrefix );\nvoid      _setBackupSuffix( char* pBackupSuffix );\nvoid      _backup( int pBackup );\nvoid      _save( int pSave );\nvoid      _saveTextFile( char* pFilePath, struct writer__FileText* pFileText );\nstruct writer__FileText* _loadTextFile( char* pFilePath );\nvoid      _setMetaPropFile( char* pMetaPropFile );\nchar*     _getMetaPropFile();\nchar*     _getProperty( char* pName );\nchar*     _getFirstUserArg();\nchar*     _getSecondUserArg();\nchar*     _getThirdUserArg();\nchar*     _getUserArg(int pOrdinal);\nchar**    _getUserArgs();\nint       _getNumUserArgs();\nchar**    _getArgs();\nint       _getNumArgs();\nvoid      _insert(char* pText);\nchar*     _spaces(int pNumSpaces);\nchar*     _left(char* pText, int pColWidth );\nchar*     _right( char* pText, int pColWidth );\nchar*     _center( char* pText, int pColWidth );\nchar*     _align( char* pText, char* pBackText, int pColWidth, char pAlignment );\nstruct writer__FileText* _getText();\nvoid      _setText( struct writer__FileText* pFileText );\n\n\n\n\n\nchar*     _strcat( char* pFirst, char* pSecond );\n\n\n!<{support>\n// version 0.1 compatibility\n/* section:support */\n!<support>\n\n\n\n!<{declare>/* section:declare */\n!<declare>!<}declare>\n\n\n\n/** Execute Write */\nint main( int argc, char *argv[] ) {\n\n  writer__initialize();\n  writer__handleArgs( argc, argv );\n  writer__write();\n\n  if( writer__iException ) {\n    writer__handleException( _strcat( WRITER__UITEXT_ExceptionIn, _strcat( WRITER__UITEXT_Method, WRITER__UITEXT_Main ) ),\n                             writer__iExceptionMessage );      \n    return 1;\n  }\n\n  return 0;\n}\n\n\n\n/* Writer Services << */\n\n/** Initialize. */\nvoid writer__initialize() {\n  writer__iCurrentFileIndex = 0;\n  writer__setDefaults();\n}\n\n\n\n/** Main file generation loop. Template script is placed here in the body section. */\nvoid writer__write() {\n\n  /* initialize */\n  int    writer__numFiles; \n  int    writer__fileI;\n  char*  writer__currentSection = \"init\";\n\n\n  !<{init>/* section:init */\n  !<init>!<}init>\n\n\n  /* write files loop */\n  writer__numFiles = _getNumFiles();\n  writer__fileI    = 0;\n  for( writer__fileI = 0; writer__fileI < writer__numFiles; writer__fileI++ ) {\n\n\n    !<{prewrite>/* section:prewrite */\n    writer__currentSection = \"prewrite\";\n    !<prewrite>!<}prewrite>\n\n\n    if( ! writer__startFile() ) { \n      continue;\n    }\n\n\n    !<{body>/* section:body */\n    writer__currentSection = \"body\";\n    !<body>!<}body>\n\n\n    if( ! writer__endFile() ) { \n      continue;\n    }\n\n\n    !<{postwrite>/* section:postwrite */\n    writer__currentSection = \"postwrite\";\n    !<postwrite>!<}postwrite>\n\n\n    exception_for_this_file:\n    if( writer__iException ) {\n      writer__handleException( _strcat( WRITER__UITEXT_ExceptionIn, _strcat( WRITER__UITEXT_Section, writer__currentSection ) ), writer__iExceptionMessage );      \n    }\n\n    writer__nextFile();       \n  }\n \n\n  !<{cleanup>/* section:cleanup */\n  writer__currentSection = \"cleanup\";\n  !<cleanup>!<}cleanup>\n\n\n  exception_for_all_files:\n  if( writer__iException ) {\n    writer__handleException( _strcat( WRITER__UITEXT_ExceptionIn, _strcat( WRITER__UITEXT_Section, writer__currentSection ) ), writer__iExceptionMessage );      \n  }\n}\n\n\n\n/** Start writing a file. */\nint writer__startFile() {\n  writer__iCurrentTextLine       = (struct writer__FileText*) malloc(sizeof(struct writer__FileText));\n  writer__iCurrentTextLine->line = WRITER__STRING_empty;\n  writer__iCurrentTextLine->next = NULL;\n  writer__iCurrentText           = writer__iCurrentTextLine;\n  return 1;\n}\n\n\n\n/** End writing a file. */\nint writer__endFile() {\n\n  int   endOK        = 1;\n  char* outputFolder;\n  char* separator = WRITER__STRING_separator;\n  char* fileName;\n  char* filePath;\n  int   outputFolder_len;\n  int   separator_len;\n  int   fileName_len;\n\n  outputFolder     = _getOutputFolder();\n  fileName         = _getFullFileName();\n  outputFolder_len = strlen( outputFolder );\n  separator_len    = strlen( separator );\n  fileName_len     = strlen( fileName );\n\n  filePath = (char*) malloc( (unsigned) (outputFolder_len + separator_len + fileName_len + 1) );\n  strcpy( filePath, outputFolder );\n  strcat( filePath, separator );\n  strcat( filePath, fileName );\n\n  if( writer__iBackup ) {\n    writer__backup( filePath, fileName, writer__iBackupFolder );\n    if( writer__iException ) {\n       writer__handleException( _strcat( WRITER__UITEXT_UnableToBackupFile, _strcat( filePath, _strcat( WRITER__UITEXT_ToBackupFolder, writer__iBackupFolder ) ) ), writer__iExceptionMessage );\n       endOK = 0;\n    }\n  }\n\n  if( endOK && writer__iSave ) {\n    _saveTextFile( filePath, writer__iCurrentText );\n    if( writer__iException ) {\n      writer__handleException( _strcat( WRITER__UITEXT_UnableToSaveFile, filePath), writer__iExceptionMessage );\n      endOK = 0;\n    } else {\n      writer__userMessage( _strcat( WRITER__UITEXT_SavedFile, _strcat( filePath, WRITER__UITEXT_NewLine ) ), 0 );\n    }\n  }\n\n  return endOK;\n}\n\n\n\n/** Move to next file */\nvoid writer__nextFile() {\n  writer__iCurrentFileIndex = writer__iCurrentFileIndex + 1;\n}\n\n\n\n/** Handle command line arguments to CodeWriter. */\nvoid writer__handleArgs( int argc, char *argv[] ) {\n\n  /* set arg names */\n  char* argName_OutputFolder           = _strcat( WRITER__ARGUMENT_CONTROL_PREFIX, WRITER__ARGUMENT_OutputFolder );\n  char* argName_MetaPropFile           = _strcat( WRITER__ARGUMENT_CONTROL_PREFIX, WRITER__ARGUMENT_MetaPropFile );\n  char* argName_BackupFolder           = _strcat( WRITER__ARGUMENT_CONTROL_PREFIX, WRITER__ARGUMENT_BackupFolder );\n  char* argName_NoBackup               = _strcat( WRITER__ARGUMENT_CONTROL_PREFIX, WRITER__ARGUMENT_NoBackup );\n\n  /* parse args */\n  /* ... */\n\n  int argI    = 0;\n  int numArgs = argc;\n  for( argI = 0; argI < numArgs; argI++ ) {\n    if( 0 == strncmp( argName_OutputFolder, argv[argI], strlen( argName_OutputFolder) ) ) {\n      _setOutputFolder( (char*) &argv[argI][ strlen( argName_OutputFolder ) ] );\n    }\n    else if( 0 == strncmp( argName_MetaPropFile, argv[argI], strlen( argName_MetaPropFile ) ) ) {\n      _setMetaPropFile( (char*) &argv[argI][ strlen( argName_MetaPropFile ) ] );\n    }\n    else if( 0 == strncmp( argName_BackupFolder, argv[argI], strlen( argName_BackupFolder ) ) ) {\n      _setBackupFolder( (char*) &argv[argI][ strlen( argName_BackupFolder ) ] );\n    }\n    else if( 0 == strcmp( argName_NoBackup, argv[argI] ) ) {\n      _backup( $<lang.FalseString> ); /* NOTE: -B => don't make backups */\n    }\n  }\n\n  /* set options */\n  writer__initArgs( argc, argv );\n\n}\n\n\n\n/** Set defaults from configuration property set. */\nvoid writer__setDefaults() {\n\n  $<{main.FileNameRoot>_setFileNameRoot( \"$<\\main.FileNameRoot>\" );$<}main.FileNameRoot>\n  $<{main.FileNamePrefix>_setFileNamePrefix( \"$<\\main.FileNamePrefix>\" );$<}main.FileNamePrefix>\n  $<{main.FileNameSuffix>_setFileNameSuffix( \"$<\\main.FileNameSuffix>\" );$<}main.FileNameSufffix>\n\n  $<{main.OutputFolder>_setOutputFolder( \"$<\\main.OutputFolder>\" );$<}main.OutputFolder>\n\n  $<{main.BackupFolder>_setBackupFolder( \"$<\\main.BackupFolder>\" );$<}main.BackupFolder>\n  $<{main.BackupPrefix>_setBackupPrefix( \"$<\\main.BackupPrefix>\" );$<}main.BackupPrefix>\n  $<{main.BackupSuffix>_setBackupSuffix( \"$<\\main.BackupSuffix>\" );$<}main.BackupSufffix>\n  _backup( 0 == strcmp( \"$<lang.TrueString>\", \"$<jostraca.MakeBackup>\" ) );\n\n}\n\n\n\n/** Store command line arguments */\nvoid writer__initArgs(int argc, char** argv) {\n  int      argI        = 0;\n  int      userArgI    = 0;\n\n  writer__iNumArgs     = argc;\n  writer__iArgs        = argv;\n  writer__iNumUserArgs = writer__iNumArgs - 1; /* program name is first arg */\n\n  for( argI = 1; argI < writer__iNumArgs; argI = argI + 1 ) {\n    if( 0 == strncmp( WRITER__ARGUMENT_CONTROL_PREFIX, writer__iArgs[argI], strlen(WRITER__ARGUMENT_CONTROL_PREFIX) ) ) {\n      writer__iNumUserArgs = writer__iNumUserArgs - 1;\n    }\n  }\n\n  writer__iUserArgs = (char**) malloc( writer__iNumUserArgs * sizeof(char**) );\n\n  for( argI = 1; argI < writer__iNumArgs; argI = argI + 1 ) {\n    if( 0 != strncmp( WRITER__ARGUMENT_CONTROL_PREFIX, writer__iArgs[argI], strlen(WRITER__ARGUMENT_CONTROL_PREFIX) ) ) {\n      writer__iUserArgs[ userArgI ] = writer__iArgs[ argI ];\n      userArgI = userArgI + 1;\n    }\n  }\n}\n\n\n\n/** Print a user readable message */\nvoid writer__userMessage( char* pMessage, int pError ) {\n  if( perror ) {\n    fprintf( stderr, pMessage );\n  }\n  else {\n  printf( pMessage );\n}\n}\n\n\n\n/** Handle exceptions: print an explanation for user. */\nvoid writer__handleException( char* pMessage, char* pException ) {\n\n  char* userMsg = WRITER__UITEXT_ErrorHeader;\n\n  userMsg = _strcat( userMsg, writer__describeState() );\n  userMsg = _strcat( userMsg, pMessage );\n  userMsg = _strcat( userMsg, WRITER__UITEXT_ColonNewLine );\n  userMsg = _strcat( userMsg, pException );\n  userMsg = _strcat( userMsg, WRITER__UITEXT_ErrorFooter );\n\n  writer__userMessage( userMsg, 1 );\n\n  writer__iException = 0;\n}\n\n\n\n/** Provide a concise description of the state of the CodeWriter. */\nchar* writer__describeState() {\n    char* currentState = WRITER__UITEXT_CodeWriterState;\n    char fileIndex[22]; \n\n    sprintf( fileIndex, \"%d\", _getFileIndex() );\n\n    currentState = _strcat( currentState, WRITER__UITEXT_GetFileIndexEquals );\n    currentState = _strcat( currentState, fileIndex );\n    currentState = _strcat( currentState, WRITER__UITEXT_GetFullFileNameEquals );\n    currentState = _strcat( currentState, _getFullFileName() );\n    currentState = _strcat( currentState, WRITER__UITEXT_GetOutputFolderEquals );\n    currentState = _strcat( currentState, _getOutputFolder() );\n    currentState = _strcat( currentState, WRITER__UITEXT_NewLine );\n\n    return currentState;\n}\n\n\n\n/** Backup overwritten files, if they exist.\n *  Backups have the format: [YYYYMMDDhhmmss][prefix][filename][suffix].\n */\nvoid writer__backup( char* pFilePath, char* pFileName, char* pBackupFolder ) {\n\n  DIR*       backupFolder;\n  time_t     now;\n  struct tm* calendar;\n  char*      year_yyyy;\n  char*      month_mm;\n  char*      day_dd;\n  char*      hour_hh;\n  char*      minute_mm;\n  char*      second_ss;\n  char       buffer[11];\n  char*      dateTime;\n  char*      backupFileName;\n  char*      backupFilePath;\n  struct writer__FileText* fileContents;\n\n  /* check backup folder ( create if necessary ) */\n  /* ... */\n\n  backupFolder = opendir( pBackupFolder );   \n  if( NULL == backupFolder) {\n    if( -1 == mkdir( pBackupFolder, 0700 ) ) {\n      writer__iExceptionMessage = _strcat( WRITER__UITEXT_BackupFolderColon, _strcat( pBackupFolder, WRITER__UITEXT_BackupFolderExistFailure ) );\n      writer__iException = 1;\n      return;\n    }\n  }\n  if( NULL != backupFolder ) {\n    closedir( backupFolder );\n  }\n\n\n  /* create backup file path */\n  now      = (time_t) time( NULL );\n  calendar = (struct tm*) localtime( &now );\n\n  sprintf( buffer, \"%d\", 1900+(calendar->tm_year) );\n  year_yyyy = _align( buffer, \"0\", 4, 'r' );\n\n  sprintf( buffer, \"%d\", 1+(calendar->tm_mon) );\n  month_mm = _align( buffer, \"0\", 2, 'r' );\n\n  sprintf( buffer, \"%d\", calendar->tm_mday );\n  day_dd = _align( buffer, \"0\", 2, 'r' );\n\n  sprintf( buffer, \"%d\", calendar->tm_hour );\n  hour_hh = _align( buffer, \"0\", 2, 'r' );\n\n  sprintf( buffer, \"%d\", calendar->tm_min );\n  minute_mm = _align( buffer, \"0\", 2, 'r' );\n\n  sprintf( buffer, \"%d\", calendar->tm_sec );\n  second_ss = _align( buffer, \"0\", 2, 'r' );\n\n  dateTime       = _strcat( year_yyyy, _strcat( month_mm, _strcat( day_dd, _strcat( hour_hh, _strcat( minute_mm, second_ss ) ) ) ) );\n  backupFileName = _strcat( dateTime, _strcat( writer__iBackupPrefix, _strcat( pFileName, writer__iBackupSuffix ) ) );\n  backupFilePath = _strcat( pBackupFolder, _strcat( WRITER__STRING_separator, backupFileName ) );\n  \n  /* save backup file */\n  fileContents = _loadTextFile( pFilePath );\n  if( writer__iException ) { return; }\n\n  _saveTextFile( backupFilePath, fileContents );\n  if( writer__iException ) { return; }\n}\n\n\n\n/** set compile-time properties */\nvoid writer__initProperties() {\n  struct writer__FileText* content;\n  char*  metaPropFile;\n\n  metaPropFile = _getMetaPropFile();\n\n  writer__iProperties = _loadTextFile( metaPropFile );\n}\n\n\n\n/** Store a line of text. */\nstruct writer__FileText* writer__insert( char* pText, struct writer__FileText* pTextLine ) {\n  \n  struct writer__FileText* newtextline      = (struct writer__FileText*) malloc(sizeof(struct writer__FileText));\n  char*                    newtextlinechars = (char*) malloc( (unsigned) (strlen( pText )+1) );\n\n  strcpy(newtextlinechars, pText);\n  newtextline->next = NULL;\n  pTextLine->line   = newtextlinechars;\n  pTextLine->next   = newtextline;\n  return newtextline;\n}\n\n/* Writer Services >> */\n\n\n\n\n/* Template Services (File Generation) << */\n\n/** Set the prefix of the files to be generated. */\nvoid _setFileNamePrefix(char* pPrefix) {\n  writer__iFileNamePrefix = pPrefix;\n}\n\n\n\n/** Get prefix of files to be generated. */\nchar* _getFileNamePrefix() {\n  return writer__iFileNamePrefix;\n}\n\n\n\n/** Set the suffix of the files to be generated. */\nvoid _setFileNameSuffix(char* pSuffix) {\n  writer__iFileNameSuffix = pSuffix;\n}\n\n\n\n/** Get suffix of files to be generated. */\nchar* _getFileNameSuffix() {\n  return writer__iFileNameSuffix;\n}\n\n\n\n/** Set the full name of the file to be generated. \n *  Prefix and Suffix are set to empty.\n */\nvoid _setFullFileName( char* pName ) {\n  _setFileNamePrefix( WRITER__STRING_empty );\n  _setFileNameRoot(   pName );\n  _setFileNameSuffix( WRITER__STRING_empty );\n}\n\n\n\n/** Get the full name of current file being generated. */\nchar* _getFullFileName() {\n  char* fullFileName;\n  char* fileNameRoot; \n  char* fileNamePrefix; \n  char* fileNameSuffix; \n\n  fileNamePrefix = _getFileNamePrefix();\n  fileNameRoot   = _getFileNameRoot();\n  fileNameSuffix = _getFileNameSuffix();  \n\n  fullFileName = _strcat( fileNamePrefix, fileNameRoot );\n  fullFileName = _strcat( fullFileName, fileNameSuffix );\n\n  return fullFileName;\n}\n\n\n\n/** Set the names of the files to be generated. \n *  Prefix and Suffix are set to empty.\n */\nvoid _setFullFileNames( int pNumFileNames, char* pFullFileNames[] ) {\n  _setFileNamePrefix( WRITER__STRING_empty );\n  _setFileNameRoots(  pNumFileNames, pFullFileNames );\n  _setFileNameSuffix( WRITER__STRING_empty );\n}\n\n\n\n/** Get the full names of the files to be generated. */\nchar** _getFullFileNames() {\n\n  char** fileNameRoots;\n  char** fullFileNames;\n  char*  fileNamePrefix; \n  char*  fileNameSuffix; \n  int    numFiles = 0;       \n  int    fileI    = 0;\n\n  fileNameRoots  = _getFileNameRoots();\n  numFiles       = _getNumFiles();\n  fileNamePrefix = _getFileNamePrefix();\n  fileNameSuffix = _getFileNameSuffix();\n\n  fullFileNames = (char**) malloc( numFiles * sizeof(char*) );\n\n  for( fileI = 0; fileI < numFiles; fileI++ ) {\n    fullFileNames[ fileI ] = _strcat( fileNamePrefix, _strcat( fileNameRoots[ fileI ], fileNameSuffix ) );\n  }\n\n  return fullFileNames;\n}\n\n\n\n/** Set the root of the name of the file to be generated. */\nvoid _setFileNameRoot( char* pFileNameRoot ) {\n  char** fileNameRoots = (char**) malloc( sizeof( char* ) );\n  fileNameRoots[0] = pFileNameRoot;\n  _setFileNameRoots( 1, fileNameRoots );\n}\n\n\n\n/** Get the root of the name of the current file being generated. */\nchar* _getFileNameRoot() {\n  char* fileNameRoot = writer__iFileNameRoots[ writer__iCurrentFileIndex ];\n  return fileNameRoot;\n}\n\n\n\n/** Set the roots of the names of the files to be generated. */\nvoid _setFileNameRoots( int pNumFileNameRoots, char* pFileNameRoots[] ) {\n  writer__iNumFiles      = pNumFileNameRoots;\n  writer__iFileNameRoots = pFileNameRoots;\n}\n\n\n\n/** Get roots of the names of files to be generated. */\nchar** _getFileNameRoots() {\n  return (char**) writer__iFileNameRoots;\n}\n\n\n\n/** Get index of file currently being generated. */\nint _getFileIndex() {\n  return writer__iCurrentFileIndex;\n}\n\n\n/** Get number of files to generate. */\nint _getNumFiles() {\n  return writer__iNumFiles;\n}\n\n\n\n/** Set output folder. */\nvoid _setOutputFolder( char* pOutputFolder ) {\n  writer__iOutputFolder = pOutputFolder;\n}\n\n\n\n/** Get output folder. */\nchar* _getOutputFolder() {\n    return writer__iOutputFolder;\n}\n\n\n\n/** Set backup folder. */\nvoid _setBackupFolder( char* pBackupFolder ) {\n  writer__iBackupFolder = pBackupFolder;\n}\n\n\n\n/** Get backup folder. */\nchar* _getBackupFolder() {\n    return writer__iBackupFolder;\n}\n\n\n\n/** Set the prefix of backup files. */\nvoid _setBackupPrefix( char* pBackupPrefix ) {\n  writer__iBackupPrefix = pBackupPrefix;\n}\n\n\n\n/** Set the suffix of backup files. */\nvoid _setBackupSuffix( char* pBackupSuffix ) {\n  writer__iBackupSuffix = pBackupSuffix;\n}\n\n\n\n/** Set to true if generated files are to be backed up to disk automatically. */\nvoid _backup( int pBackup )  {\n  writer__iBackup = pBackup;\n}\n\n\n\n/** Set to true if generated files are to be saved to disk automatically. */\nvoid _save(int pSave) {\n  writer__iSave = pSave;\n}\n\n\n\n/** Save a text file. */\nvoid _saveTextFile( char* pFullPath, struct writer__FileText* pFileText ) {\n\n  struct writer__FileText* fileline;\n  FILE* fp;\n\n  fileline = pFileText;\n  fp = fopen( pFullPath, \"w\");\n  if( NULL == fp ) {\n    writer__iExceptionMessage = (char*) malloc( 55 + sizeof( pFullPath ) );\n    sprintf( writer__iExceptionMessage, \"Error writing: %s\", pFullPath );\n    writer__iException = 1;\n    return;\n  }\n\n  while( NULL != fileline->next ) {\n    fprintf( fp, \"%s\", fileline->line );\n    fileline = fileline->next;\n  }\n\n  fclose( fp );\n}\n\n\n\n/** Load a text file. */\nstruct writer__FileText* _loadTextFile( char* pFullPath ) {\n\n  struct writer__FileText* fileline = (struct writer__FileText*) malloc(sizeof(struct writer__FileText));\n  FILE*                    fp;\n  char                     line[ WRITER__MAX_LINE_LEN ];\n  struct writer__FileText* filetext;\n\n  fp = fopen( pFullPath, \"r\");\n  if( NULL == fp ) {\n    writer__iExceptionMessage = (char*) malloc( 55 + sizeof( pFullPath ) );\n    sprintf( writer__iExceptionMessage, \"Error reading: %s\", pFullPath );\n    writer__iException = 1;\n    return;\n  }\n\n  filetext = fileline;\n  fileline->line = WRITER__STRING_empty;\n  fileline->next = NULL;\n  while( NULL != fgets( line, WRITER__MAX_LINE_LEN, fp ) ) {\n    fileline = writer__insert( line, fileline );\n  }\n\n  fclose( fp );\n\n  return filetext;\n}\n\n\n/** Set build properties file. */\nvoid _setMetaPropFile( char* pMetaPropFile ) {\n  writer__iMetaPropFile   = pMetaPropFile;\n  writer__iPropertiesInit = 0;\n}\n\n\n\n/** Get build properties file. */\nchar* _getMetaPropFile() {\n  return writer__iMetaPropFile;\n}\n\n\n/* Template Services (File Generation) >> */\n\n\n\n\n/* Template Services (Control) << */\n\n/** Get the value of a compile-time property. */\nchar* _getProperty( char* pName ) {\n\n  struct writer__FileText* propline;\n  int cI = 0, nI = 0, sv = 0, pI = 0, namelen = 0;\n  char c;\n  char* pv;\n\n\n  if( 0 == writer__iPropertiesInit ) {\n    writer__initProperties();\n  }\n\n  cI = 0;\n  while( 0 != ( c = pName[cI++] ) ) {}\n  namelen = --cI;\n\n  propline = writer__iProperties;\n  while( NULL != propline->next ) {\n    if( 0 == strncmp( pName, propline->line, namelen ) ) {\n      nI = namelen;\n      while( 0 != ( c = propline->line[nI] ) ) {\n        if( ' ' != c && '\\t' != c && '=' != c && ':' != c ) {         \n          sv = nI;\n          break;\n        }\n        nI++;\n      }\n      while( 0 != ( c = propline->line[nI] ) ) {\n        if( ' ' == c || '\\t' == c || '\\r' == c || '\\n' == c ) {         \n          break;\n        }\n        nI++;\n      }\n\n      if( 0 == sv || sv == nI ) {\n        return \"\";\n      }\n      else {\n        pv = (char*) malloc( (unsigned) (nI-sv+1) ); \n        for( pI = 0; pI < nI-sv; pI++ ) {\n          pv[pI] = propline->line[sv+pI];\n        }\n        pv[nI-sv] = '\\0';\n        return pv;\n      }\n    }\n\n    propline = propline->next;\n  }\n\n\n  return \"\";\n}\n\n\n\n/** Get first user arg. */\nchar* _getFirstUserArg() {\n  return _getUserArg(0);\n}\n\n\n\n/** Get second user arg. */\nchar* _getSecondUserArg() {\n  return _getUserArg(1);\n}\n\n\n\n/** Get third user arg. */\nchar* _getThirdUserArg() {\n  return _getUserArg(2);\n}\n\n\n\n/** Get nth (n=0,1,2,...) user arg (the nth arg with no WRITER__ARGUMENT_CONTROL_PREFIX). */\nchar* _getUserArg( int pOrdinal ) {\n\n  int ordinal = 0;\n  int numArgs = _getNumArgs();\n  int argI    = 0;\n\n  /** ingore code writer name (first arg) */\n  for( argI = 1; argI < numArgs; argI++ ) {\n\n    if( 0 == strncmp( WRITER__ARGUMENT_CONTROL_PREFIX, writer__iArgs[argI], strlen(WRITER__ARGUMENT_CONTROL_PREFIX) ) ) {\n      continue;\n    } else {\n      if( ordinal == pOrdinal ) {\n        return writer__iArgs[argI];\n      } else {\n        ordinal++;\n      }\n    }\n  }\n  return NULL;\n}\n\n\n\n/** Get usercommand line arguments to CodeWriter. */\nchar** _getUserArgs() {\n  return writer__iUserArgs;\n}\n\n\n\n/** Get number of user command line arguments to CodeWriter. */\nint _getNumUserArgs() {\n  return writer__iNumUserArgs;\n}\n\n\n\n/** Get command line arguments to CodeWriter. */\nchar** _getArgs() {\n  return writer__iArgs;\n}\n\n\n\n/** Get number of command line arguments to CodeWriter. */\nint _getNumArgs() {\n  return writer__iNumArgs;\n}\n\n/* Template Services (Control) >> */\n\n\n\n\n/* Template Services (Text Production) << */\n\n\n/** Insert text into generated file. */\nvoid _insert( char* pText ) {\n  writer__iCurrentTextLine = writer__insert( pText, writer__iCurrentTextLine );\n}\n\n\n\n/** Create a String containing specified number of spaces. */\nchar* _spaces( int pNumSpaces ) {\n\n  char* spaces    = NULL;\n  int   spaceI    = 0;\n  int   numSpaces = pNumSpaces;\n\n  if( numSpaces < 0 ) {\n    numSpaces = numSpaces * -1;\n  }\n  spaces = (char*) malloc( (unsigned) (numSpaces+1) );\n\n  *spaces = '\\0';\n  for( spaceI = 0; spaceI < numSpaces; spaceI++ ) {\n    strcat( spaces, \" \");\n  }\n\n  return spaces;\n}\n\n\n\n/** Left align String with spaces. */\nchar* _left(char* pText, int pColWidth ) {\n  return _align( pText, \" \", pColWidth, 'l' );\n} \n\n\n\n/** Right align String with spaces. */\nchar* _right( char* pText, int pColWidth ) {\n  return _align( pText, \" \", pColWidth, 'r' );\n} \n\n\n\n/** Center align String with spaces. */\nchar* _center( char* pText, int pColWidth ) {\n  return _align( pText, \" \", pColWidth, 'c' );\n} \n\n\n\n/** Align text within background text with specified column width.\n *  Alignment can be 'l': left, 'c': center, 'r': right\n */\nchar* _align( char* pText, char* pBackText, int pColWidth, char pAlignment ) {\n\n  char*  result;\n  int    textLen;\n  int    backTextLen;\n  int    remainWidth;\n  int    backTextRepeats;\n  int    backTextRemain;\n  int    backTextI = 0;\n  char*  back = WRITER__STRING_empty;\n  char   buffer[WRITER__MAX_LINE_LEN] = WRITER__STRING_empty;\n  int    backLen;\n\n  textLen = strlen( pText );\n  if( pColWidth > textLen ) {\n    backTextLen     = strlen( pBackText );\n    remainWidth     = pColWidth - textLen;\n    backTextRepeats = remainWidth / backTextLen;\n    backTextRemain  = remainWidth % backTextLen;\n    for( backTextI = 0; backTextI < backTextRepeats; backTextI++ ) {\n      back = _strcat( back, pBackText );\n    }\n    if( 0 < backTextRemain ) {\n      strncpy( buffer, pBackText, backTextRemain );\n      back = _strcat( back, buffer );\n    }\n\n    if( 'l' == pAlignment ) {\n      result = _strcat( pText, back );\n      \n    } else if( 'c' == pAlignment ) {\n      backLen = strlen( back );\n      result = _strcat( strncpy( buffer, back, (backLen/2) ) , pText) ;\n      result = _strcat( result, back+(backLen/2) );\n\n    } else if( 'r' == pAlignment ) {\n      result = _strcat( back, pText );\n    }\n  } \n  else {\n    result = (char*) malloc( (textLen+1) * sizeof(char) );\n    strcpy( result, pText );\n  }\n\n  return result;\n}\n\n\n\n/* Get text of file currently being generated. */\nstruct writer__FileText* _getText() {\n  return writer__iCurrentText;\n}\n\n\n\n/* Set text of file currently being generated. */\nvoid _setText( struct writer__FileText* pFileText ) {\n  writer__iCurrentText = pFileText;\n}\n\n/* Template Services (Text Production) >> */\n\n\n\n\n/* Language Specific Services << */\n\n/** Concatenate two strings, dynamically creating the needed memory. \n *  This is a nice little memory leaker...\n */\nchar * _strcat( char* pFirst, char* pSecond ) {\n  int   lenFirst  = strlen( pFirst );\n  int   lenSecond = strlen( pSecond );\n  char* result    = (char*) malloc( (lenFirst + lenSecond + 1) * sizeof(char) ); \n\n  strcpy( result, pFirst );\n  strcat( result, pSecond );\n\n  return result;\n}\n\n/* Language Specific Services >> */\n\n\n\n!<footer>\n");
    }
