    private static final void makeWF_BasicJythonWriterFormat_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicJythonWriterFormat.jwf", "!<header>\n\nimport os\nimport os.path\nimport sys\nimport time\nimport string\nimport traceback\nimport re\n\n\n\n!<{import># section:import\n!<import>!<}import>\n\n\nclass $<main.CodeWriter>$<{python.CodeWriter.extends>($<python.CodeWriter.extends>)$<}python.CodeWriter.extends>:\n\n\n  def __init__(self):\n\n    # Constants << #\n   \n    # Command line arguments\n    self.WRITER__ARGUMENT_CONTROL_PREFIX         = \"$<main.CodeWriter.argument.ControlPrefix>\"\n    self.WRITER__ARGUMENT_OutputFolder           = \"$<main.CodeWriter.argument.name.OutputFolder>\"\n    self.WRITER__ARGUMENT_MetaPropFile           = \"$<main.CodeWriter.argument.name.MetaPropFile>\"\n    self.WRITER__ARGUMENT_BackupFolder           = \"$<main.CodeWriter.argument.name.BackupFolder>\"\n    self.WRITER__ARGUMENT_NoBackup               = \"$<main.CodeWriter.argument.name.NoBackup>\"\n  \n    # User Interface text message parts\n    self.WRITER__UITEXT_Method                   = \"method \"\n    self.WRITER__UITEXT_Main                     = \"main \"\n    self.WRITER__UITEXT_ExceptionIn              = \"Exception in \"\n    self.WRITER__UITEXT_ColonNewLine             = \":\\n\"\n    self.WRITER__UITEXT_NewLine                  = \"\\n\"\n    self.WRITER__UITEXT_Section                  = \"section \"\n    self.WRITER__UITEXT_SavedFile                = \"Saved file:       \"\n    self.WRITER__UITEXT_UnableToSaveFile         = \"Unable to save file: \"\n    self.WRITER__UITEXT_UnableToBackupFile       = \"Unable to backup file: \"\n    self.WRITER__UITEXT_ToBackupFolder           = \" to backup folder: \"\n    self.WRITER__UITEXT_BackupFolderColon        = \"Backup folder: \"\n    self.WRITER__UITEXT_BackupFolderExistFailure = \" does not exist and cannot be created.\"\n    self.WRITER__UITEXT_BackupFolderNotAFolder   = \" is not a folder.\"\n    self.WRITER__UITEXT_BackupFolderNotWritable  = \" is not writable.\"\n    self.WRITER__UITEXT_CodeWriterState          = \"Code Writer State: \"\n    self.WRITER__UITEXT_GetFileIndexEquals       = \"\\n_getFileIndex()    = \";\n    self.WRITER__UITEXT_GetFullFileNameEquals    = \"\\n_getFullFileName() = \";\n    self.WRITER__UITEXT_GetOutputFolderEquals    = \"\\n_getOutputFolder() = \";\n    self.WRITER__UITEXT_ErrorHeader              = \"\\n\\n--- CodeWriter Error Description Start ---\\n\\n\"\n    self.WRITER__UITEXT_ErrorFooter              = \"\\n--- CodeWriter Error Description End -----\\n\\n\"\n    self.WRITER__UITEXT_UnableToLoadMetaProps    = \"Unable to load metadata from file: \"\n    self.WRITER__UITEXT_PlaceHolderException     = \"This placeholder Exception should never be thrown: there is an error in the WriterFormat.\"\n  \n    # String constants\n    self.WRITER__STRING_empty                    = \"\"\n    self.WRITER__STRING_dot                      = \".\"\n    self.WRITER__STRING_separator                = \"$<\\jostraca.system.fileSeparator>\"\n  \n    # Constants >> #\n  \n  \n  \n  \n    # Writer Variables << #\n  \n    self.writer__iFileNameRoots         = [   self.WRITER__STRING_empty ]   # generated file name roots\n    self.writer__iNumFiles              = 0                                 # number of generated files\n    \n    self.writer__iFileNamePrefix        =   self.WRITER__STRING_empty       # failsafe default\n    self.writer__iFileNameSuffix        =   self.WRITER__STRING_empty       # failsafe default\n  \n    self.writer__iBackupPrefix          =   self.WRITER__STRING_empty       # failsafe default\n    self.writer__iBackupSuffix          =   self.WRITER__STRING_empty       # failsafe default\n  \n    self.writer__iCurrentText           =   self.WRITER__STRING_empty       # current text\n    self.writer__iCurrentFileIndex      = 0                                 # current file index\n  \n    self.writer__iArgs                  = []                                # cmd line args\n    self.writer__iNumArgs               = 0                                 # number of cmd line args\n    self.writer__iUserArgs              = []                                # user cmd line args\n    self.writer__iNumUserArgs           = 0                                 # number of user cmd line args\n  \n    self.writer__iSave                  = 1                                 # save generated code to disk\n    self.writer__iBackup                = 1                                 # make backups\n  \n    self.writer__iOutputFolder          = self.WRITER__STRING_dot           # written code is output to this folder\n    self.writer__iBackupFolder          = self.WRITER__STRING_dot           # overwritten files are placed here\n    self.writer__iMetaPropFile          = self.WRITER__STRING_empty;        # metadata properties file path\n\n    self.writer__iProperties            = {}                                # lookup table for compile time properties\n    self.writer__iPropertiesInit        = $<lang.FalseString>               # true => lookup table initialiased\n\n    self.writer__iContext               = ''                                # context object\n    self.writer__iResult                = ''                                # result object\n\n  \n    # Writer Variables >> #\n\n\n\n  !<{declare># section:declare\n  !<declare>!<}declare>\n\n\n\n  # Execute.\n  def main( self, pArgs ) :\n    try :\n      self.writer__initialize()\n      self.writer__handleArgs( pArgs )\n      self.writer__write()\n  \n      if \"\" == self._getResult():\n         self._setResult( self._getText() )\n\n    except Exception :\n      self.writer__handleException( self.WRITER__UITEXT_ExceptionIn + self.WRITER__UITEXT_Method + self.WRITER__UITEXT_Main )\n  \n\n\n\n  # Writer Services << #\n  \n  # Initialize.\n  def writer__initialize( self ) :\n    self.writer__iCurrentFileIndex = 0\n    self.writer__setDefaults()\n  \n  \n  \n  # Main file generation loop. Template script is placed here in the body section.\n  def writer__write( self ) :\n    \n    # initialize\n    self.writer__currentSection = \"init\"\n    \n    \n    try :\n     \n      !<{init># section:init\n      self.writer__currentSection = \"init\"\n      !<init>!<}init>\n      pass\n  \n     \n      # write files loop  \n      self.writer__numFiles = self._getNumFiles()\n      self.writer__fileI    = 0\n      for self.writer__fileI in range( self.writer__numFiles ) :\n    \n        try :\n     \n          !<{prewrite># section:prewrite\n          self.writer__currentSection = \"prewrite\"\n          !<prewrite>!<}prewrite> \n          pass\n  \n     \n          ok = self.writer__startFile()\n          if ok :     \n     \n            !<{body># section:body\n            self.writer__currentSection = \"body\"\n            !<body>!<}body> \n            pass\n  \n     \n            ok = self.writer__endFile()\n            if ok :     \n  \n              !<{postwrite># section:postwrite\n              self.writer__currentSection = \"postwrite\"\n              !<postwrite>!<}postwrite> \n              pass\n  \n   \n        except Exception :\n          self.writer__handleException( self.WRITER__UITEXT_ExceptionIn + self.WRITER__UITEXT_Section + self.writer__currentSection )\n   \n   \n        self.writer__nextFile()\n   \n   \n      !<{cleanup># section:cleanup\n      self.writer__currentSection = \"cleanup\"\n      !<cleanup>!<}cleanup>\n      pass \n    \n    except Exception :\n      self.writer__handleException( self.WRITER__UITEXT_ExceptionIn + self.WRITER__UITEXT_Section + self.writer__currentSection )\n  \n  \n  \n  # Start writing a file.\n  def writer__startFile( self ) :\n    self.writer__iCurrentText = self.WRITER__STRING_empty\n    return 1\n  \n  \n  \n  # End writing a file.\n  def writer__endFile( self ) :\n    endOK = 1\n  \n    fileName = self._getFullFileName() \n    filePath = self.writer__iOutputFolder + self.WRITER__STRING_separator + fileName\n  \n    if self.writer__iBackup :\n      try :\n        self.writer__backup( filePath, fileName, self.writer__iBackupFolder )\n  \n      except Exception, e :\n        self.writer__handleException( self.WRITER__UITEXT_UnableToBackupFile + filePath + self.WRITER__UITEXT_ToBackupFolder + self.writer__iBackupFolder )\n        endOK = 0\n  \n   \n    if endOK and self.writer__iSave :\n      try :\n        self._saveTextFile( filePath, self.writer__iCurrentText )\n        self.writer__userMessage( self.WRITER__UITEXT_SavedFile + filePath, $<lang.FalseString> ) # CP! + self.WRITER__UITEXT_NewLine )\n  \n      except Exception :\n        self.writer__handleException( self.WRITER__UITEXT_UnableToSaveFile + filePath )\n        endOK = 0\n  \n    return endOK\n    \n  \n  \n  # Move to next file\n  def writer__nextFile( self ) :\n    self.writer__iCurrentFileIndex = self.writer__iCurrentFileIndex + 1\n  \n  \n  \n  # Handle command line arguments to CodeWriter.\n  def writer__handleArgs( self, pArgs ) :\n  \n    # set arg names\n    argName_OutputFolder           = self.WRITER__ARGUMENT_CONTROL_PREFIX + self.WRITER__ARGUMENT_OutputFolder\n    argName_MetaPropFile           = self.WRITER__ARGUMENT_CONTROL_PREFIX + self.WRITER__ARGUMENT_MetaPropFile\n    argName_BackupFolder           = self.WRITER__ARGUMENT_CONTROL_PREFIX + self.WRITER__ARGUMENT_BackupFolder\n    argName_NoBackup               = self.WRITER__ARGUMENT_CONTROL_PREFIX + self.WRITER__ARGUMENT_NoBackup\n  \n    # parse args\n    # ...\n  \n    numArgs = len( pArgs )\n    for argI in range( numArgs ) :\n      if   0 == string.find( pArgs[ argI ], argName_OutputFolder ) :\n        self._setOutputFolder( pArgs[ argI ][len(argName_OutputFolder):] )\n      \n      elif 0 == string.find( pArgs[ argI ], argName_MetaPropFile ) :\n        self._setMetaPropFile( pArgs[ argI ][len(argName_MetaPropFile):] )\n\n      elif 0 == string.find( pArgs[ argI ], argName_BackupFolder ) :\n        self._setBackupFolder( pArgs[ argI ][len(argName_BackupFolder):] )\n  \n      elif argName_NoBackup == pArgs[ argI ]  :\n        self._backup( $<lang.FalseString> ) ## NOTE: -B => don't make backups\n      \n    self.writer__initArgs( len( pArgs ), pArgs )\n  \n  \n  \n  # Set def aults from configuration property set.\n  def writer__setDefaults( self ) :\n  \n    $<{main.FileNameRoot>self._setFileNameRoot( \"$<\\main.FileNameRoot>\" )$<}main.FileNameRoot>\n    $<{main.FileNamePrefix>self._setFileNamePrefix( \"$<\\main.FileNamePrefix>\" )$<}main.FileNamePrefix>\n    $<{main.FileNameSuffix>self._setFileNameSuffix( \"$<\\main.FileNameSuffix>\" )$<}main.FileNameSufffix>\n  \n    $<{main.OutputFolder>self._setOutputFolder( \"$<\\main.OutputFolder>\" )$<}main.OutputFolder>\n  \n    $<{main.BackupFolder>self._setBackupFolder( \"$<\\main.BackupFolder>\" )$<}main.BackupFolder>\n    $<{main.BackupPrefix>self._setBackupPrefix( \"$<\\main.BackupPrefix>\" )$<}main.BackupPrefix>\n    $<{main.BackupSuffix>self._setBackupSuffix( \"$<\\main.BackupSuffix>\" )$<}main.BackupSufffix>\n    self._backup( \"$<lang.TrueString>\" == \"$<jostraca.MakeBackup>\" )\n  \n    pass\n  \n  \n  \n  # Initialize command line arguments.\n  def writer__initArgs( self, pNumArgs, pArgs ) :\n    argI     = 0\n    userArgI = 0\n  \n    self.writer__iNumArgs     = pNumArgs\n    self.writer__iArgs        = pArgs\n    self.writer__iNumUserArgs = self.writer__iNumArgs - 1 # script name is arg 0\n  \n    for argI in range( 1, self.writer__iNumArgs ) :\n      if 0 == string.find( self.writer__iArgs[ argI ], self.WRITER__ARGUMENT_CONTROL_PREFIX ) : \n        self.writer__iNumUserArgs = self.writer__iNumUserArgs - 1\n      \n    for argI in range( 1, self.writer__iNumArgs ) :\n      if 0 == string.find( self.writer__iArgs[ argI ], self.WRITER__ARGUMENT_CONTROL_PREFIX ) : \n        continue\n      else :\n        self.writer__iUserArgs.append( self.writer__iArgs[ argI ] )\n        userArgI = userArgI + 1;\n  \n  \n  \n  # Print a user readable message.\n  def writer__userMessage( self, pMessage, pError ) :\n    if pError :\n      print >> sys.stderr, pMessage\n    else :\n      print pMessage\n  \n  \n  \n  # Handle exceptions: print an explanation for user.\n  def writer__handleException( self, pMessage ) :\n    userMsg = self.WRITER__UITEXT_ErrorHeader\n  \n    userMsg = userMsg + self.writer__describeState() + pMessage + self.WRITER__UITEXT_ColonNewLine\n    userMsg = userMsg + string.join(traceback.format_exception( sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2] ))\n    userMsg = userMsg + self.WRITER__UITEXT_ErrorFooter\n  \n    self.writer__userMessage( userMsg, $<lang.TrueString> )\n  \n  \n  \n  # Provide a concise description of the state of the CodeWriter.\n  def writer__describeState( self ) :\n    currentState = self.WRITER__STRING_empty +                                \\\n        self.WRITER__UITEXT_CodeWriterState                                   \\\n      + self.WRITER__UITEXT_GetFileIndexEquals    + str( self._getFileIndex() )    \\\n      + self.WRITER__UITEXT_GetFullFileNameEquals + self._getFullFileName()        \\\n      + self.WRITER__UITEXT_GetOutputFolderEquals + self._getOutputFolder()        \\\n      + self.WRITER__UITEXT_NewLine\n    return currentState\n  \n  \n  \n  # Backup overwritten files, if they exist.\n  # Backups have the format: [YYYYMMDDhhmmss][prefix][filename][suffix].\n  def writer__backup( self, pFilePath, pFileName, pBackupFolder ) :\n  \n    backupFolder = pBackupFolder\n  \n    # check backup folder ( create if necessary )\n    if not os.path.exists( backupFolder ) :\n      if not os.mkdir( backupFolder, 0700 ) :\n        raise Exception, self.WRITER__UITEXT_BackupFolderColon          \\\n                         + backupFolder                            \\\n                         + self.WRITER__UITEXT_BackupFolderExistFailure\n    if not os.path.isdir( backupFolder ) :\n      raise Exception, self.WRITER__UITEXT_BackupFolderColon        \\\n                       + backupFolder                          \\\n                       + self.WRITER__UITEXT_BackupFolderNotAFolder\n\n    #if not os.access( backupFolder, os.W_OK ) :\n    #  raise Exception, self.WRITER__UITEXT_BackupFolderColon         \\\n    #                   + backupFolder                           \\\n    #                   + self.WRITER__UITEXT_BackupFolderNotWritable\n  \n  \n    # create backup file path\n    calendar = time.localtime( time.time() )\n    year_yyyy    = self._align( str(calendar[0]), \"0\", 4, 'r' )\n    month_mm     = self._align( str(calendar[1]), \"0\", 2, 'r' )\n    day_dd       = self._align( str(calendar[2]), \"0\", 2, 'r' )\n    hour_hh      = self._align( str(calendar[3]), \"0\", 2, 'r' )\n    minute_mm    = self._align( str(calendar[4]), \"0\", 2, 'r' )\n    second_ss    = self._align( str(calendar[5]), \"0\", 2, 'r' )\n    dateTime = year_yyyy+month_mm+day_dd+hour_hh+month_mm+second_ss\n    backupFileName = dateTime + self.writer__iBackupPrefix + pFileName + self.writer__iBackupSuffix\n    backupFilePath = pBackupFolder + self.WRITER__STRING_separator + backupFileName\n    \n    # save backup file\n    if os.path.exists( pFilePath ) :\n      fileContents = self._loadTextFile( pFilePath )\n      self._saveTextFile( backupFilePath, fileContents )\n  \n  \n  \n  # Set compile time properties\n  def writer__initProperties( self ) :\n    metaPropFile = self._getMetaPropFile()\n\n    if not \"\" == metaPropFile:\n      self.writer__iProperties = {}    \n\n      try:\n        content = self._loadTextFile( metaPropFile );\n\n        content = content.replace(\"\\r\\n\",\"\\n\");\n        content = content.replace(\"\\r\",\"\\n\");\n\n        for (name,value,index) in re.findall( '\\n\\s*(.*?)\\s*[=:]\\s*((\\\\\\s*\\n|.)*)', content ):\n          if not name.startswith('#'): \n            value = value.strip()\n            value = re.sub( '\\\\\\s*\\n', '', value )\n            value = value.replace( '\\n', '' )\n            self.writer__iProperties[name] = value    \n\n        self.writer__iPropertiesInit = $<lang.TrueString>\n\n      except:\n        self.writer__handleException( self.WRITER__UITEXT_UnableToLoadMetaProps+self._getMetaPropFile() )\n\n\n  # Writer Services >> #\n  \n  \n  \n  \n  # Template Services (File Generation) << #\n  \n  # Set the prefix of the files to be generated. \n  def _setFileNamePrefix( self, pPrefix ) :\n    prefix = str( pPrefix )\n    self.writer__iFileNamePrefix = prefix\n  \n  \n  \n  # Get prefix of files to be generated.\n  def _getFileNamePrefix( self ) : \n    return self.writer__iFileNamePrefix\n  \n  \n  \n  # Set the suffix of the files to be generated.\n  def _setFileNameSuffix( self, pSuffix ) :\n    suffix = str( pSuffix )\n    self.writer__iFileNameSuffix = suffix\n  \n  \n  \n  # Get suffix of files to be generated.\n  def _getFileNameSuffix( self ) :\n    return self.writer__iFileNameSuffix\n  \n  \n  \n  # Set the full name of the file to be generated. \n  # Prefix and Suffix are set to empty.\n  def _setFullFileName( self, pName ) :\n  \n    name = str( pName )\n    self._setFileNamePrefix( self.WRITER__STRING_empty )\n    self._setFileNameRoot(   name )\n    self._setFileNameSuffix( self.WRITER__STRING_empty )\n  \n  \n  \n  # Get the full name of current file being generated.\n  def _getFullFileName( self ) : \n    return self._getFileNamePrefix() + self._getFileNameRoot() + self._getFileNameSuffix()\n  \n  \n  \n  # Set the names of the files to be generated. \n  # Prefix and Suffix are set to empty.\n  def _setFullFileNames( self, pNames ) :\n    self._setFileNamePrefix( self.WRITER__STRING_empty )\n    self._setFileNameRoots(  pNames )\n    self._setFileNameSuffix( self.WRITER__STRING_empty )\n  \t\n  \n  \n  # Get the full names of the files to be generated.\n  def _getFullFileNames( self ) : \n    fullFileNames  = []\n    fileNameRoots  = self._getFileNameRoots()\n    fileNamePrefix = self._getFileNamePrefix()\n    fileNameSuffix = self._getFileNameSuffix()\n    numFiles       = len( fileNameRoots )\n    for fileI in range( numFiles ) :\n      fullFileNames.append( fileNamePrefix + fileNameRoots[ fileI ] + fileNameSuffix )\n  \n    return fullFileNames\n  \n  \n  \n  # Set the root of the name of the file to be generated. \n  def _setFileNameRoot( self, pRoot ) :\n    root = str( pRoot )\n    self._setFileNameRoots( [ root ] )\n  \n  \n  \n  # Get the root of the name of current file being generated.\n  def _getFileNameRoot( self ) :\n    if self.writer__iCurrentFileIndex < len(self.writer__iFileNameRoots):\n      return self.writer__iFileNameRoots[ self.writer__iCurrentFileIndex ]\n    else:\n      return ''\n  \n  \n  # Get roots of the names of files to be generated.\n  def _getFileNameRoots( self ) :\n    return self.writer__iFileNameRoots\n  \n  \n  \n  # Set the roots of the names of the files to be generated. \n  def _setFileNameRoots( self, pRoots ) :\n    self.writer__iFileNameRoots = pRoots\n    self.writer__iNumFiles      = len( self.writer__iFileNameRoots )\n  \n  \n  \n  # Get index of file currently being generated.\n  def _getFileIndex( self ) :\n    return self.writer__iCurrentFileIndex\n  \n  \n  \n  # Get number of files to generate.\n  def _getNumFiles( self ) :\n    return self.writer__iNumFiles\n  \n  \n  \n  # Set output folder.\n  def _setOutputFolder( self, pOutputFolder ) : \n    outputFolder        = str( pOutputFolder )\n    self.writer__iOutputFolder = outputFolder\n   \n  \n  \n  # Get output folder.\n  def _getOutputFolder( self ) :\n    return self.writer__iOutputFolder\n  \n  \n  \n  # Set backup folder.\n  def _setBackupFolder( self, pBackupFolder ) :\n    self.writer__iBackupFolder = pBackupFolder\n  \n  \n  \n  # Get backup folder.\n  def _getBackupFolder( self ) :\n    return self.writer__iBackupFolder\n  \n  \n  \n  # Set the prefix of backup files.\n  def _setBackupPrefix( self, pBackupPrefix ) :\n    self.writer__iBackupPrefix = pBackupPrefix\n  \n  \n  \n  # Set the suffix of backup files.\n  def _setBackupSuffix( self, pBackupSuffix ) :\n    self.writer__iBackupSuffix = pBackupSuffix\n  \n  \n  \n  # Set to true if generated files are to be backed up to disk automatically.   \n  def _backup( self, pBackup ) :\n    self.writer__iBackup = pBackup\n  \n  \n  \n  # Set to true if generated files are to be saved to disk automatically. \n  def _save( self, pSave ) :\n    self.writer__iSave = pSave\n  \n  \n  \n  # Save a text file.\n  def _saveTextFile( self, pFilePath, pContent ) :\n    file = open( pFilePath, \"w\" )\n  \n    if file :  \n      file.write( pContent )\n      file.close()\n    else :\n      raise Exception, \"Unable to read file: \" + pFilePath\n  \n    \n  \n  # Load a text file.\n  def _loadTextFile( self, pFilePath ) :\n    file = open( pFilePath, \"r\" )\n  \n    if file :  \n      contents = file.readlines()\n      file.close()\n      return string.join( contents )\n  \n    else :\n      raise Exception, \"Unable to read file: \" + pFilePath\n  \n\n\n  # Set build properties file.\n  def _setMetaPropFile( self, pMetaPropFile ):\n    self.writer__iMetaPropFile   = pMetaPropFile\n    self.writer__iPropertiesInit = $<lang.FalseString>\n\n\n\n  # Get build properties file.\n  def _getMetaPropFile( self ):\n     return self.writer__iMetaPropFile\n\n\n\n  # Template Services (File Generation) >> #\n  \n  \n  \n  \n  # Template Services (Control) << #\n  \n  # Get the value of a compile-time property.\n  def _getProperty( self, pName ) :\n  \n    if not self.writer__iPropertiesInit : \n      self.writer__initProperties()\n  \n    name   = str( pName )\n    result = self.writer__iProperties.get(name,'') \n  \n    return result\n  \n  \n  \n  # Get first user arg.\n  def _getFirstUserArg( self ) :\n    return self._getUserArg( 0 )\n  \n  \n  \n  # Get second user arg.\n  def _getSecondUserArg( self ) :\n    return self._getUserArg( 1 )\n  \n  \n  \n  # Get third user arg.\n  def _getThirdUserArg( self ) :\n    return self._getUserArg( 2 )\n  \n  \n  \n  # Get nth (n=0,1,2,...) user arg (the nth arg with no self.WRITER__ARGUMENT_CONTROL_PREFIX).\n  def _getUserArg( self, pOrdinal ) :\n    if pOrdinal < self._getNumUserArgs() :\n      userargs = self._getUserArgs()\n      return userargs[ pOrdinal ]\n    else :\n      return self.WRITER__STRING_empty\n  \n  \n  \n  # Get usercommand line arguments to CodeWriter. \n  def _getUserArgs( self ) :\n    return self.writer__iUserArgs\n  \n  \n  \n  # Get number of user command line arguments to CodeWriter.\n  def _getNumUserArgs( self ) :\n    return self.writer__iNumUserArgs\n  \n  \n  \n  # Get command line arguments to CodeWriter. \n  def _getArgs( self ) :\n    return self.writer__iArgs\n  \n  \n  \n  # Get number of command line arguments to CodeWriter.\n  def _getNumArgs( self ) :\n    return self.writer__iNumArgs\n\n\n  # Set a context object for the template to use.\n  def _setContext( self, pContext ):\n    self.writer__iContext = pContext\n\n\n  # Get the context object if set. NOTE: may return null. */\n  def _getContext(self):\n    return self.writer__iContext\n\n  \n  # Template Services (Control) >> #\n  \n  \n  \n  \n  # Template Services (Text Production) << #\n  \n  \n  # Insert text into generated file.\n  def _insert( self, pText ) :\n    text = str( pText )\n    self.writer__iCurrentText = self.writer__iCurrentText + text\n  \n  \n  \n  # Create a String containing specified number of spaces.\n  def _spaces( self, pNumSpaces ) :\n    return \" \" * abs( int( pNumSpaces ) )\n  \n  \n  \n  # Left align String with spaces. \n  def _left( self, pText, pColWidth ) :\n    return self._align( pText, \" \", pColWidth, 'l' )\n  \n  \n  \n  # Right align String with spaces. \n  def _right( self, pText, pColWidth ) :\n    return self._align( pText, \" \", pColWidth, 'r' )\n  \n  \n  \n  # Center align String with spaces. \n  def _center( self, pText, pColWidth ) :\n    return self._align( pText, \" \", pColWidth, 'c' )\n  \n  \n  \n  # Align text within background text with specified column width.\n  # Alignment can be 'l': left, 'c': center, 'r': right\n  def _align( self, pText, pBackText, pColWidth, pAlignment ) :\n  \n    result = pText\n   \n    try :\n      textLen = len( pText )\n      if pColWidth > textLen :\n        backTextLen     = len( pBackText )\n        remainWidth     = pColWidth - textLen\n        backTextRepeats = remainWidth / backTextLen\n        backTextRemain  = remainWidth % backTextLen\n        back            = self.WRITER__STRING_empty\n        for backTextI in range( backTextRepeats ) :\n          back = back + pBackText\n  \n        back = back + pBackText[0:backTextRemain]\n  \n        if 'l' == pAlignment :\n          result = result + back\n  \n        elif 'c' == pAlignment :\n          result = back[0:(len(back)/2)] + result + back[(len(back)/2):]\n  \n        elif 'r' == pAlignment :\n          result = back + result\n  \n    except Exception, e:\n      result = pText\n  \n    return result\n  \n  \n  \n  # Get text of file currently being generated.\n  def _getText( self ) :\n    return self.writer__iCurrentText\n  \n  \n  \n  # Set text of file currently being generated.\n  def _setText( self, pText ) :\n    self.writer__iCurrentText = pText\n\n\n  # Set a result object for the template to use.\n  def _setResult( self, pResult ):\n    self.writer__iResult = pResult\n\n\n  # Get the result object if set. NOTE: may return null. */\n  def _getResult(self):\n    return self.writer__iResult\n\n  \n  # Template Services (Text Production) >> */\n\n\n\n\n# Language Specific Services << #\n\n\n# Insert text into generated file. \n# This special name is used for automated indentation.\ndef _py_insert( obj, pText ) :\n  obj._insert( pText )\n\n# Language Specific Services >> #\n\n\n\n# Start execution.\nif __name__ == \"__main__\":\n  cw = $<main.CodeWriter>();\n  cw.main( sys.argv )\n  sys.exit( 0 )\n\n\n!<footer>\n");
    }
