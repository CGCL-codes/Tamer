    private static final void makeWF_BasicJavaScriptWriterFormat_jwf(Hashtable pWriterFormats) {
        pWriterFormats.put("BasicJavaScriptWriterFormat.jwf", "!<header>\n\n\n\nfunction $<main.CodeWriter>() {\n  var self = this;\n\n  /* Constants << */\n \n  // Command line arguments\n  var WRITER__ARGUMENT_CONTROL_PREFIX = \"$<main.CodeWriter.argument.ControlPrefix>\";\n  var WRITER__ARGUMENT_OutputFolder   = \"$<main.CodeWriter.argument.name.OutputFolder>\";\n  var WRITER__ARGUMENT_MetaPropFile   = \"$<main.CodeWriter.argument.name.MetaPropFile>$<main.CodeWriter.argument.name.BuildPropFile>\";\n  var WRITER__ARGUMENT_BackupFolder   = \"$<main.CodeWriter.argument.name.BackupFolder>\";\n  var WRITER__ARGUMENT_NoBackup       = \"$<main.CodeWriter.argument.name.NoBackup>\";\n\n  // User Interface text message parts\n  var WRITER__UITEXT_Method                     = \"method \";\n  var WRITER__UITEXT_Main                       = \"main \";\n  var WRITER__UITEXT_ExceptionIn                = \"Exception in \";\n  var WRITER__UITEXT_ColonNewLine               = \":\\n\";\n  var WRITER__UITEXT_NewLine                    = \"\\n\";\n  var WRITER__UITEXT_Section                    = \"section \";\n  var WRITER__UITEXT_SavedFile                  = \"Saved file:       \";\n  var WRITER__UITEXT_UnableToSaveFile           = \"Unable to save file: \";\n  var WRITER__UITEXT_UnableToBackupFile         = \"Unable to backup file: \";\n  var WRITER__UITEXT_ToBackupFolder             = \" to backup folder: \";\n  var WRITER__UITEXT_BackupFolderColon          = \"Backup folder: \";\n  var WRITER__UITEXT_BackupFolderExistFailure   = \" does not exist and cannot be created.\";\n  var WRITER__UITEXT_BackupFolderNotAFolder     = \" is not a folder.\";\n  var WRITER__UITEXT_BackupFolderNotWritable    = \" is not writable.\";\n  var WRITER__UITEXT_CodeWriterState            = \"Code Writer State: \";\n  var WRITER__UITEXT_GetFileIndexEquals         = \"\\n_getFileIndex()    = \";\n  var WRITER__UITEXT_GetFullFileNameEquals      = \"\\n_getFullFileName() = \";\n  var WRITER__UITEXT_GetOutputFolderEquals      = \"\\n_getOutputFolder() = \";\n  var WRITER__UITEXT_ErrorHeader                = \"\\n\\n--- CodeWriter Error Description Start ---\\n\\n\";\n  var WRITER__UITEXT_ErrorFooter                = \"\\n\\n--- CodeWriter Error Description End -----\\n\\n\";\n  var WRITER__UITEXT_UnableToLoadMetaProps      = \"Unable to load metadata from file: \";\n  var WRITER__UITEXT_UndefinedProperty          = \"Undefined property: \";\n  var WRITER__UITEXT_UnableToCreateOutputFolder = \"Unable to create output folder: \";\n\n  // String constants \n  var WRITER__STRING_empty                      = \"\";\n  var WRITER__STRING_dot                        = \".\";\n  var WRITER__STRING_separator                  = java.io.File.separator;\n\n  /* Constants >> */\n\n\n\n\n  /* Writer Variables << */\n\n  var writer__iFileNameRoots    = [];                   // generated file name roots\n  var writer__iNumFiles         = 0;                    // number of generated files\n  \n  var writer__iFileNamePrefix   = WRITER__STRING_empty; // failsafe default\n  var writer__iFileNameSuffix   = WRITER__STRING_empty; // failsafe default\n\n  var writer__iBackupPrefix     = WRITER__STRING_empty; // failsafe default\n  var writer__iBackupSuffix     = WRITER__STRING_empty; // failsafe default\n\n  var writer__iCurrentText      = [];                   // current text\n  var writer__iCurrentFileIndex = 0;                    // current file index\n\n  var writer__iArgs             = [];                   // cmd line args\n  var writer__iNumArgs          = 0;                    // number of cmd line args\n  var writer__iUserArgs         = [];                   // user cmd line args\n  var writer__iNumUserArgs      = 0;                    // number of user cmd line args\n\n  var writer__iSave             = true;                 // save generated code to disk\n  var writer__iBackup           = true;                 // make backups\n\n  var writer__iOutputFolder     = WRITER__STRING_dot;   // written code is output to this folder\n  var writer__iBackupFolder     = WRITER__STRING_dot;   // overwritten files are placed here\n  var writer__iMetaPropFile     = null;                 // metadata properties file path\n\n  var writer__iProperties       = null;                 // build properties\n  var writer__iPropertiesInit   = false;                // true => lookup table initialiased\n\n  var writer__iContext          = null;                 // context object\n  var writer__iResult           = null;                 // result object\n\n  var writer__iThrow            = false;                // throw Exceptions\n\n  /* Writer Variables >> */\n\n\n\n\n  !<{declare>// section:declare\n  !<declare>!<}declare>\n\n\n\n\n  /* Writer Services << */\n\n  /** Generate. */\n  self._generate = function( pArgs, pThrow ) {\n     writer__iThrow = pThrow;\n\n    try {\n      writer__initialize();\n      writer__handleArgs( pArgs );\n      writer__write();    \n\n      var result = self._getResult();\n      if( null == result ) {\n        result = self._getText();\n        self._setResult( result );\n      }\n\n      return result;\n    } \n    catch( e ) {\n      writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Method + WRITER__UITEXT_Main, e );\n      return 1;\n    }\n  }\n\n\n  /* Initialize. */\n  function writer__initialize() {\n    writer__iCurrentFileIndex = 0;\n    writer__setDefaults();\n  }\n\n\n\n  /** Main file generation loop. Template script is placed here in the body section. */\n  function writer__write() {\n\n    // initialize\n    var writer__currentSection = \"init\";\n\n    try {\n      !<{init>// section:init\n      !<init>!<}init>\n\n\n      // write files loop\n      var writer__numFiles = self._getNumFiles();\n      var writer__fileI    = 0;\n      writer__next_file: for( writer__fileI = 0; writer__fileI < writer__numFiles; writer__fileI = writer__fileI + 1 ) {\n\n        try {\n          !<{prewrite>// section:prewrite\n          writer__currentSection = \"prewrite\";\n          !<prewrite>!<}prewrite>\n\n\n          if( ! writer__startFile() ) { continue writer__next_file; }\n\n\n          !<{body>// section:body\n          writer__currentSection = \"body\";\n          !<body>!<}body>\n\n\n          if( ! writer__endFile() ) { continue writer__next_file; }\n\n\n          !<{postwrite>// section:postwrite\n          writer__currentSection = \"postwrite\";\n          !<postwrite>!<}postwrite>\n\n\n        } \n        catch( e ) {\n           writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Section + writer__currentSection, e );\n        }\n\n        writer__nextFile();       \n      }\n \n\n      !<{cleanup>// section:cleanup\n      writer__currentSection = \"cleanup\";\n      !<cleanup>!<}cleanup>\n\n    } \n    catch( e ) {\n      writer__handleException( WRITER__UITEXT_ExceptionIn + WRITER__UITEXT_Section + writer__currentSection, e );\n    }\n  }\n\n\n\n  /** Start writing a file. */\n  function writer__startFile() {\n    writer__iCurrentText = [];\n    return true;\n  }\n\n\n\n  /** End writing a file. */\n  function writer__endFile() {\n    var endOK = true;\n  \n    var filePath = \"output-file-path\";\n\n    if( endOK ) {\n      var fileName = self._getFullFileName();\n      filePath \n        = writer__iOutputFolder\n        + WRITER__STRING_separator\n        + fileName;\n\n      if( writer__iBackup ) {\n        try {\n          writer__backup( filePath, fileName, writer__iBackupFolder );\n        } \n        catch( e ) {\n          writer__handleException( WRITER__UITEXT_UnableToBackupFile \n                                   + filePath \n                                   + WRITER__UITEXT_ToBackupFolder\n                                   + writer__iBackupFolder\n                                   ,e );\n          endOK = false;\n        }\n      }\n    }\n\n    var outputFolder = null;\n    try {\n      outputFolder = new java.io.File( filePath ).getParentFile();\n      if( null != outputFolder && !outputFolder.exists() ) {\n        outputFolder.mkdirs();\n      }\n    }\n    catch( e ) {\n      writer__handleException( WRITER__UITEXT_UnableToCreateOutputFolder \n                               + outputFolder\n                               ,e );\n      endOK = false;\n    }\n\n\n    if( endOK && writer__iSave ) {\n      try {\n        self._saveTextFile( filePath, writer__iCurrentText.join('') );\n        writer__userMessage( WRITER__UITEXT_SavedFile + filePath + WRITER__UITEXT_NewLine, false );\n      } \n      catch( e ) {\n        writer__handleException( WRITER__UITEXT_UnableToSaveFile + filePath, e );\n        endOK = false;\n      }\n    }\n\n    return endOK;\n  }\n\n\n\n  /** Move to next file. */\n  function writer__nextFile() {\n    writer__iCurrentFileIndex = writer__iCurrentFileIndex + 1;\n  }\n\n\n\n  /** Handle command line arguments to CodeWriter. */\n  function writer__handleArgs( pArgs ) {\n\n    // set arg names\n    var argName_OutputFolder     = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_OutputFolder;\n    var argName_MetaPropFile     = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_MetaPropFile;\n    var argName_BackupFolder     = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_BackupFolder;\n    var argName_NoBackup         = WRITER__ARGUMENT_CONTROL_PREFIX + WRITER__ARGUMENT_NoBackup;\n\n    // parse\n    var numArgs = pArgs.length;\n    for( var argI = 0; argI < numArgs; argI = argI + 1 ) {\n      if( 0 < argName_OutputFolder.length && 0 == pArgs[argI].indexOf( argName_OutputFolder ) ) {\n        self._setOutputFolder( pArgs[ argI ].substring( argName_OutputFolder.length ) );\n      }\n      else if( 0 < argName_MetaPropFile.length && 0 == pArgs[argI].indexOf( argName_MetaPropFile ) ) {\n        self._setMetaPropFile( pArgs[ argI ].substring( argName_MetaPropFile.length ) );\n      }\n      else if( 0 < argName_BackupFolder.length && 0 == pArgs[argI].indexOf( argName_BackupFolder ) ) {\n        self._setBackupFolder( pArgs[ argI ].substring( argName_BackupFolder.length ) );\n      }\n      else if( 0 < argName_NoBackup.length && argName_NoBackup.equals( pArgs[ argI ] ) ) {\n        self._backup( $<lang.FalseString> ); // NOTE: -B => don't make backups\n      }\n    }\n\n    writer__initArgs( pArgs.length, pArgs );\n  }\n\n\n\n  /** Set defaults from configuration property set. */\n  function writer__setDefaults() {\n\n    $<{main.FileNameRoot>self._setFileNameRoot( \"$<\\main.FileNameRoot>\" );$<}main.FileNameRoot>\n    $<{main.FileNamePrefix>self._setFileNamePrefix( \"$<\\main.FileNamePrefix>\" );$<}main.FileNamePrefix>\n    $<{main.FileNameSuffix>self._setFileNameSuffix( \"$<\\main.FileNameSuffix>\" );$<}main.FileNameSufffix>\n\n    $<{main.OutputFolder>self._setOutputFolder( \"$<\\main.OutputFolder>\" );$<}main.OutputFolder>\n\n    $<{main.BackupFolder>self._setBackupFolder( \"$<\\main.BackupFolder>\" );$<}main.BackupFolder>\n    $<{main.BackupPrefix>self._setBackupPrefix( \"$<\\main.BackupPrefix>\" );$<}main.BackupPrefix>\n    $<{main.BackupSuffix>self._setBackupSuffix( \"$<\\main.BackupSuffix>\" );$<}main.BackupSufffix>\n    self._backup( \"$<lang.TrueString>\".equals( \"$<jostraca.MakeBackup>\" ) );\n\n  }\n\n\n\n  /** Initialize command line arguments. */\n  function writer__initArgs( pNumArgs, pArgs ) {\n    var argI        = 0;\n    var userArgI    = 0;\n\n    writer__iNumArgs     = pNumArgs;\n    writer__iArgs        = pArgs;\n    writer__iNumUserArgs = writer__iNumArgs;\n\n    for( argI = 0; argI < writer__iNumArgs; argI = argI + 1 ) {\n      if( 0 == writer__iArgs[argI].indexOf( WRITER__ARGUMENT_CONTROL_PREFIX ) ) {\n        writer__iNumUserArgs = writer__iNumUserArgs - 1;\n      }\n    }\n\n    writer__iUserArgs = [];\n    for( argI = 0; argI < writer__iNumArgs; argI = argI + 1 ) {\n      if( -1 == writer__iArgs[argI].indexOf( WRITER__ARGUMENT_CONTROL_PREFIX ) ) {\n        writer__iUserArgs[ userArgI ] = writer__iArgs[ argI ];\n        userArgI = userArgI + 1;\n      }\n    }\n  }\n\n\n\n  /** Print a user readable message. */\n  function writer__userMessage( pMessage, pIsError ) {\n    (pIsError?java.lang.System.err:java.lang.System.out).print( pMessage );\n  }\n\n\n\n  /** Handle exceptions: print an explanation for user. */\n  function writer__handleException( pMessage, pException ) {\n    if( pException.runtime ) {\n      throw pMessage+\": \"+pException.msg;\n    }\n    else {\n      var userMsg = WRITER__UITEXT_ErrorHeader + \n        writer__describeState() + pMessage + WRITER__UITEXT_ColonNewLine + (pException.msg?pException.msg:pException) +\n        WRITER__UITEXT_ErrorFooter;\n\n      if( writer__iThrow ) {\n        throw { runtime:true, msg:userMsg };\n      }\n      else {\n        writer__userMessage( userMsg, true );\n      }\n    }\n  }\n\n\n\n  /** Provide a concise description of the state of the CodeWriter. */\n  function writer__describeState() {\n    var currentState \n      = WRITER__UITEXT_CodeWriterState\n      + WRITER__UITEXT_GetFileIndexEquals    + self._getFileIndex() \n      + WRITER__UITEXT_GetFullFileNameEquals + self._getFullFileName()\n      + WRITER__UITEXT_GetOutputFolderEquals + self._getOutputFolder()\n      + WRITER__UITEXT_NewLine\n      ; \n    return currentState;\n  }\n\n\n\n  /** Backup overwritten files, if they exist.\n   *  Backups have the format: [YYYYMMDDhhmmss][prefix][filename][suffix].\n   */ \n  function writer__backup( pFilePath, pFileName, pBackupFolder ) {\n\n    var backupFolder = new java.io.File( pBackupFolder );\n\n    // check backup folder ( create if necessary )\n    if( ! backupFolder.exists() ) {\n      if( ! backupFolder.mkdirs() ) {\n        throw { runtime:true, msg:WRITER__UITEXT_BackupFolderColon\n                                  + backupFolder\n                                  + WRITER__UITEXT_BackupFolderExistFailure };\n      }\n    }\n    if( ! backupFolder.isDirectory() ) {\n      throw { runtime:true, msg:WRITER__UITEXT_BackupFolderColon \n                                  + backupFolder\n                                  + WRITER__UITEXT_BackupFolderNotAFolder };\n    }\n    if( ! backupFolder.canWrite() ) {\n      throw { runtime:true, msg:WRITER__UITEXT_BackupFolderColon\n                                  + backupFolder\n                                  + WRITER__UITEXT_BackupFolderNotWritable };\n    }\n\n    // create backup file path\n    var calendar = java.util.Calendar.getInstance();\n    var year_yyyy = self._align( java.lang.String.valueOf( calendar.get(java.util.Calendar.YEAR) ),         \"0\", 4, 'r' );\n    var month_mm  = self._align( java.lang.String.valueOf( (1+calendar.get(java.util.Calendar.MONTH)) ),    \"0\", 2, 'r' );\n    var day_dd    = self._align( java.lang.String.valueOf( calendar.get(java.util.Calendar.DAY_OF_MONTH) ), \"0\", 2, 'r' );\n    var hour_hh   = self._align( java.lang.String.valueOf( calendar.get(java.util.Calendar.HOUR_OF_DAY) ),  \"0\", 2, 'r' );\n    var minute_mm = self._align( java.lang.String.valueOf( calendar.get(java.util.Calendar.MINUTE) ),       \"0\", 2, 'r' );\n    var second_ss = self._align( java.lang.String.valueOf( calendar.get(java.util.Calendar.SECOND) ),       \"0\", 2, 'r' );\n    var dateTime       = year_yyyy+month_mm+day_dd+hour_hh+minute_mm+second_ss;\n    var backupFileName = dateTime + writer__iBackupPrefix + pFileName + writer__iBackupSuffix;\n    var backupFilePath = new java.io.File( pBackupFolder, backupFileName );\n    \n    var fullBackupFolder = backupFilePath.getParentFile();\n    if( null != fullBackupFolder && !fullBackupFolder.exists() ) {\n      if( ! fullBackupFolder.mkdirs() ) {\n        throw { runtime:true, msg:WRITER__UITEXT_BackupFolderColon\n                                    + fullBackupFolder\n                                    + WRITER__UITEXT_BackupFolderExistFailure };\n      }\n    }\n\n\n    // save backup file\n    var fileToBackup = new java.io.File( pFilePath );\n    if( fileToBackup.exists() ) {\n      var fileContents = self._loadTextFile( pFilePath );\n      self._saveTextFile( backupFilePath.getPath(), fileContents );\n    }\n  }\n\n\n\n  /** Load build properties. */\n  function writer__initProperties() {\n\n    var metaPropFile = self._getMetaPropFile();\n    if( null != metaPropFile ) {\n      writer__iProperties = new java.util.Properties();\n      \n      try {\n        var fis = new java.io.FileInputStream( self._getMetaPropFile() );\n        writer__iProperties.load( fis );\n        fis.close();\n      }\n      catch( e ) {\n        writer__handleException( WRITER__UITEXT_UnableToLoadMetaProps+_getMetaPropFile(), e );\n      }\n\n      writer__iPropertiesInit = true;\n    }\n  }\n\n  /* Writer Services >> */\n \n\n\n\n  /* Template Services (File Generation) << */\n\n  /** Set the prefix of the files to be generated. */\n  self._setFileNamePrefix = function( pPrefix ) {\n    if( null == pPrefix ) {\n      return; // ignore\n    }\n    writer__iFileNamePrefix = pPrefix;\n  }\n\n\n\n  /** Get prefix of files to be generated. */\n  self._getFileNamePrefix = function() {\n    return writer__iFileNamePrefix;\n  }\n\n\n\n  /** Set the suffix of the files to be generated. */\n  self._setFileNameSuffix = function( pSuffix ) {\n    if( null == pSuffix ) {\n      return; // ignore\n    }\n    writer__iFileNameSuffix = pSuffix;\n  }\n\n\n\n  /** Get suffix of files to be generated. */\n  self._getFileNameSuffix = function() {\n    return writer__iFileNameSuffix;\n  }\n\n\n\n  /** Set the full name of the file to be generated. \n   *  Prefix and Suffix are set to empty.\n   */\n  self._setFullFileName = function( pName ) {\n    self._setFileNamePrefix( WRITER__STRING_empty );\n    self._setFileNameRoot(   pName );\n    self._setFileNameSuffix( WRITER__STRING_empty );\n  }\n\n\n\n  /** Get the full name of current file being generated. */\n  self._getFullFileName = function() {\n    return self._getFileNamePrefix() + self._getFileNameRoot() + self._getFileNameSuffix();\n  }\n\n\n\n  /** Set the names of the files to be generated. \n   *  Prefix and Suffix are set to empty.\n   */\n  self._setFullFileNames = function( pNames ) {\n    self._setFileNamePrefix( WRITER__STRING_empty );\n    self._setFileNameRoots(  pNames );\n    self._setFileNameSuffix( WRITER__STRING_empty );\n  }\n\n\n\n  /** Get the full names of the files to be generated. */\n  self._getFullFileNames = function() {\n\n    var fileNameRoots  = self._getFileNameRoots();\n    var numFiles       = fileNameRoots.length;\n    var fullFileNames  = [];\n    var fileNamePrefix = self._getFileNamePrefix();\n    var fileNameSuffix = self._getFileNameSuffix();\n\n    for( var fileI = 0; fileI < numFiles; fileI = fileI + 1 ) {\n      fullFileNames[ fileI ] = fileNamePrefix + fileNameRoots[ fileI ] + fileNameSuffix;\n    }\n\n    return fullFileNames;\n  }\n\n\n\n  /** Set the root of the name of the file to be generated. */\n  self._setFileNameRoot = function( pFileNameRoot ) {\n    if( null == pFileNameRoot ) {\n      return; // ignore\n    }\n    self._setFileNameRoots( [ pFileNameRoot ] );\n  }\n\n\n\n  /** Get the root of the name of the current file being generated. */\n  self._getFileNameRoot = function() {\n    if( 0 < writer__iFileNameRoots.length ) {\n      return writer__iFileNameRoots[ writer__iCurrentFileIndex ];\n    }\n    return WRITER__STRING_empty;\n  }\n\n\n\n  /** Set the roots of the names of the files to be generated. */\n  self._setFileNameRoots = function( pFileNameRoots ) {\n    if( null == pFileNameRoots ) {\n      return; // ignore\n    }\n\n    writer__iFileNameRoots = pFileNameRoots;\n    writer__iNumFiles      = pFileNameRoots.length;\n  }\n\n\n\n  /** Get roots of the names of files to be generated. */\n  self._getFileNameRoots = function() {\n    return writer__iFileNameRoots;\n  }\n\n\n\n  /** Get index of file currently being generated. */\n  self._getFileIndex = function() {\n    return writer__iCurrentFileIndex;\n  }\n\n\n\n  /** Get number of files to generate. */\n  self._getNumFiles = function() {\n    return writer__iNumFiles;\n  }\n\n\n\n  /** Set output folder. */\n  self._setOutputFolder = function( pOutputFolder ) {\n    writer__iOutputFolder = pOutputFolder;\n  }\n\n\n\n  /** Get output folder. */\n  self._getOutputFolder = function() {\n    return writer__iOutputFolder;\n  }\n\n\n\n  /** Set backup folder. */\n  self._setBackupFolder = function( pBackupFolder ) {\n    writer__iBackupFolder = pBackupFolder;\n  }\n\n\n\n  /** Get backup folder. */\n  self._getBackupFolder = function() {\n    return writer__iBackupFolder;\n  }\n\n\n\n  /** Set the prefix of backup files. */\n  self._setBackupPrefix = function( pPrefix ) {\n    if( null == pPrefix ) {\n      return; // ignore\n    }\n    writer__iBackupPrefix = pPrefix;\n  }\n\n\n\n  /** Set the suffix of backup files. */\n  self._setBackupSuffix = function( pSuffix ) {\n    if( null == pSuffix ) {\n      return; // ignore\n    }\n    writer__iBackupSuffix = pSuffix;\n  }\n\n\n\n  /** Set to true if generated files are to be backed up to disk automatically. */\n  self._backup = function( pBackup ) {\n    writer__iBackup = pBackup;\n  }\n\n\n\n  /** Set to true if generated files are to be saved to disk automatically. */\n  self._save = function( pSave ) {\n    writer__iSave = pSave;\n  }\n\n\n\n  /** Save a text file. */\n  self._saveTextFile = function( pFilePath, pContent ) {\n    try {\n      var sr = new java.io.StringReader( pContent );\n      var br = new java.io.BufferedReader( sr );\n      var fw = new java.io.FileWriter( pFilePath );\n      var bw = new java.io.BufferedWriter( fw );\n\n      var line = null;\n      while( null != (line = br.readLine()) ) {\n        bw.write( line );\n        bw.newLine();\n      }\n\n      bw.close();\n      br.close();\n    }\n    catch( e ) {\n      throw { runtime:true, msg:e.getMessage() };\n    }\n  }\n\n\n\n  /** Load a text file. */\n  self._loadTextFile = function( pFilePath ) {\n    try {\n      var fr = new java.io.FileReader( new java.io.File( pFilePath ) );\n      var br = new java.io.BufferedReader( fr );\n\n      var line = null;\n      var sb   = [];\n      while( null != ( line = br.readLine() ) ) {\n        sb.push( line+\"\\n\" );\n      }\n      br.close();\n      return sb.join('');\n    }\n    catch( e ) {\n      throw { runtime:true, msg:e.getMessage() };\n    }\n  }\n\n\n  /** Set build properties file. */\n  self._setMetaPropFile = function( pMetaPropFile ) {\n    writer__iMetaPropFile   = pMetaPropFile;\n    writer__iPropertiesInit = false;\n  }\n\n\n\n  /** Get build properties file. */\n  self._getMetaPropFile = function() {\n    return writer__iMetaPropFile;\n  }\n\n  /* Template Services (File Generation) >> */\n\n\n\n\n  /* Template Services (Control) << */\n\n  /** Get the value of a compile-time property. */\n  self._getProperty = function( pName ) {\n    var result = WRITER__STRING_empty;\n\n    if( ! writer__iPropertiesInit ) {\n      writer__initProperties();\n    }\n\n    result = writer__iProperties.getProperty(pName);\n    return result;\n  }\n\n\n\n  /** Get first user arg. */\n  self._getFirstUserArg = function() {\n    return self._getUserArg(0);\n  }\n\n\n\n  /** Get second user arg. */\n  self._getSecondUserArg = function() {\n    return self._getUserArg(1);\n  }\n\n\n\n  /** Get third user arg. */\n  self._getThirdUserArg = function() {\n    return self._getUserArg(2);\n  }\n\n\n\n  /** Get nth (n=0,1,2,...) user arg (the nth arg with no WRITER__ARGUMENT_CONTROL_PREFIX). */\n  self._getUserArg = function( pOrdinal ) {\n    if( pOrdinal < self._getNumUserArgs() ) {\n      var userargs =  self._getUserArgs();\n      return userargs[ pOrdinal ];\n    }\n    else {\n      return WRITER__STRING_empty;\n    }\n  }\n\n\n\n  /** Get user command line arguments to CodeWriter. */\n  self._getUserArgs = function() {\n    return writer__iUserArgs;\n  }\n\n\n\n  /** Get number of user command line arguments to CodeWriter. */\n  self._getNumUserArgs = function() {\n    return writer__iNumUserArgs;\n  }\n\n\n\n  /** Get all command line arguments to CodeWriter. */\n  self._getArgs = function() {\n    return writer__iArgs;\n  }\n\n\n\n  /** Get total number of command line arguments to CodeWriter. */\n  self._getNumArgs = function() {\n    return writer__iNumArgs;\n  }\n\n\n  \n  /** Set a context object for the template to use. */\n  self._setContext = function( pContext ) {\n    writer__iContext = pContext;\n  }\n\n\n\n  /** Get the context object if set. NOTE: may return null. */\n  self._getContext = function() {\n    return writer__iContext;\n  }\n\n  /* Template Services (Control) >> */\n\n\n\n\n  /* Template Services (Text Production) << */\n\n  // inserts\n  self._insert = function( pText ) {\n    writer__iCurrentText.push( pText );\n  }\n\n\n  /** Create a String containing specified number of spaces. */\n  self._spaces = function( pNumSpaces ) {\n    var numSpaces = pNumSpaces;\n    if( 0 > numSpaces ) { numSpaces *= -1; }\n    var spaces = [];\n    for(var spaceI = 0; spaceI < numSpaces; spaceI = spaceI + 1 ) {\n      spaces.push(\" \");\n    }\n    return spaces.join('');\n  }\n\n\n\n  /** Left align String with spaces. */ \n  self._left = function( pText, pColWidth ) {\n    return self._align( pText, \" \", pColWidth, 'l' );\n  } \n\n\n\n  /** Right align String with spaces. */ \n  self._right = function( pText, pColWidth ) {\n    return self._align( pText, \" \", pColWidth, 'r' );\n  } \n\n\n\n  /** Center align String with spaces. */ \n  self._center = function( pText, pColWidth ) {\n    return self._align( pText, \" \", pColWidth, 'c' );\n  } \n\n\n\n  /** Align text within background text to specified column width. \n   *  Alignment can be 'l': left, 'c': center, 'r': right.\n   */\n  self._align = function( pText, pBackText, pColWidth, pAlignment ) {\n    var result = pText;\n \n    if( null == pText ) { \n       result = WRITER__STRING_empty; \n    }\n    else if( null != pBackText ) {\n      try {\n        var textLen = pText.length;\n        if( pColWidth > textLen ) {\n          var backTextLen     = pBackText.length;\n          var remainWidth     = pColWidth - textLen;\n          var backTextRepeats = Math.floor( remainWidth / backTextLen );\n          var backTextRemain  = remainWidth % backTextLen;\n          var back            = WRITER__STRING_empty;\n          for( var backTextI = 0; backTextI < backTextRepeats; backTextI = backTextI + 1 ) {\n            back = back + pBackText;\n          }\n          back = back + pBackText.substring( 0, backTextRemain );\n \n          switch( pAlignment ) {\n          case 'l':\n            result = result + back;\n            break;\n          case 'c':\n            result = back.substring( 0, Math.floor(back.length/2) ) + result + back.substring( Math.floor(back.length/2) );\n            break;\n          case 'r':\n            result = back + result;\n            break;\n          }\n        }\n      } \n      catch( e ) {\n        result = pText;\n      }\n    }\n    return result;\n  }\n\n\n\n  /** Set the text of file currently being generated. */\n  self._setText = function( pText) {\n    writer__iCurrentText = [pText];\n  }\n\n\n\n  /** Get the text of file currently being generated. */\n  self._getText = function() {\n    return writer__iCurrentText.join('');\n  }\n\n\n  /** Set result object (optional). */\n  self._setResult = function( pResult ) {\n    writer__iResult = pResult;\n  }\n\n\n\n  /** Get the result object (may be null). */\n  self._getResult = function() {\n    return writer__iResult;\n  }\n\n  /* Template Services (Text Production) >> */\n\n}\n\n\nvar codewriter = new $<main.CodeWriter>();\n\n/** Execute. */\nfunction main( pArgs ) {\n  var result = codewriter._generate( pArgs, false );\n    \n  var exitvalue = 0;\n  if( !isNan(result) ) {\n    try {\n      exitvalue = parseInt(result);\n    } \n    catch( e ) {\n      // result was not an integer, so ignore it\n    } \n  }\n\n  java.lang.System.exit( exitvalue );\n}\n\n\n!<footer>\n");
    }
