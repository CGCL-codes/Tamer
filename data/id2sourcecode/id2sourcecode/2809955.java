    public void genCsharpCode(File outputDirectory) throws IOException {
        if (!outputDirectory.exists()) {
            if (!outputDirectory.mkdirs()) {
                throw new IOException("Cannnot create directory: " + outputDirectory);
            }
        } else if (!outputDirectory.isDirectory()) {
            throw new IOException(outputDirectory + " is not a directory.");
        }
        File csharpFile = new File(outputDirectory, getName() + ".cs");
        FileWriter cs = new FileWriter(csharpFile);
        cs.write("// File generated by hadoop record compiler. Do not edit.\n");
        cs.write("/**\n");
        cs.write("* Licensed to the Apache Software Foundation (ASF) under one\n");
        cs.write("* or more contributor license agreements.  See the NOTICE file\n");
        cs.write("* distributed with this work for additional information\n");
        cs.write("* regarding copyright ownership.  The ASF licenses this file\n");
        cs.write("* to you under the Apache License, Version 2.0 (the\n");
        cs.write("* \"License\"); you may not use this file except in compliance\n");
        cs.write("* with the License.  You may obtain a copy of the License at\n");
        cs.write("*\n");
        cs.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");
        cs.write("*\n");
        cs.write("* Unless required by applicable law or agreed to in writing, software\n");
        cs.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");
        cs.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
        cs.write("* See the License for the specific language governing permissions and\n");
        cs.write("* limitations under the License.\n");
        cs.write("*/\n");
        cs.write("\n");
        cs.write("using System;\n");
        cs.write("using Org.Apache.Jute;\n");
        cs.write("\n");
        cs.write("namespace " + getCsharpNameSpace() + "\n");
        cs.write("{\n");
        String className = getCsharpName();
        cs.write("public class " + className + " : IRecord, IComparable \n");
        cs.write("{\n");
        cs.write("  public " + className + "() {\n");
        cs.write("  }\n");
        cs.write("  public " + className + "(\n");
        int fIdx = 0;
        int fLen = mFields.size();
        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
            JField jf = i.next();
            cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));
            cs.write((fLen - 1 == fIdx) ? "" : ",\n");
        }
        cs.write(") {\n");
        fIdx = 0;
        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
            JField jf = i.next();
            cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));
        }
        cs.write("  }\n");
        fIdx = 0;
        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
            JField jf = i.next();
            cs.write(jf.genCsharpGetSet(fIdx));
            cs.write("\n");
        }
        cs.write("  public void Serialize(IOutputArchive a_, String tag) {\n");
        cs.write("    a_.StartRecord(this,tag);\n");
        fIdx = 0;
        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
            JField jf = i.next();
            cs.write(jf.genCsharpWriteMethodName());
        }
        cs.write("    a_.EndRecord(this,tag);\n");
        cs.write("  }\n");
        cs.write("  public void Deserialize(IInputArchive a_, String tag) {\n");
        cs.write("    a_.StartRecord(tag);\n");
        fIdx = 0;
        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
            JField jf = i.next();
            cs.write(jf.genCsharpReadMethodName());
        }
        cs.write("    a_.EndRecord(tag);\n");
        cs.write("}\n");
        cs.write("  public override String ToString() {\n");
        cs.write("    try {\n");
        cs.write("      System.IO.MemoryStream ms = new System.IO.MemoryStream();\n");
        cs.write("      MiscUtil.IO.EndianBinaryWriter writer =\n");
        cs.write("        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);\n");
        cs.write("      BinaryOutputArchive a_ = \n");
        cs.write("        new BinaryOutputArchive(writer);\n");
        cs.write("      a_.StartRecord(this,\"\");\n");
        fIdx = 0;
        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
            JField jf = i.next();
            cs.write(jf.genCsharpWriteMethodName());
        }
        cs.write("      a_.EndRecord(this,\"\");\n");
        cs.write("      ms.Position = 0;\n");
        cs.write("      return System.Text.Encoding.UTF8.GetString(ms.ToArray());\n");
        cs.write("    } catch (Exception ex) {\n");
        cs.write("      Console.WriteLine(ex.StackTrace);\n");
        cs.write("    }\n");
        cs.write("    return \"ERROR\";\n");
        cs.write("  }\n");
        cs.write("  public void Write(MiscUtil.IO.EndianBinaryWriter writer) {\n");
        cs.write("    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\n");
        cs.write("    Serialize(archive, \"\");\n");
        cs.write("  }\n");
        cs.write("  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) {\n");
        cs.write("    BinaryInputArchive archive = new BinaryInputArchive(reader);\n");
        cs.write("    Deserialize(archive, \"\");\n");
        cs.write("  }\n");
        cs.write("  public int CompareTo (object peer_) {\n");
        boolean unimplemented = false;
        for (JField f : mFields) {
            if ((f.getType() instanceof JMap) || (f.getType() instanceof JVector)) {
                unimplemented = true;
            }
        }
        if (unimplemented) {
            cs.write("    throw new InvalidOperationException(\"comparing " + getCsharpName() + " is unimplemented\");\n");
        } else {
            cs.write("    if (!(peer_ is " + getCsharpName() + ")) {\n");
            cs.write("      throw new InvalidOperationException(\"Comparing different types of records.\");\n");
            cs.write("    }\n");
            cs.write("    " + getCsharpName() + " peer = (" + getCsharpName() + ") peer_;\n");
            cs.write("    int ret = 0;\n");
            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
                JField jf = i.next();
                cs.write(jf.genCsharpCompareTo());
                cs.write("    if (ret != 0) return ret;\n");
            }
            cs.write("     return ret;\n");
        }
        cs.write("  }\n");
        cs.write("  public override bool Equals(object peer_) {\n");
        cs.write("    if (!(peer_ is " + getCsharpName() + ")) {\n");
        cs.write("      return false;\n");
        cs.write("    }\n");
        cs.write("    if (peer_ == this) {\n");
        cs.write("      return true;\n");
        cs.write("    }\n");
        cs.write("    bool ret = false;\n");
        cs.write("    " + getCsharpName() + " peer = (" + getCsharpName() + ")peer_;\n");
        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
            JField jf = i.next();
            cs.write(jf.genCsharpEquals());
            cs.write("    if (!ret) return ret;\n");
        }
        cs.write("     return ret;\n");
        cs.write("  }\n");
        cs.write("  public override int GetHashCode() {\n");
        cs.write("    int result = 17;\n");
        cs.write("    int ret;\n");
        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
            JField jf = i.next();
            cs.write(jf.genCsharpHashCode());
            cs.write("    result = 37*result + ret;\n");
        }
        cs.write("    return result;\n");
        cs.write("  }\n");
        cs.write("  public static string Signature() {\n");
        cs.write("    return \"" + getSignature() + "\";\n");
        cs.write("  }\n");
        cs.write("}\n");
        cs.write("}\n");
        cs.close();
    }
