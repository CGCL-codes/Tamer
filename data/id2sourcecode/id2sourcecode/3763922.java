    public static void writeVECTestingMain(PrintStream ps, String fxnBaseName, String baseName, IOHandler ioHandle) {
        ps.println();
        ps.println("/* Start of testbench code */");
        ps.println("#include <stdio.h>");
        ps.println("");
        ps.println("/*");
        ps.println(" * Parses the xxx_input_blocks.vec file format, counts the number of");
        ps.println(" * data elements, and stores the data elements into 'ptr' iff doSave");
        ps.println(" * is non-zero.  If doSave is zero, then this function only counts the");
        ps.println(" * number of input elements.  If 'supplyValid' is true then the skipped");
        ps.println(" * line defines the 'is valid' flag for the results until the next");
        ps.println(" * 'skipped' line");
        ps.println(" */");
        ps.println("long long validValue;");
        ps.println("long long value;");
        ps.println("char tempBuf[256];");
        ps.println("int getVECData (FILE *fp, long long *ptr, long long *validPtr, int doSave, int skipLine, int supplyValid)");
        ps.println("{");
        ps.println("    int inputValuesCount = 0;");
        ps.println("    validValue = 1;");
        ps.println("    while(1)");
        ps.println("    {");
        ps.println("        if (fscanf(fp, \"%llx\", &value) > 0)");
        ps.println("        {");
        ps.println("            if (doSave)");
        ps.println("            {");
        ps.println("                ptr[inputValuesCount] = value;");
        ps.println("                if (supplyValid) {");
        ps.println("                    validPtr[inputValuesCount] = validValue;");
        ps.println("                }");
        ps.println("                //printf(\"%08x\\n\", value);");
        ps.println("            }");
        ps.println("            inputValuesCount++;");
        ps.println("        }");
        ps.println("        else");
        ps.println("        {");
        ps.println("            int cmp = fscanf(fp, \"%[/blockforiteration0123456789 ]\\n\",tempBuf);");
        ps.println("            // String length will be 2 if all we catch is the double");
        ps.println("            // slash in pad data comment");
        ps.println("            if (cmp <= 0 || (strlen(tempBuf) <= 2))");
        ps.println("            {");
        ps.println("                break;");
        ps.println("            }");
        ps.println("            else if (skipLine)");
        ps.println("            {");
        ps.println("                if (fscanf(fp, \"%llx\", &validValue) > 0)");
        ps.println("                {");
        ps.println("                    /*printf(\"Skipping line\\n\");*/");
        ps.println("                }");
        ps.println("                else");
        ps.println("                {");
        ps.println("                    printf(\"Error trying to skip line! %s\\n\", tempBuf);");
        ps.println("                }");
        ps.println("            }");
        ps.println("        }");
        ps.println("    }");
        ps.println("    return inputValuesCount;");
        ps.println("}");
        ps.println("");
        ps.println("/*");
        ps.println(" * Finds the first input value after //pad data and returns that.  In");
        ps.println(" * the verilog simulation it is this value that is fed to the core");
        ps.println(" * after all the input data has been exhausted.");
        ps.println(" */");
        ps.println("int getLast (FILE *fp, long long *ptr, int count)");
        ps.println("{");
        ps.println("    int cnt = 0;");
        ps.println("    while (1)");
        ps.println("    {");
        ps.println("        if (fscanf(fp, \"%llx\", &value) > 0)");
        ps.println("        {");
        ps.println("            ptr[cnt] = value;");
        ps.println("            cnt++;");
        ps.println("            if (cnt == count)");
        ps.println("            {");
        ps.println("                break;");
        ps.println("            }");
        ps.println("        }");
        ps.println("        else");
        ps.println("        {");
        ps.println("            int cmp = fscanf(fp, \"%[/paddata ]\\n\", tempBuf);");
        ps.println("            if (cmp <= 0)");
        ps.println("            {");
        ps.println("                break;");
        ps.println("            }");
        ps.println("        }");
        ps.println("    }");
        ps.println("    return cnt;");
        ps.println("}");
        ps.println("");
        ps.println("#define VERILOG_EXISTS_DELAY 11");
        ps.println("int main (int argc, char *argv[])");
        ps.println("{");
        ps.println("    char *progname = argv[0];");
        ps.println("    int verbose = 0;");
        ps.println("    if (argc > 1) { verbose = atoi(argv[1]); }");
        ps.println("    char *inName = \"" + baseName + "_input_blocks.vec\";");
        ps.println("    char *expName = \"" + baseName + "_output_expected.vec\";");
        ps.println("    char *outName = \"" + baseName + "_c_sim.results\";");
        ps.println("    // Count and read in the input data elements");
        ps.println("    FILE *input = fopen(inName, \"r\");");
        ps.println("    input = fopen(inName, \"r\");");
        ps.println("    int inputFinalCount = getVECData(input, NULL, NULL, 0, 0, 0);");
        ps.println("    fclose(input);");
        ps.println("    input = fopen(inName, \"r\");");
        ps.println("    long long *inData = (long long*)malloc((inputFinalCount * 8) + 1);");
        ps.println("    getVECData(input, inData, NULL, 1, 0, 0);");
        ps.println("    int trailerCount = getLast(input, &(inData[inputFinalCount]), 1);");
        ps.println("");
        ps.println("    // Count and read in the expected results");
        ps.println("    FILE *expFile = fopen(expName, \"r\");");
        ps.println("    int expFinalCount = getVECData(expFile, NULL, NULL, 0, 1, 0);");
        ps.println("    fclose(expFile);");
        ps.println("    expFile = fopen(expName, \"r\");");
        ps.println("    long long *expected = (long long*)malloc(expFinalCount * 8);");
        ps.println("    long long *expValid = (long long*)malloc(expFinalCount * 8);");
        ps.println("    getVECData(expFile, expected, expValid, 1, 1, 1);");
        ps.println("");
        ps.println("    // Now get the masking data from the expected file");
        ps.println("    // Assume no more than 8K elements in the output blocks.");
        ps.println("    long long *expMasks = (long long *)malloc(8192 * 8);");
        ps.println("    int expMaskCount = getLast(expFile, expMasks, 8192);");
        ps.println("    // The expected data has 1 extra 'pad' at the end... UGH!");
        ps.println("    expMaskCount--;");
        ps.println("    fclose(expFile);");
        ps.println("");
        ps.println("    // Open the cycle data output file");
        ps.println("    FILE *output = fopen(outName, \"w\");");
        ps.println("");
        ps.println("    // Run the simulation.");
        ps.println("    int inputCount = 0;");
        ps.println("    int cycleCount = 0;");
        ps.println("    int expCount = 0;");
        ps.println("    int expMaskIndex = 0;");
        ps.println("    int errors = 0;");
        ps.println("    int doOneMore = 0;");
        ps.println("    int dataExistsDelay = 0;");
        ps.println("    int hangTimer = 0;");
        ps.println("    while ((expCount < expFinalCount) || doOneMore)");
        ps.println("    {");
        ps.println("        doOneMore = 0;");
        ps.println("        if (hangTimer > " + HANG_TIMER_EXP + ") {");
        ps.println("            fprintf(output, \"HANG TIMER EXPIRED\\n\");");
        ps.println("            errors++;");
        ps.println("        }");
        ps.println("        hangTimer++;");
        ps.println("        if (inputs[0]->read)");
        ps.println("        {");
        ps.println("            inputCount++;");
        ps.println("            hangTimer = 0;");
        ps.println("        }");
        ps.println("        inputs[0]->data = inData[inputCount];");
        ps.println("        inputs[0]->exists = (inputCount < inputFinalCount) ? ((dataExistsDelay > VERILOG_EXISTS_DELAY) ? 1:0):0;");
        ps.println("        outputs[0]->full = 0;");
        ps.println("");
        ps.println("        " + fxnBaseName + "_update();");
        ps.println("        " + fxnBaseName + "_clockEdge();");
        ps.println("");
        ps.println("        // Verify the result");
        ps.println("        long long expectedValid = expValid[expCount];");
        ps.println("        long long mask = expMasks[expMaskIndex];");
        ps.println("        long long maskedResult = outputs[0]->data & mask;");
        ps.println("        long long maskedExpected = expected[expCount] & mask;");
        ps.println("        //printf(\"result %d #%d %llx expected %016llx obtained %016llx\\n\", expMaskIndex, expCount, mask, maskedExpected, maskedResult);");
        ps.println("        if (outputs[0]->write)");
        ps.println("        {");
        ps.println("            if ((expectedValid != 0) && (maskedResult != maskedExpected))");
        ps.println("            {");
        ps.println("                printf(\"ERROR Result error! result #%d expected %016llx obtained %016llx\\n\", expCount, maskedExpected, maskedResult);");
        ps.println("                errors++;");
        ps.println("            }");
        ps.println("            expMaskIndex = (expMaskIndex == (expMaskCount - 1)) ? 0:(expMaskIndex + 1);");
        ps.println("            expCount++;");
        ps.println("            doOneMore = (expCount == expFinalCount);");
        ps.println("            hangTimer = 0;");
        ps.println("        }");
        ps.println("        ");
        ps.println("        if (cycleCount > 0 || inputs[0]->read || outputs[0]->write)");
        ps.println("        {");
        ps.println("            //printf(\"%08x %08x %01x %08x %01x\\n\", cycleCount, inputs[0]->data, inputs[0]->read, outputs[0]->data, outputs[0]->write);");
        if (ioHandle.getInputCount() > 0 && ioHandle.getOutputCount() > 0) ps.println("            fprintf(output, \"%08x %08x %01x %08x %01x\\n\", cycleCount, inputs[0]->data, inputs[0]->read, outputs[0]->data, outputs[0]->write);"); else if (ioHandle.getInputCount() == 0 && ioHandle.getOutputCount() != 0) ps.println("            fprintf(output, \"%08x xxxxxxxx z %08x %01x\\n\", cycleCount, outputs[0]->data, outputs[0]->write);"); else if (ioHandle.getInputCount() != 0 && ioHandle.getOutputCount() == 0) ps.println("            fprintf(output, \"%08x %08x %01x xxxxxxxx z\\n\", cycleCount, inputs[0]->data, inputs[0]->read);"); else ps.println("            fprintf(output, \"%08x %08x %01x %08x %01x\\n\", cycleCount, inputs[0]->data, inputs[0]->read, outputs[0]->data, outputs[0]->write);");
        ps.println("            cycleCount++;");
        ps.println("        }");
        ps.println("        dataExistsDelay++;");
        ps.println("    }");
        ps.println("");
        ps.println("    if (!errors)");
        ps.println("    {");
        ps.println("        if (verbose) { printf(\"PASSED '%s' %d valid writes.\\n\", progname, expFinalCount); }");
        ps.println("    }");
        ps.println("    else");
        ps.println("    {");
        ps.println("        printf(\"ERRORS during '%s': %d errors across %d output writes.\\n\", progname, errors, expFinalCount);");
        ps.println("    }");
        ps.println("    ");
        ps.println("    fclose(output);");
        ps.println("");
        ps.println("    return errors;");
        ps.println("}");
        ps.println("");
        ps.println();
        ps.println("/* End of testbench code */");
    }
